/**
 * skylark-videojs - A version of video.js that ported to running on skylarkjs.
 * @author Hudaokeji Co.,Ltd
 * @version v0.9.0
 * @link www.skylarkjs.org
 * @license MIT
 */
(function(factory,globals) {
  var define = globals.define,
      require = globals.require,
      isAmd = (typeof define === 'function' && define.amd),
      isCmd = (!isAmd && typeof exports !== 'undefined');

  if (!isAmd && !define) {
    var map = {};
    function absolute(relative, base) {
        if (relative[0]!==".") {
          return relative;
        }
        var stack = base.split("/"),
            parts = relative.split("/");
        stack.pop(); 
        for (var i=0; i<parts.length; i++) {
            if (parts[i] == ".")
                continue;
            if (parts[i] == "..")
                stack.pop();
            else
                stack.push(parts[i]);
        }
        return stack.join("/");
    }
    define = globals.define = function(id, deps, factory) {
        if (typeof factory == 'function') {
            map[id] = {
                factory: factory,
                deps: deps.map(function(dep){
                  return absolute(dep,id);
                }),
                resolved: false,
                exports: null
            };
            require(id);
        } else {
            map[id] = {
                factory : null,
                resolved : true,
                exports : factory
            };
        }
    };
    require = globals.require = function(id) {
        if (!map.hasOwnProperty(id)) {
            throw new Error('Module ' + id + ' has not been defined');
        }
        var module = map[id];
        if (!module.resolved) {
            var args = [];

            module.deps.forEach(function(dep){
                args.push(require(dep));
            })

            module.exports = module.factory.apply(globals, args) || null;
            module.resolved = true;
        }
        return module.exports;
    };
  }
  
  if (!define) {
     throw new Error("The module utility (ex: requirejs or skylark-utils) is not loaded!");
  }

  factory(define,require);

  if (!isAmd) {
    var skylarkjs = require("skylark-langx-ns");

    if (isCmd) {
      module.exports = skylarkjs;
    } else {
      globals.skylarkjs  = skylarkjs;
    }
  }

})(function(define,require) {

define('skylark-langx-ns/_attach',[],function(){
    return  function attach(obj1,path,obj2) {
        if (typeof path == "string") {
            path = path.split(".");//[path]
        };
        var length = path.length,
            ns=obj1,
            i=0,
            name = path[i++];

        while (i < length) {
            ns = ns[name] = ns[name] || {};
            name = path[i++];
        }

        return ns[name] = obj2;
    }
});
define('skylark-langx-ns/ns',[
    "./_attach"
], function(_attach) {
    var skylark = {
    	attach : function(path,obj) {
    		return _attach(skylark,path,obj);
    	}
    };
    return skylark;
});

define('skylark-langx-ns/main',[
	"./ns"
],function(skylark){
	return skylark;
});
define('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });

define('skylark-langx/skylark',[
    "skylark-langx-ns"
], function(ns) {
	return ns;
});

define('skylark-langx-globals/globals',[
	"skylark-langx-ns"
],function(ns) {
	var globals = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		} else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	return ns.attach("langx.globals",globals);

});
define('skylark-langx-globals/window',[
	"./globals"
], function(globals) {

	var win = (function() {
		if (typeof window !== "undefined") {
		    return window;
		} else {
		    return {};
		}
	})();

	return globals.window = win;
});

define('skylark-langx-types/types',[
    "skylark-langx-ns"
],function(skylark){
    var nativeIsArray = Array.isArray, 
        toString = {}.toString;
    
    var type = (function() {
        var class2type = {};

        // Populate the class2type map
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" ").forEach(function(name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        return function type(obj) {
            return obj == null ? String(obj) :
                class2type[toString.call(obj)] || "object";
        };
    })();

 
    var  isArray = nativeIsArray || function(obj) {
        return object && object.constructor === Array;
    };


    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function/string/element and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * isArrayLike([1, 2, 3])
     * // => true
     *
     * isArrayLike(document.body.children)
     * // => false
     *
     * isArrayLike('abc')
     * // => true
     *
     * isArrayLike(Function)
     * // => false
     */    
    function isArrayLike(obj) {
        return !isString(obj) && !isHtmlNode(obj) && typeof obj.length == 'number' && !isFunction(obj);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * isBoolean(false)
     * // => true
     *
     * isBoolean(null)
     * // => false
     */
    function isBoolean(obj) {
       return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
       //return typeof(obj) === "boolean";
    }

    function isDefined(obj) {
        return typeof obj !== 'undefined';
    }

    function isDocument(obj) {
        return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
    }

   // Is a given value a DOM element?
    function isElement(obj) {
        return !!(obj && obj.nodeType === 1);
    }   

    function isEmptyObject(obj) {
        var name;
        for (name in obj) {
            if (obj[name] !== null) {
                return false;
            }
        }
        return true;
    }


    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * isFunction(parseInt)
     * // => true
     *
     * isFunction(/abc/)
     * // => false
     */
    function isFunction(value) {
        return type(value) == "function";
    }



    function isHtmlNode(obj) {
        return obj && obj.nodeType; // obj instanceof Node; //Consider the elements in IFRAME
    }

    function isInstanceOf( /*Object*/ value, /*Type*/ type) {
        //Tests whether the value is an instance of a type.
        if (value === undefined) {
            return false;
        } else if (value === null || type == Object) {
            return true;
        } else if (typeof value === "number") {
            return type === Number;
        } else if (typeof value === "string") {
            return type === String;
        } else if (typeof value === "boolean") {
            return type === Boolean;
        } else if (typeof value === "string") {
            return type === String;
        } else {
            return (value instanceof type) || (value && value.isInstanceOf ? value.isInstanceOf(type) : false);
        }
    }

    function isNull(obj) {
        return obj === null;
    }

    function isNumber(obj) {
        return typeof obj == 'number';
    }

    function isObject(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;        
        //return type(obj) == "object";
    }

    function isPlainObject(obj) {
        return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
    }

    function isString(obj) {
        return typeof obj === 'string';
    }

    function isWindow(obj) {
        return obj && obj == obj.window;
    }

    function isSameOrigin(href) {
        if (href) {
            var origin = location.protocol + '//' + location.hostname;
            if (location.port) {
                origin += ':' + location.port;
            }
            return href.startsWith(origin);
        }
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }

    // Is a given variable undefined?
    function isUndefined(obj) {
        return obj === void 0;
    }


    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }   

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }





    return skylark.attach("langx.types",{

        isArray: isArray,

        isArrayLike: isArrayLike,

        isBoolean: isBoolean,

        isDefined: isDefined,

        isDocument: isDocument,

        isElement,

        isEmpty : isEmptyObject,

        isEmptyObject: isEmptyObject,

        isFunction: isFunction,

        isHtmlNode: isHtmlNode,

        isNaN : function (obj) {
            return isNaN(obj);
        },

        isNull: isNull,


        isNumber: isNumber,

        isNumeric: isNumber,

        isObject: isObject,

        isPlainObject: isPlainObject,

        isString: isString,

        isSameOrigin: isSameOrigin,

        isSymbol : isSymbol,

        isUndefined: isUndefined,

        isWindow: isWindow,

        type: type,

        toFinite : toFinite,
        toNumber : toNumber,
        toInteger : toInteger
        
    });

});
define('skylark-langx-types/main',[
	"./types"
],function(types){
	return types;
});
define('skylark-langx-types', ['skylark-langx-types/main'], function (main) { return main; });

define('skylark-langx-objects/objects',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        slice = Array.prototype.slice,
        isBoolean = types.isBoolean,
        isFunction = types.isFunction,
        isObject = types.isObject,
        isPlainObject = types.isPlainObject,
        isArray = types.isArray,
        isArrayLike = types.isArrayLike,
        isString = types.isString,
        toInteger = types.toInteger;

     // An internal function for creating assigner functions.
    function createAssigner(keysFunc, defaults) {
        return function(obj) {
          var length = arguments.length;
          if (defaults) obj = Object(obj);  
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
       };
    }

    // Internal recursive comparison function for `isEqual`.
    var eq, deepEq;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // `null` or `undefined` only equal to itself (strict comparison).
        if (a == null || b == null) return false;
        // `NaN`s are equivalent, but non-reflexive.
        if (a !== a) return b !== b;
        // Exhaust primitive checks
        var type = typeof a;
        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
        return deepEq(a, b, aStack, bStack);
    };

    // Internal recursive comparison function for `isEqual`.
    deepEq = function(a, b, aStack, bStack) {
        // Unwrap any wrapped objects.
        //if (a instanceof _) a = a._wrapped;
        //if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, regular expressions, dates, and booleans are compared by value.
            case '[object RegExp]':
            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return '' + a === '' + b;
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive.
                // Object(NaN) is equivalent to NaN.
                if (+a !== +a) return +b !== +b;
                // An `egal` comparison is performed for other numeric values.
                return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a === +b;
            case '[object Symbol]':
                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        }

        var areArrays = className === '[object Array]';
        if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object') return false;
            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&
                               isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
                return false;
            }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a) return bStack[length] === b;
        }

        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);

        // Recursively compare objects and arrays.
        if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length) return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
                if (!eq(a[length], b[length], aStack, bStack)) return false;
            }
        } else {
            // Deep compare objects.
            var keys = Object.keys(a), key;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (Object.keys(b).length !== length) return false;
            while (length--) {
                // Deep compare each member
                key = keys[length];
                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
    };

    // Retrieve all the property names of an object.
    function allKeys(obj) {
        if (!isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }

    function each(obj, callback,isForEach) {
        var length, key, i, undef, value;

        if (obj) {
            length = obj.length;

            if (length === undef) {
                // Loop object items
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        value = obj[key];
                        if ((isForEach ? callback.call(value, value, key) : callback.call(value, key, value) ) === false) {
                            break;
                        }
                    }
                }
            } else {
                // Loop array items
                for (i = 0; i < length; i++) {
                    value = obj[i];
                    if ((isForEach ? callback.call(value, value, i) : callback.call(value, i, value) )=== false) {
                        break;
                    }
                }
            }
        }

        return this;
    }

    function extend(target) {
        var deep, args = slice.call(arguments, 1);
        if (typeof target == 'boolean') {
            deep = target
            target = args.shift()
        }
        if (args.length == 0) {
            args = [target];
            target = this;
        }
        args.forEach(function(arg) {
            mixin(target, arg, deep);
        });
        return target;
    }

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    function keys(obj) {
        if (isObject(obj)) return [];
        var keys = [];
        for (var key in obj) if (has(obj, key)) keys.push(key);
        return keys;
    }

    function has(obj, path) {
        if (!isArray(path)) {
            return obj != null && hasOwnProperty.call(obj, path);
        }
        var length = path.length;
        for (var i = 0; i < length; i++) {
            var key = path[i];
            if (obj == null || !hasOwnProperty.call(obj, key)) {
                return false;
            }
            obj = obj[key];
        }
        return !!length;
    }

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }


   // Perform a deep comparison to check if two objects are equal.
    function isEqual(a, b) {
        return eq(a, b);
    }

    // Returns whether an object has a given set of `key:value` pairs.
    function isMatch(object, attrs) {
        var keys = keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
    }    

    function _mixin(target, source, deep, safe) {
        for (var key in source) {
            //if (!source.hasOwnProperty(key)) {
            //    continue;
            //}
            if (safe && target[key] !== undefined) {
                continue;
            }
            // if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
            //    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
            if (deep && isPlainObject(source[key])) {
                if (!isPlainObject(target[key])) {
                    target[key] = {};
                }
                //if (isArray(source[key]) && !isArray(target[key])) {
                //    target[key] = [];
                //}
                _mixin(target[key], source[key], deep, safe);
            } else if (source[key] !== undefined) {
                target[key] = source[key]
            }
        }
        return target;
    }

    function _parseMixinArgs(args) {
        var params = slice.call(arguments, 0),
            target = params.shift(),
            deep = false;
        if (isBoolean(params[params.length - 1])) {
            deep = params.pop();
        }

        return {
            target: target,
            sources: params,
            deep: deep
        };
    }

    function mixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, false);
        });
        return args.target;
    }

   // Return a copy of the object without the blacklisted properties.
    function omit(obj, prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = mixin({},obj);
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                delete result[pn];
            }
        }
        return result;

    }

   // Return a copy of the object only containing the whitelisted properties.
    function pick(obj,prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = {};
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                result[pn] = obj[pn];
            }
        }
        return result;
    }

    function removeItem(items, item) {
        if (isArray(items)) {
            var idx = items.indexOf(item);
            if (idx != -1) {
                items.splice(idx, 1);
            }
        } else if (isPlainObject(items)) {
            for (var key in items) {
                if (items[key] == item) {
                    delete items[key];
                    break;
                }
            }
        }

        return this;
    }

    function result(obj, path, fallback) {
        if (!isArray(path)) {
            path = path.split(".");//[path]
        };
        var length = path.length;
        if (!length) {
          return isFunction(fallback) ? fallback.call(obj) : fallback;
        }
        for (var i = 0; i < length; i++) {
          var prop = obj == null ? void 0 : obj[path[i]];
          if (prop === void 0) {
            prop = fallback;
            i = length; // Ensure we don't continue iterating.
          }
          obj = isFunction(prop) ? prop.call(obj) : prop;
        }

        return obj;
    }

    function safeMixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, true);
        });
        return args.target;
    }

    // Retrieve the values of an object's properties.
    function values(obj) {
        var keys = allKeys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    }

    function clone( /*anything*/ src,checkCloneMethod) {
        var copy;
        if (src === undefined || src === null) {
            copy = src;
        } else if (checkCloneMethod && src.clone) {
            copy = src.clone();
        } else if (isArray(src)) {
            copy = [];
            for (var i = 0; i < src.length; i++) {
                copy.push(clone(src[i]));
            }
        } else if (isPlainObject(src)) {
            copy = {};
            for (var key in src) {
                copy[key] = clone(src[key]);
            }
        } else {
            copy = src;
        }

        return copy;

    }

    function scall(obj,method,arg1,arg2) {
        if (obj && obj[method]) {
            var args = slice.call(arguments, 2);

            return obj[method].apply(obj,args);
        }
    }

    return skylark.attach("langx.objects",{
        allKeys: allKeys,

        attach : skylark.attach,

        clone: clone,

        defaults : createAssigner(allKeys, true),

        each : each,

        extend : extend,

        has: has,

        isEqual: isEqual,   

        includes: includes,

        isMatch: isMatch,

        keys: keys,

        mixin: mixin,

        omit: omit,

        pick: pick,

        removeItem: removeItem,

        result : result,
        
        safeMixin: safeMixin,

        scall,

        values: values
    });


});
define('skylark-langx-objects/main',[
	"./objects"
],function(objects){
	return objects;
});
define('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });

define('skylark-langx-arrays/arrays',[
  "skylark-langx-ns",
  "skylark-langx-types",
  "skylark-langx-objects"
],function(skylark,types,objects){
    var filter = Array.prototype.filter,
        find = Array.prototype.find,
        isArrayLike = types.isArrayLike;

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }


    function compact(array) {
        return filter.call(array, function(item) {
            return item != null;
        });
    }

    function filter2(array,func) {
      return filter.call(array,func);
    }

    function flatten(array) {
        if (isArrayLike(array)) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                if (isArrayLike(item)) {
                    for (var j = 0; j < item.length; j++) {
                        result.push(item[j]);
                    }
                } else {
                    result.push(item);
                }
            }
            return result;
        } else {
            return array;
        }
        //return array.length > 0 ? concat.apply([], array) : array;
    }

    function grep(array, callback) {
        var out = [];

        objects.each(array, function(i, item) {
            if (callback(item, i)) {
                out.push(item);
            }
        });

        return out;
    }

    function inArray(item, array) {
        if (!array) {
            return -1;
        }
        var i;

        if (array.indexOf) {
            return array.indexOf(item);
        }

        i = array.length;
        while (i--) {
            if (array[i] === item) {
                return i;
            }
        }

        return -1;
    }

    function makeArray(obj, offset, startWith) {
       if (isArrayLike(obj) ) {
        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
      }

      // array of single index
      return [ obj ];             
    }


    function forEach (arr, fn) {
      if (arr.forEach) return arr.forEach(fn)
      for (var i = 0; i < arr.length; i++) fn(arr[i], i);
    }

    function map(elements, callback) {
        var value, values = [],
            i, key
        if (isArrayLike(elements))
            for (i = 0; i < elements.length; i++) {
                value = callback.call(elements[i], elements[i], i);
                if (value != null) values.push(value)
            }
        else
            for (key in elements) {
                value = callback.call(elements[key], elements[key], key);
                if (value != null) values.push(value)
            }
        return flatten(values)
    }


    function merge( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }

    function reduce(array,callback,initialValue) {
        return Array.prototype.reduce.call(array,callback,initialValue);
    }

    function uniq(array) {
        return filter.call(array, function(item, idx) {
            return array.indexOf(item) == idx;
        })
    }

    function find2(array,func) {
      return find.call(array,func);
    }

    return skylark.attach("langx.arrays",{
        baseFindIndex: baseFindIndex,

        baseIndexOf : baseIndexOf,
        
        compact: compact,

        first : function(items,n) {
            if (n) {
                return items.slice(0,n);
            } else {
                return items[0];
            }
        },

        filter : filter2,

        find : find2,
        
        flatten: flatten,

        grep: grep,

        inArray: inArray,

        makeArray: makeArray, // 

        toArray : makeArray,

        merge : merge,

        forEach : forEach,

        map : map,
        
        reduce : reduce,

        uniq : uniq

    });
});
define('skylark-langx-arrays/main',[
	"./arrays"
],function(arrays){
	return arrays;
});
define('skylark-langx-arrays', ['skylark-langx-arrays/main'], function (main) { return main; });

define('skylark-langx-funcs/funcs',[
  "skylark-langx-ns",
],function(skylark,types,objects){
        



    function noop() {
    }




    return skylark.attach("langx.funcs",{
        noop : noop,

        returnTrue: function() {
            return true;
        },

        returnFalse: function() {
            return false;
        }

    });
});
define('skylark-langx-funcs/defer',[
    "./funcs"
],function(funcs){
    function defer(fn,args,context) {
        var ret = {
            stop : null
        },
        id,
        fn1 = fn;

        if (args) {
            fn1 = function() {
                fn.apply(context,args);
            };
        }
        if (requestAnimationFrame) {
            id = requestAnimationFrame(fn1);
            ret.stop = function() {
                return cancelAnimationFrame(id);
            };
        } else {
            id = setTimeoutout(fn1);
            ret.stop = function() {
                return clearTimeout(id);
            };
        }
        return ret;
    }

    return funcs.defer = defer;
});
define('skylark-langx-funcs/debounce',[
	"./funcs",
    "./defer"
],function(funcs,defer){
   
    function debounce(fn, wait,useAnimationFrame) {
        var timeout,
            defered;

        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (useAnimationFrame) {
                    defered = defer(fn,args,context);
                } else {
                    fn.apply(context, args);
                }
            };

            function stop() {
                if (timeout) {
                    clearTimeout(timeout);
                }
                if (defered) {
                    defered.stop();
                }
                timeout = void 0;
                defered = void 0;
            }

            stop();
            timeout = setTimeout(later, wait);

            return {
                stop 
            };
        };
    }

    return funcs.debounce = debounce;

});
define('skylark-langx-funcs/delegate',[
  "skylark-langx-objects",
  "./funcs"
],function(objects,funcs){
	var mixin = objects.mixin;

    var delegate = (function() {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {}
        return function(obj, props) {
            TMP.prototype = obj;
            var tmp = new TMP();
            TMP.prototype = null;
            if (props) {
                mixin(tmp, props);
            }
            return tmp; // Object
        };
    })();

    return funcs.delegate = delegate;

});
define('skylark-langx-funcs/loop',[
	"./funcs"
],function(funcs){

	/**
	 * Animation timer is a special type of timer that uses the requestAnimationFrame method.
	 *
	 * This timer calls the method with the same rate as the screen refesh rate.
	 * 
	 * Loop time can be changed dinamically.
	 *
	 * @class AnimationTimer
	 * @param {Function} callback Timer callback function.
	 */
	function AnimationTimer(callback)
	{
		this.callback = callback;

		this.running = false;
		this.id = -1;
	}

	/**
	 * Start timer, is the timer is already running dosen't do anything.
	 * 
	 * @method start
	 */
	AnimationTimer.prototype.start = function()
	{
		if(this.running)
		{
			return;
		}

		this.running = true;

		var self = this;
		function run()
		{
			self.callback();

			if(self.running)
			{
				self.id = requestAnimationFrame(run);
			}
		}

		run();
	};

	/**
	 * Stop animation timer.
	 * 
	 * @method stop
	 */
	AnimationTimer.prototype.stop = function()
	{
		this.running = false;
		cancelAnimationFrame(this.id);
	};

	function loop(fn) {
		return new AnimationTimer(fn);
    }

    return funcs.loop = loop;
});
define('skylark-langx-funcs/negate',[
	"./funcs"
],function(funcs){
   
    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0
     * }
     *
     * filter([1, 2, 3, 4, 5, 6], negate(isEven))
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate !== 'function') {
        throw new TypeError('Expected a function')
      }
      return function(...args) {
        return !predicate.apply(this, args)
      }
    }


    return funcs.negate = negate;

});
define('skylark-langx-funcs/proxy',[
  "skylark-langx-types",
	"./funcs"
],function(types,funcs){
    var slice = Array.prototype.slice,
        isFunction = types.isFunction,
        isString = types.isString;

    function proxy(fn, context) {
        var args = (2 in arguments) && slice.call(arguments, 2)
        if (isFunction(fn)) {
            var proxyFn = function() {
                return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
            }
            return proxyFn;
        } else if (isString(context)) {
            if (args) {
                args.unshift(fn[context], fn)
                return proxy.apply(null, args)
            } else {
                return proxy(fn[context], fn);
            }
        } else {
            throw new TypeError("expected function");
        }
    }

    return funcs.bind = funcs.proxy = proxy;

});
define('skylark-langx-funcs/template',[
  "skylark-langx-objects",
  "./funcs",
  "./proxy"
],function(objects,funcs,proxy){
    var slice = Array.prototype.slice;

   
    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    var templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;


    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;


    function template(text, data, settings) {
        var render;
        settings = objects.defaults({}, settings,templateSettings);

        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');

        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset)
              .replace(escaper, function(match) { return '\\' + escapes[match]; });

          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          }
          if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          }
          if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + 'return __p;\n';

        try {
          render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }

        if (data) {
          return render(data,this)
        }
        var template = proxy(function(data) {
          return render.call(this, data,this);
        },this);

        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';

        return template;
    }

    template.templateSettings = funcs.templateSettings = templateSettings;

    return funcs.template = template;

});
define('skylark-langx-funcs/throttle',[
  "./funcs"
],function(funcs){

    const throttle = function (fn, wait) {
        let last = window.performance.now();
        const throttled = function (...args) {
            const now = window.performance.now();
            if (now - last >= wait) {
                fn(...args);
                last = now;
            }
        };
        return throttled;
    };

    return funcs.throttle = throttle;
});
define('skylark-langx-funcs/main',[
	"./funcs",
	"./debounce",
	"./defer",
	"./delegate",
	"./loop",
	"./negate",
	"./proxy",
	"./template",
	"./throttle"
],function(funcs){
	return funcs;
});
define('skylark-langx-funcs', ['skylark-langx-funcs/main'], function (main) { return main; });

define('skylark-langx-async/Deferred',[
    "skylark-langx-arrays",
	"skylark-langx-funcs",
    "skylark-langx-objects"
],function(arrays,funcs,objects){
    "use strict";

    var slice = Array.prototype.slice,
        proxy = funcs.proxy,
        makeArray = arrays.makeArray,
        result = objects.result,
        mixin = objects.mixin;

    mixin(Promise.prototype,{
        always: function(handler) {
            //this.done(handler);
            //this.fail(handler);
            this.then(handler,handler);
            return this;
        },
        done : function() {
            for (var i = 0;i<arguments.length;i++) {
                this.then(arguments[i]);
            }
            return this;
        },
        fail : function(handler) { 
            //return mixin(Promise.prototype.catch.call(this,handler),added);
            //return this.then(null,handler);
            this.catch(handler);
            return this;
         }
    });


    var Deferred = function() {
        var self = this,
            p = this.promise = makePromise2(new Promise(function(resolve, reject) {
                self._resolve = resolve;
                self._reject = reject;
            }));

        //wrapPromise(p,self);

        //this[PGLISTENERS] = [];
        //this[PGNOTIFIES] = [];

        //this.resolve = Deferred.prototype.resolve.bind(this);
        //this.reject = Deferred.prototype.reject.bind(this);
        //this.progress = Deferred.prototype.progress.bind(this);

    };

   
    function makePromise2(promise) {
        // Don't modify any promise that has been already modified.
        if (promise.isResolved) return promise;

        // Set initial state
        var isPending = true;
        var isRejected = false;
        var isResolved = false;

        // Observe the promise, saving the fulfillment in a closure scope.
        var result = promise.then(
            function(v) {
                isResolved = true;
                isPending = false;
                return v; 
            }, 
            function(e) {
                isRejected = true;
                isPending = false;
                throw e; 
            }
        );

        result.isResolved = function() { return isResolved; };
        result.isPending = function() { return isPending; };
        result.isRejected = function() { return isRejected; };

        result.state = function() {
            if (isResolved) {
                return 'resolved';
            }
            if (isRejected) {
                return 'rejected';
            }
            return 'pending';
        };

        var notified = [],
            listeners = [];

          
        result.then = function(onResolved,onRejected,onProgress) {
            if (onProgress) {
                this.progress(onProgress);
            }
            return makePromise2(Promise.prototype.then.call(this,
                onResolved && function(args) {
                    if (args && args.__ctx__ !== undefined) {
                        return onResolved.apply(args.__ctx__,args);
                    } else {
                        return onResolved(args);
                    }
                },
                onRejected && function(args){
                    if (args && args.__ctx__ !== undefined) {
                        return onRejected.apply(args.__ctx__,args);
                    } else {
                        return onRejected(args);
                    }
                }
            ));
        };

        result.progress = function(handler) {
            notified.forEach(function (value) {
                handler(value);
            });
            listeners.push(handler);
            return this;
        };

        result.pipe = result.then;

        result.notify = function(value) {
            try {
                notified.push(value);

                return listeners.forEach(function (listener) {
                    return listener(value);
                });
            } catch (error) {
            this.reject(error);
            }
            return this;
        };

        return result;
    }

 
    Deferred.prototype.resolve = function(value) {
        var args = slice.call(arguments);
        return this.resolveWith(null,args);
    };

    Deferred.prototype.resolveWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._resolve(args);
        this._resolved = true;
        return this;
    };

    Deferred.prototype.notify = function(value) {
        var p = result(this,"promise");
        p.notify(value);
        return this;
    };

    Deferred.prototype.reject = function(reason) {
        var args = slice.call(arguments);
        return this.rejectWith(null,args);
    };

    Deferred.prototype.rejectWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._reject(args);
        this._rejected = true;
        return this;
    };

    Deferred.prototype.isResolved = function() {
        var p = result(this,"promise");
        return p.isResolved();
    };

    Deferred.prototype.isRejected = function() {
        var p = result(this,"promise");
        return p.isRejected();
    };

    Deferred.prototype.state = function() {
        var p = result(this,"promise");
        return p.state();
    };

    Deferred.prototype.then = function(callback, errback, progback) {
        var p = result(this,"promise");
        return p.then(callback, errback, progback);
    };

    Deferred.prototype.progress = function(progback){
        var p = result(this,"promise");
        return p.progress(progback);
    };
   
    Deferred.prototype.catch = function(errback) {
        var p = result(this,"promise");
        return p.catch(errback);
    };


    Deferred.prototype.always  = function() {
        var p = result(this,"promise");
        p.always.apply(p,arguments);
        return this;
    };

    Deferred.prototype.done  = function() {
        var p = result(this,"promise");
        p.done.apply(p,arguments);
        return this;
    };

    Deferred.prototype.fail = function(errback) {
        var p = result(this,"promise");
        p.fail(errback);
        return this;
    };


    Deferred.all = function(array) {
        //return wrapPromise(Promise.all(array));
        var d = new Deferred();
        Promise.all(array).then(d.resolve.bind(d),d.reject.bind(d));
        return result(d,"promise");
    };

    Deferred.first = function(array) {
        return makePromise2(Promise.race(array));
    };


    Deferred.when = function(valueOrPromise, callback, errback, progback) {
        var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
        var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

        if (!receivedPromise) {
            if (arguments.length > 1) {
                return callback ? callback(valueOrPromise) : valueOrPromise;
            } else {
                return new Deferred().resolve(valueOrPromise);
            }
        } else if (!nativePromise) {
            var deferred = new Deferred(valueOrPromise.cancel);
            valueOrPromise.then(proxy(deferred.resolve,deferred), proxy(deferred.reject,deferred), deferred.notify);
            valueOrPromise = deferred.promise;
        }

        if (callback || errback || progback) {
            return valueOrPromise.then(callback, errback, progback);
        }
        return valueOrPromise;
    };

    Deferred.reject = function(err) {
        var d = new Deferred();
        d.reject(err);
        return d.promise;
    };

    Deferred.resolve = function(data) {
        var d = new Deferred();
        d.resolve.apply(d,arguments);
        return d.promise;
    };

    Deferred.immediate = Deferred.resolve;


    Deferred.promise = function(callback) {
        var d = new Deferred();

        callback(d.resolve.bind(d),d.reject.bind(d),d.progress.bind(d));

        return d.promise;
    };

    return Deferred;
});
define('skylark-langx-events/events',[
	"skylark-langx-ns"
],function(skylark){
	return skylark.attach("langx.events",{});
});
define('skylark-langx-constructs/constructs',[
  "skylark-langx-ns"
],function(skylark){

    return skylark.attach("langx.constructs",{});
});
define('skylark-langx-constructs/inherit',[
	"./constructs"
],function(constructs){

    function inherit(ctor,base) {
        ///var f = function() {};
        ///f.prototype = base.prototype;
        ///
        ///ctor.prototype = new f();

	    if ((typeof base !== "function") && base) {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    ctor.prototype = Object.create(base && base.prototype, {
	      constructor: {
	        value: ctor,
	        writable: true,
	        configurable: true
	      }
	    });

	    if (base) {
	    	//tor.__proto__ = base;
	    	Object.setPrototypeOf(ctor, base);
	    } 
    }

    return constructs.inherit = inherit
});
define('skylark-langx-constructs/klass',[
  "skylark-langx-ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "./constructs",
  "./inherit"
],function(skylark,types,objects,arrays,constructs,inherit){
    var uniq = arrays.uniq,
        has = objects.has,
        mixin = objects.mixin,
        isArray = types.isArray,
        isDefined = types.isDefined;

/* for reference 
 function klass(props,parent) {
    var ctor = function(){
        this._construct();
    };
    ctor.prototype = props;
    if (parent) {
        ctor._proto_ = parent;
        props.__proto__ = parent.prototype;
    }
    return ctor;
}

// Type some JavaScript code here.
let animal = klass({
  _construct(){
      this.name = this.name + ",hi";
  },
    
  name: "Animal",
  eat() {         // [[HomeObject]] == animal
    alert(`${this.name} eats.`);
  }
    
    
});


let rabbit = klass({
  name: "Rabbit",
  _construct(){
      super._construct();
  },
  eat() {         // [[HomeObject]] == rabbit
    super.eat();
  }
},animal);

let longEar = klass({
  name: "Long Ear",
  eat() {         // [[HomeObject]] == longEar
    super.eat();
  }
},rabbit);
*/
    


    var f1 = function() {
        function extendClass(ctor, props, options) {
            // Copy the properties to the prototype of the class.
            var proto = ctor.prototype,
                _super = ctor.superclass.prototype,
                noOverrided = options && options.noOverrided,
                overrides = options && options.overrides || {};

            for (var name in props) {
                if (name === "constructor") {
                    continue;
                }

                // Check if we're overwriting an existing function
                var prop = props[name];
                if (typeof props[name] == "function") {
                    proto[name] =  !prop._constructor && !noOverrided && typeof _super[name] == "function" ?
                          (function(name, fn, superFn) {
                            return function() {
                                var tmp = this.overrided;

                                // Add a new ._super() method that is the same method
                                // but on the super-class
                                this.overrided = superFn;

                                // The method only need to be bound temporarily, so we
                                // remove it when we're done executing
                                var ret = fn.apply(this, arguments);

                                this.overrided = tmp;

                                return ret;
                            };
                        })(name, prop, _super[name]) :
                        prop;
                } else if (types.isPlainObject(prop) && prop!==null && (prop.get)) {
                    Object.defineProperty(proto,name,prop);
                } else {
                    proto[name] = prop;
                }
            }
            return ctor;
        }

        function serialMixins(ctor,mixins) {
            var result = [];

            mixins.forEach(function(mixin){
                if (has(mixin,"__mixins__")) {
                     throw new Error("nested mixins");
                }
                var clss = [];
                while (mixin) {
                    clss.unshift(mixin);
                    mixin = mixin.superclass;
                }
                result = result.concat(clss);
            });

            result = uniq(result);

            result = result.filter(function(mixin){
                var cls = ctor;
                while (cls) {
                    if (mixin === cls) {
                        return false;
                    }
                    if (has(cls,"__mixins__")) {
                        var clsMixines = cls["__mixins__"];
                        for (var i=0; i<clsMixines.length;i++) {
                            if (clsMixines[i]===mixin) {
                                return false;
                            }
                        }
                    }
                    cls = cls.superclass;
                }
                return true;
            });

            if (result.length>0) {
                return result;
            } else {
                return false;
            }
        }

        function mergeMixins(ctor,mixins) {
            var newCtor =ctor;
            for (var i=0;i<mixins.length;i++) {
                var xtor = new Function();

                inherit(xtor,newCtor)
                //xtor.prototype = Object.create(newCtor.prototype);
                //xtor.__proto__ = newCtor;
                xtor.superclass = null;
                mixin(xtor.prototype,mixins[i].prototype);
                xtor.prototype.__mixin__ = mixins[i];
                newCtor = xtor;
            }

            return newCtor;
        }

        function _constructor ()  {
            if (this._construct) {
                return this._construct.apply(this, arguments);
            } else  if (this.init) {
                return this.init.apply(this, arguments);
            }
        }

        return function createClass(props, parent, mixins,options) {
            if (isArray(parent)) {
                options = mixins;
                mixins = parent;
                parent = null;
            }
            parent = parent || Object;

            if (isDefined(mixins) && !isArray(mixins)) {
                options = mixins;
                mixins = false;
            }

            var innerParent = parent;

            if (mixins) {
                mixins = serialMixins(innerParent,mixins);
            }

            if (mixins) {
                innerParent = mergeMixins(innerParent,mixins);
            }

            var klassName = props.klassName || "",
                ctor = new Function(
                    "return function " + klassName + "() {" +
                    "var inst = this," +
                    " ctor = arguments.callee;" +
                    "if (!(inst instanceof ctor)) {" +
                    "inst = Object.create(ctor.prototype);" +
                    "}" +
                    "return ctor._constructor.apply(inst, arguments) || inst;" + 
                    "}"
                )();


            // Populate our constructed prototype object
            ///ctor.prototype = Object.create(innerParent.prototype);

            // Enforce the constructor to be what we expect
            ///ctor.prototype.constructor = ctor;
  
            // And make this class extendable
            ///ctor.__proto__ = innerParent;

            inherit(ctor,innerParent);

            ctor.superclass = parent;

            if (!ctor._constructor) {
                ctor._constructor = _constructor;
            } 

            if (mixins) {
                ctor.__mixins__ = mixins;
            }

            if (!ctor.partial) {
                ctor.partial = function(props, options) {
                    return extendClass(this, props, options);
                };
            }
            if (!ctor.inherit) {
                ctor.inherit = function(props, mixins,options) {
                    return createClass(props, this, mixins,options);
                };
            }

            ctor.partial(props, options);

            return ctor;
        };
    }

    var createClass = f1();

    return constructs.klass = createClass;
});
define('skylark-langx-klass/klass',[
  "skylark-langx-ns",
  "skylark-langx-constructs/klass"
],function(skylark,klass){


    return skylark.attach("langx.klass",klass);
});
define('skylark-langx-klass/main',[
	"./klass"
],function(klass){
	return klass;
});
define('skylark-langx-klass', ['skylark-langx-klass/main'], function (main) { return main; });

define('skylark-langx-hoster/hoster',[
    "skylark-langx-ns"
],function(skylark){
	// The javascript host environment, brower and nodejs are supported.
	var hoster = {
		"isBrowser" : true, // default
		"isNode" : null,
		"global" : this,
		"browser" : null,
		"node" : null
	};

	if (typeof process == "object" && process.versions && process.versions.node && process.versions.v8) {
		hoster.isNode = true;
		hoster.isBrowser = false;
	}

	hoster.global = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		} else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	var _document = null;

	Object.defineProperty(hoster,"document",function(){
		if (!_document) {
			var w = typeof window === 'undefined' ? require('html-element') : window;
			_document = w.document;
		}

		return _document;
	});

	if (hoster.global.CustomEvent === undefined) {
		hoster.global.CustomEvent = function(type,props) {
			this.type = type;
			this.props = props;
		};
	}
	Object.defineProperty(hoster,"document",function(){
		if (!_document) {
			var w = typeof window === 'undefined' ? require('html-element') : window;
			_document = w.document;
		}

		return _document;
	});

	if (hoster.isBrowser) {
	    function uaMatch( ua ) {
		    ua = ua.toLowerCase();

			//IE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),
			//Edge = !!navigator.userAgent.match(/Edge/i),
			//FireFox = !!navigator.userAgent.match(/firefox/i),
			//Safari = !!(navigator.userAgent.match(/safari/i) && !navigator.userAgent.match(/chrome/i) && !navigator.userAgent.match(/android/i)),
			//IOS = !!(navigator.userAgent.match(/iP(ad|od|hone)/i)),

		    var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		      /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		      /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		      /(msie) ([\w.]+)/.exec( ua ) ||
		      ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		      [];

		    return {
		      browser: match[ 1 ] || '',
		      version: match[ 2 ] || '0'
		    };
	  	};

	    var matched = uaMatch( navigator.userAgent );

	    var browser = hoster.browser = {};

	    if ( matched.browser ) {
	      browser[ matched.browser ] = true;
	      browser.version = matched.version;
	    }

	    // Chrome is Webkit, but Webkit is also Safari.
	    if ( browser.chrome ) {
	      browser.webkit = true;
	    } else if ( browser.webkit ) {
	      browser.safari = true;
	    }
	}

	hoster.detects = {};

	return  skylark.attach("langx.hoster",hoster);
});
define('skylark-langx-hoster/detects/mobile',[
    "../hoster"
],function(hoster){
    //refer : https://github.com/kaimallea/isMobile

    var appleIphone = /iPhone/i;
    var appleIpod = /iPod/i;
    var appleTablet = /iPad/i;
    var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    var androidTablet = /Android/i;
    var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    var amazonTablet = /Silk/i;
    var windowsPhone = /Windows Phone/i;
    var windowsTablet = /\bWindows(?:.+)ARM\b/i;
    var otherBlackBerry = /BlackBerry/i;
    var otherBlackBerry10 = /BB10/i;
    var otherOpera = /Opera Mini/i;
    var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    var otherFirefox = /Mobile(?:.+)Firefox\b/i;
    var isAppleTabletOnIos13 = function (navigator) {
        return (typeof navigator !== 'undefined' &&
            navigator.platform === 'MacIntel' &&
            typeof navigator.maxTouchPoints === 'number' &&
            navigator.maxTouchPoints > 1 &&
            typeof MSStream === 'undefined');
    };
    function createMatch(userAgent) {
        return function (regex) { return regex.test(userAgent); };
    }
    
    function detectMobile(param) {
        var nav = {
            userAgent: '',
            platform: '',
            maxTouchPoints: 0
        };
        if (!param && typeof navigator !== 'undefined') {
            nav = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                maxTouchPoints: navigator.maxTouchPoints || 0
            };
        }
        else if (typeof param === 'string') {
            nav.userAgent = param;
        }
        else if (param && param.userAgent) {
            nav = {
                userAgent: param.userAgent,
                platform: param.platform,
                maxTouchPoints: param.maxTouchPoints || 0
            };
        }
        var userAgent = nav.userAgent;
        var tmp = userAgent.split('[FBAN');
        if (typeof tmp[1] !== 'undefined') {
            userAgent = tmp[0];
        }
        tmp = userAgent.split('Twitter');
        if (typeof tmp[1] !== 'undefined') {
            userAgent = tmp[0];
        }
        var match = createMatch(userAgent);
        var result = {
            apple: {
                phone: match(appleIphone) && !match(windowsPhone),
                ipod: match(appleIpod),
                tablet: !match(appleIphone) &&
                    (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                    !match(windowsPhone),
                universal: match(appleUniversal),
                device: (match(appleIphone) ||
                    match(appleIpod) ||
                    match(appleTablet) ||
                    match(appleUniversal) ||
                    isAppleTabletOnIos13(nav)) &&
                    !match(windowsPhone)
            },
            amazon: {
                phone: match(amazonPhone),
                tablet: !match(amazonPhone) && match(amazonTablet),
                device: match(amazonPhone) || match(amazonTablet)
            },
            android: {
                phone: (!match(windowsPhone) && match(amazonPhone)) ||
                    (!match(windowsPhone) && match(androidPhone)),
                tablet: !match(windowsPhone) &&
                    !match(amazonPhone) &&
                    !match(androidPhone) &&
                    (match(amazonTablet) || match(androidTablet)),
                device: (!match(windowsPhone) &&
                    (match(amazonPhone) ||
                        match(amazonTablet) ||
                        match(androidPhone) ||
                        match(androidTablet))) ||
                    match(/\bokhttp\b/i)
            },
            windows: {
                phone: match(windowsPhone),
                tablet: match(windowsTablet),
                device: match(windowsPhone) || match(windowsTablet)
            },
            other: {
                blackberry: match(otherBlackBerry),
                blackberry10: match(otherBlackBerry10),
                opera: match(otherOpera),
                firefox: match(otherFirefox),
                chrome: match(otherChrome),
                device: match(otherBlackBerry) ||
                    match(otherBlackBerry10) ||
                    match(otherOpera) ||
                    match(otherFirefox) ||
                    match(otherChrome)
            },
            any: false,
            phone: false,
            tablet: false
        };
        result.any =
            result.apple.device ||
                result.android.device ||
                result.windows.device ||
                result.other.device;
        result.phone =
            result.apple.phone || result.android.phone || result.windows.phone;
        result.tablet =
            result.apple.tablet || result.android.tablet || result.windows.tablet;
        return result;
    }

    return hoster.detects.mobile = detectMobile;
});

define('skylark-langx-hoster/isMobile',[
    "./hoster",
    "./detects/mobile"
],function(hoster,detectMobile){
    if (hoster.isMobile == undefined) {
        hoster.isMobile = detectMobile();
    }

    return hoster.isMobile;
});

define('skylark-langx-hoster/main',[
	"./hoster",
	"./isMobile"
],function(hoster){
	return hoster;
});
define('skylark-langx-hoster', ['skylark-langx-hoster/main'], function (main) { return main; });

define('skylark-langx-events/Event',[
  "skylark-langx-objects",
  "skylark-langx-funcs",
  "skylark-langx-klass",
  "skylark-langx-hoster",
    "./events"
],function(objects,funcs,klass,events){
    var eventMethods = {
        preventDefault: "isDefaultPrevented",
        stopImmediatePropagation: "isImmediatePropagationStopped",
        stopPropagation: "isPropagationStopped"
     };
        

    function compatible(event, source) {
        if (source || !event.isDefaultPrevented) {
            if (!source) {
                source = event;
            }

            objects.each(eventMethods, function(name, predicate) {
                var sourceMethod = source[name];
                event[name] = function() {
                    this[predicate] = funcs.returnTrue;
                    return sourceMethod && sourceMethod.apply(source, arguments);
                }
                event[predicate] = funcs.returnFalse;
            });
        }
        return event;
    }


    /*
    var Event = klass({
        _construct : function(type,props) {
            CustomEvent.call(this,type.props);
            objects.safeMixin(this, props);
            compatible(this);
        }
    },CustomEvent);
    */

    class Event extends CustomEvent {
        constructor(type,props) {
            super(type,props);
            objects.safeMixin(this, props);
            compatible(this);
        } 
    }


    Event.compatible = compatible;

    return events.Event = Event;
    
});
define('skylark-langx-events/Listener',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass",
  "./events",
  "./Event"
],function(types,objects,arrays,klass,events,Event){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isBoolean = types.isBoolean,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;


    var Listener = klass({

        listenTo: function(obj, event, callback, /*used internally*/ one) {
            if (!obj) {
                return this;
            }

            if (isBoolean(callback)) {
                one = callback;
                callback = null;
            }

            if (types.isPlainObject(event)){
                //listenTo(obj,callbacks,one)
                var callbacks = event;
                for (var name in callbacks) {
                    this.listenTo(obj,name,callbacks[name],one);
                }
                return this;
            }

            if (!callback) {
                callback = "handleEvent";
            }
            
            // Bind callbacks on obj,
            if (isString(callback)) {
                callback = this[callback];
            }

            if (one) {
                obj.one(event, callback, this);
            } else {
                obj.on(event, callback, this);
            }

            //keep track of them on listening.
            var listeningTo = this._listeningTo || (this._listeningTo = []),
                listening;

            for (var i = 0; i < listeningTo.length; i++) {
                if (listeningTo[i].obj == obj) {
                    listening = listeningTo[i];
                    break;
                }
            }
            if (!listening) {
                listeningTo.push(
                    listening = {
                        obj: obj,
                        events: {}
                    }
                );
            }
            var listeningEvents = listening.events,
                listeningEvent = listeningEvents[event] = listeningEvents[event] || [];
            if (listeningEvent.indexOf(callback) == -1) {
                listeningEvent.push(callback);
            }

            return this;
        },

        listenToOnce: function(obj, event, callback) {
            return this.listenTo(obj, event, callback, 1);
        },

        unlistenTo: function(obj, event, callback) {
            var listeningTo = this._listeningTo;
            if (!listeningTo) {
                return this;
            }

            if (isString(callback)) {
                callback = this[callback];
            }

            for (var i = 0; i < listeningTo.length; i++) {
                var listening = listeningTo[i];

                if (obj && obj != listening.obj) {
                    continue;
                }

                var listeningEvents = listening.events;
                for (var eventName in listeningEvents) {
                    if (event && event != eventName) {
                        continue;
                    }

                    var listeningEvent = listeningEvents[eventName];

                    for (var j = 0; j < listeningEvent.length; j++) {
                        if (!callback || callback == listeningEvent[i]) {
                            listening.obj.off(eventName, listeningEvent[i], this);
                            listeningEvent[i] = null;
                        }
                    }

                    listeningEvent = listeningEvents[eventName] = compact(listeningEvent);

                    if (isEmptyObject(listeningEvent)) {
                        listeningEvents[eventName] = null;
                    }

                }

                if (isEmptyObject(listeningEvents)) {
                    listeningTo[i] = null;
                }
            }

            listeningTo = this._listeningTo = compact(listeningTo);
            if (isEmptyObject(listeningTo)) {
                this._listeningTo = null;
            }

            return this;
        }
    });

    return events.Listener = Listener;

});
define('skylark-langx-events/Emitter',[
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass",
  "./events",
  "./Event",
  "./Listener"
],function(types,objects,arrays,klass,events,Event,Listener){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            name: segs[0],
            ns: segs.slice(1).join(" ")
        };
    }

    var Emitter = Listener.inherit({
        _prepareArgs : function(e,args) {
            if (isDefined(args)) {
                args = [e].concat(args);
            } else {
                args = [e];
            }
            return args;
        },

        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {
            var self = this,
                _hub = this._hub || (this._hub = {});

            if (isPlainObject(events)) {
                ctx = callback;
                each(events, function(type, fn) {
                    self.on(type, selector, data, fn, ctx, one);
                });
                return this;
            }

            if (!isString(selector) && !isFunction(callback)) {
                ctx = callback;
                callback = data;
                data = selector;
                selector = undefined;
            }

            if (isFunction(data)) {
                ctx = callback;
                callback = data;
                data = null;
            }

            if (!callback ) {
                throw new Error("No callback function");
            } else if (!isFunction(callback)) {
                throw new Error("The callback  is not afunction");
            }

            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                (_hub[name] || (_hub[name] = [])).push({
                    fn: callback,
                    selector: selector,
                    data: data,
                    ctx: ctx,
                    ns : ns,
                    one: one
                });
            });

            return this;
        },

        one: function(events, selector, data, callback, ctx) {
            return this.on(events, selector, data, callback, ctx, 1);
        },

        emit: function(e /*,argument list*/ ) {
            if (!this._hub) {
                return this;
            }

            var self = this;

            if (isString(e)) {
                e = new Event(e); //new CustomEvent(e);
            }

            Object.defineProperty(e,"target",{
                value : this
            });

            var args = slice.call(arguments, 1);

            args = this._prepareArgs(e,args);

            [e.type || e.name, "all"].forEach(function(eventName) {
                var parsed = parse(eventName),
                    name = parsed.name,
                    ns = parsed.ns;

                var listeners = self._hub[name];
                if (!listeners) {
                    return;
                }

                var len = listeners.length,
                    reCompact = false;

                for (var i = 0; i < len; i++) {
                    if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                        return this;
                    }
                    var listener = listeners[i];
                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {
                        continue;
                    }
                    if (e.data) {
                        if (listener.data) {
                            e.data = mixin({}, listener.data, e.data);
                        }
                    } else {
                        e.data = listener.data || null;
                    }
                    listener.fn.apply(listener.ctx, args);
                    if (listener.one) {
                        listeners[i] = null;
                        reCompact = true;
                    }
                }

                if (reCompact) {
                    self._hub[eventName] = compact(listeners);
                }

            });
            return this;
        },

        listened: function(event) {
            var evtArr = ((this._hub || (this._events = {}))[event] || []);
            return evtArr.length > 0;
        },

        off: function(events, callback) {
            var _hub = this._hub || (this._hub = {});
            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                var evts = _hub[name];

                if (evts) {
                    var liveEvents = [];

                    if (callback || ns) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            
                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {
                                liveEvents.push(evts[i]);
                                continue;
                            } 

                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {
                                liveEvents.push(evts[i]);
                                continue;
                            }
                        }
                    }

                    if (liveEvents.length) {
                        _hub[name] = liveEvents;
                    } else {
                        delete _hub[name];
                    }

                }
            });

            return this;
        },
        trigger  : function() {
            return this.emit.apply(this,arguments);
        }
    });


    return events.Emitter = Emitter;

});
define('skylark-langx-events/createEvent',[
	"./events",
	"./Event"
],function(events,Event){
    function createEvent(type,props) {
        //var e = new CustomEvent(type,props);
        //return safeMixin(e, props);
        return new Event(type,props);
    };

    return events.createEvent = createEvent;	
});
define('skylark-langx-events/main',[
	"./events",
	"./Event",
	"./Listener",
	"./Emitter",
	"./createEvent"
],function(events){
	return events;
});
define('skylark-langx-events', ['skylark-langx-events/main'], function (main) { return main; });

define('skylark-langx-emitter/Emitter',[
    "skylark-langx-events"
],function(events){
    return events.Emitter;
});
define('skylark-langx-emitter/Evented',[
	"./Emitter"
],function(Emitter){
	return Emitter;
});
define('skylark-net-http/http',[
  "skylark-langx-ns/ns",
],function(skylark){
	return skylark.attach("net.http",{});
});
define('skylark-net-http/xhr',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-funcs",
  "skylark-langx-async/Deferred",
  "skylark-langx-emitter/Evented",
  "./http"
],function(skylark,types,objects,arrays,funcs,Deferred,Evented,http){

    var each = objects.each,
        mixin = objects.mixin,
        noop = funcs.noop,
        isArray = types.isArray,
        isFunction = types.isFunction,
        isPlainObject = types.isPlainObject,
        type = types.type;
 
     var getAbsoluteUrl = (function() {
        var a;

        return function(url) {
            if (!a) a = document.createElement('a');
            a.href = url;

            return a.href;
        };
    })();
   
    var Xhr = (function(){
        var jsonpID = 0,
            key,
            name,
            rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            scriptTypeRE = /^(?:text|application)\/javascript/i,
            xmlTypeRE = /^(?:text|application)\/xml/i,
            jsonType = 'application/json',
            htmlType = 'text/html',
            blankRE = /^\s*$/;

        var XhrDefaultOptions = {
            async: true,

            // Default type of request
            type: 'GET',
            // Callback that is executed before request
            beforeSend: noop,
            // Callback that is executed if the request succeeds
            success: noop,
            // Callback that is executed the the server drops error
            error: noop,
            // Callback that is executed on request complete (both: error and success)
            complete: noop,
            // The context for the callbacks
            context: null,
            // Whether to trigger "global" Ajax events
            global: true,

            // MIME types mapping
            // IIS returns Javascript as "application/x-javascript"
            accepts: {
                script: 'text/javascript, application/javascript, application/x-javascript',
                json: 'application/json',
                xml: 'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain'
            },
            // Whether the request is to another domain
            crossDomain: false,
            // Default timeout
            timeout: 0,
            // Whether data should be serialized to string
            processData: false,
            // Whether the browser should be allowed to cache GET responses
            cache: true,

            traditional : false,
            
            xhrFields : {
                withCredentials : false
            }
        };

        function mimeToDataType(mime) {
            if (mime) {
                mime = mime.split(';', 2)[0];
            }
            if (mime) {
                if (mime == htmlType) {
                    return "html";
                } else if (mime == jsonType) {
                    return "json";
                } else if (scriptTypeRE.test(mime)) {
                    return "script";
                } else if (xmlTypeRE.test(mime)) {
                    return "xml";
                }
            }
            return "text";
        }

        function appendQuery(url, query) {
            if (query == '') return url
            return (url + '&' + query).replace(/[&?]{1,2}/, '?')
        }

        // serialize payload and append it to the URL for GET requests
        function serializeData(options) {
            options.data = options.data || options.query;
            if (options.processData && options.data && type(options.data) != "string") {
                options.data = param(options.data, options.traditional);
            }
            if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) {
                if (type(options.data) != "string") {
                    options.data = param(options.data, options.traditional);
                }
                options.url = appendQuery(options.url, options.data);
                options.data = undefined;
            }
        }
        
        function serialize(params, obj, traditional, scope) {
            var t, array = isArray(obj),
                hash = isPlainObject(obj)
            each(obj, function(key, value) {
                t =type(value);
                if (scope) key = traditional ? scope :
                    scope + '[' + (hash || t == 'object' || t == 'array' ? key : '') + ']'
                // handle data in serializeArray() format
                if (!scope && array) params.add(value.name, value.value)
                // recurse into nested objects
                else if (t == "array" || (!traditional && t == "object"))
                    serialize(params, value, traditional, key)
                else params.add(key, value)
            })
        }

        var param = function(obj, traditional) {
            var params = []
            params.add = function(key, value) {
                if (isFunction(value)) {
                  value = value();
                }
                if (value == null) {
                  value = "";
                }
                this.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
            serialize(params, obj, traditional)
            return params.join('&').replace(/%20/g, '+')
        };

        var Xhr = Evented.inherit({
            klassName : "Xhr",

            _request  : function(args) {
                var _ = this._,
                    self = this,
                    options = mixin({},XhrDefaultOptions,_.options,args),
                    xhr = _.xhr = new XMLHttpRequest();

                serializeData(options)

                if (options.beforeSend) {
                    options.beforeSend.call(this, xhr, options);
                }                

                var dataType = options.dataType || options.handleAs,
                    mime = options.mimeType || options.accepts[dataType],
                    headers = options.headers,
                    xhrFields = options.xhrFields,
                    isFormData = options.data && options.data instanceof FormData,
                    basicAuthorizationToken = options.basicAuthorizationToken,
                    type = options.type,
                    url = options.url,
                    async = options.async,
                    user = options.user , 
                    password = options.password,
                    deferred = new Deferred(),
                    contentType = options.contentType || (isFormData ? false : 'application/x-www-form-urlencoded');

                if (xhrFields) {
                    for (name in xhrFields) {
                        xhr[name] = xhrFields[name];
                    }
                }

                if (mime && mime.indexOf(',') > -1) {
                    mime = mime.split(',', 2)[0];
                }
                if (mime && xhr.overrideMimeType) {
                    xhr.overrideMimeType(mime);
                }

                if (dataType == "blob" || dataType == "arraybuffer") {
                    xhr.responseType = dataType;
                }

                var finish = function() {
                    xhr.onloadend = noop;
                    xhr.onabort = noop;
                    xhr.onprogress = noop;
                    xhr.ontimeout = noop;
                    xhr = null;
                }
                var onloadend = function() {
                    var result, error = false
                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && getAbsoluteUrl(url).startsWith('file:'))) {
                        dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader('content-type'));

                        //result = xhr.responseText;
                        try {
                            if (dataType == 'script') {
                                eval(xhr.responseText);
                            } else if (dataType == 'xml') {
                                result = xhr.responseXML;
                            } else if (dataType == 'json') {
                                result = blankRE.test(xhr.responseText) ? null : JSON.parse(xhr.responseText);
                            } else if (dataType == "blob") {
                                result = xhr.response; // new Blob([xhr.response]);
                            } else if (dataType == "arraybuffer") {
                                result = xhr.reponse;
                            } else if (dataType == "text") {
                                result = xhr.responseText;
                            }
                        } catch (e) { 
                            error = e;
                        }

                        if (error) {
                            deferred.reject(error,xhr.status,xhr);
                        } else {
                            deferred.resolve(result,xhr.status,xhr);
                        }
                    } else {
                        deferred.reject(new Error(xhr.statusText),xhr.status,xhr);
                    }
                    finish();
                };
                
                var onabort = function() {
                    if (deferred) {
                        deferred.reject(new Error("abort"),xhr.status,xhr);
                    }
                    finish();                 
                }
 
                var ontimeout = function() {
                    if (deferred) {
                        deferred.reject(new Error("timeout"),xhr.status,xhr);
                    }
                    finish();                 
                }

                var onprogress = function(evt) {
                    if (deferred) {
                        deferred.notify(evt,xhr.status,xhr);
                    }
                }

                xhr.onloadend = onloadend;
                xhr.onabort = onabort;
                xhr.ontimeout = ontimeout;
                xhr.onprogress = onprogress;

                xhr.open(type, url, async, user, password);
               
                if (headers) {
                    for ( var key in headers) {
                        var value = headers[key];
 
                        if(key.toLowerCase() === 'content-type'){
                            contentType = value;
                        } else {
                           xhr.setRequestHeader(key, value);
                        }
                    }
                }   

                if  (contentType && contentType !== false){
                    xhr.setRequestHeader('Content-Type', contentType);
                }

                if(!headers || !('X-Requested-With' in headers)){
                    //xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); // del for s02
                }


                //If basicAuthorizationToken is defined set its value into "Authorization" header
                if (basicAuthorizationToken) {
                    xhr.setRequestHeader("Authorization", basicAuthorizationToken);
                }

                xhr.send(options.data ? options.data : null);

                return deferred.promise;

            },

            "abort": function() {
                var _ = this._,
                    xhr = _.xhr;

                if (xhr) {
                    xhr.abort();
                }    
            },


            "request": function(args) {
                return this._request(args);
            },

            get : function(args) {
                args = args || {};
                args.type = "GET";
                return this._request(args);
            },

            post : function(args) {
                args = args || {};
                args.type = "POST";
                return this._request(args);
            },

            patch : function(args) {
                args = args || {};
                args.type = "PATCH";
                return this._request(args);
            },

            put : function(args) {
                args = args || {};
                args.type = "PUT";
                return this._request(args);
            },

            del : function(args) {
                args = args || {};
                args.type = "DELETE";
                return this._request(args);
            },

            "init": function(options) {
                this._ = {
                    options : options || {}
                };
            }
        });

        ["request","get","post","put","del","patch"].forEach(function(name){
            Xhr[name] = function(url,args) {
                var xhr = new Xhr({"url" : url});
                return xhr[name](args);
            };
        });

        Xhr.defaultOptions = XhrDefaultOptions;
        Xhr.param = param;

        return Xhr;
    })();

    return http.Xhr = Xhr;  
});
define('skylark-langx-globals/document',[
	"./globals"
], function(globals) {
	var topLevel = typeof global !== 'undefined' ? global :
	    typeof window !== 'undefined' ? window : {};

	var doccy;

	if (typeof document !== 'undefined') {
	    doccy = document;
	} else {
        doccy  = require('min-document');
	}


	return globals.document = doccy;
});




define('skylark-langx/arrays',[
	"skylark-langx-arrays"
],function(arrays){
  return arrays;
});
define('skylark-langx/klass',[
    "skylark-langx-klass"
],function(klass){
    return klass;
});
define('skylark-langx/ArrayStore',[
    "./klass"
],function(klass){
    var SimpleQueryEngine = function(query, options){
        // summary:
        //      Simple query engine that matches using filter functions, named filter
        //      functions or objects by name-value on a query object hash
        //
        // description:
        //      The SimpleQueryEngine provides a way of getting a QueryResults through
        //      the use of a simple object hash as a filter.  The hash will be used to
        //      match properties on data objects with the corresponding value given. In
        //      other words, only exact matches will be returned.
        //
        //      This function can be used as a template for more complex query engines;
        //      for example, an engine can be created that accepts an object hash that
        //      contains filtering functions, or a string that gets evaluated, etc.
        //
        //      When creating a new dojo.store, simply set the store's queryEngine
        //      field as a reference to this function.
        //
        // query: Object
        //      An object hash with fields that may match fields of items in the store.
        //      Values in the hash will be compared by normal == operator, but regular expressions
        //      or any object that provides a test() method are also supported and can be
        //      used to match strings by more complex expressions
        //      (and then the regex's or object's test() method will be used to match values).
        //
        // options: dojo/store/api/Store.QueryOptions?
        //      An object that contains optional information such as sort, start, and count.
        //
        // returns: Function
        //      A function that caches the passed query under the field "matches".  See any
        //      of the "query" methods on dojo.stores.
        //
        // example:
        //      Define a store with a reference to this engine, and set up a query method.
        //
        //  |   var myStore = function(options){
        //  |       //  ...more properties here
        //  |       this.queryEngine = SimpleQueryEngine;
        //  |       //  define our query method
        //  |       this.query = function(query, options){
        //  |           return QueryResults(this.queryEngine(query, options)(this.data));
        //  |       };
        //  |   };

        // create our matching query function
        switch(typeof query){
            default:
                throw new Error("Can not query with a " + typeof query);
            case "object": case "undefined":
                var queryObject = query;
                query = function(object){
                    for(var key in queryObject){
                        var required = queryObject[key];
                        if(required && required.test){
                            // an object can provide a test method, which makes it work with regex
                            if(!required.test(object[key], object)){
                                return false;
                            }
                        }else if(required != object[key]){
                            return false;
                        }
                    }
                    return true;
                };
                break;
            case "string":
                // named query
                if(!this[query]){
                    throw new Error("No filter function " + query + " was found in store");
                }
                query = this[query];
                // fall through
            case "function":
                // fall through
        }
        
        function filter(arr, callback, thisObject){
            // summary:
            //      Returns a new Array with those items from arr that match the
            //      condition implemented by callback.
            // arr: Array
            //      the array to iterate over.
            // callback: Function|String
            //      a function that is invoked with three arguments (item,
            //      index, array). The return of this function is expected to
            //      be a boolean which determines whether the passed-in item
            //      will be included in the returned array.
            // thisObject: Object?
            //      may be used to scope the call to callback
            // returns: Array
            // description:
            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
            //      run over sparse arrays, this implementation passes the "holes" in the sparse array to
            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
            //      For more details, see:
            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
            // example:
            //  | // returns [2, 3, 4]
            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });

            // TODO: do we need "Ctr" here like in map()?
            var i = 0, l = arr && arr.length || 0, out = [], value;
            if(l && typeof arr == "string") arr = arr.split("");
            if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
            if(thisObject){
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback.call(thisObject, value, i, arr)){
                        out.push(value);
                    }
                }
            }else{
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback(value, i, arr)){
                        out.push(value);
                    }
                }
            }
            return out; // Array
        }

        function execute(array){
            // execute the whole query, first we filter
            var results = filter(array, query);
            // next we sort
            var sortSet = options && options.sort;
            if(sortSet){
                results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
                    for(var sort, i=0; sort = sortSet[i]; i++){
                        var aValue = a[sort.attribute];
                        var bValue = b[sort.attribute];
                        // valueOf enables proper comparison of dates
                        aValue = aValue != null ? aValue.valueOf() : aValue;
                        bValue = bValue != null ? bValue.valueOf() : bValue;
                        if (aValue != bValue){
                            // modified by lwf 2016/07/09
                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                        }
                    }
                    return 0;
                });
            }
            // now we paginate
            if(options && (options.start || options.count)){
                var total = results.length;
                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
                results.total = total;
            }
            return results;
        }
        execute.matches = query;
        return execute;
    };

    var QueryResults = function(results){
        // summary:
        //      A function that wraps the results of a store query with additional
        //      methods.
        // description:
        //      QueryResults is a basic wrapper that allows for array-like iteration
        //      over any kind of returned data from a query.  While the simplest store
        //      will return a plain array of data, other stores may return deferreds or
        //      promises; this wrapper makes sure that *all* results can be treated
        //      the same.
        //
        //      Additional methods include `forEach`, `filter` and `map`.
        // results: Array|dojo/promise/Promise
        //      The result set as an array, or a promise for an array.
        // returns:
        //      An array-like object that can be used for iterating over.
        // example:
        //      Query a store and iterate over the results.
        //
        //  |   store.query({ prime: true }).forEach(function(item){
        //  |       //  do something
        //  |   });

        if(!results){
            return results;
        }

        var isPromise = !!results.then;
        // if it is a promise it may be frozen
        if(isPromise){
            results = Object.delegate(results);
        }
        function addIterativeMethod(method){
            // Always add the iterative methods so a QueryResults is
            // returned whether the environment is ES3 or ES5
            results[method] = function(){
                var args = arguments;
                var result = Deferred.when(results, function(results){
                    //Array.prototype.unshift.call(args, results);
                    return QueryResults(Array.prototype[method].apply(results, args));
                });
                // forEach should only return the result of when()
                // when we're wrapping a promise
                if(method !== "forEach" || isPromise){
                    return result;
                }
            };
        }

        addIterativeMethod("forEach");
        addIterativeMethod("filter");
        addIterativeMethod("map");
        if(results.total == null){
            results.total = Deferred.when(results, function(results){
                return results.length;
            });
        }
        return results; // Object
    };

    var ArrayStore = klass({
        "klassName": "ArrayStore",

        "queryEngine": SimpleQueryEngine,
        
        "idProperty": "id",


        get: function(id){
            // summary:
            //      Retrieves an object by its identity
            // id: Number
            //      The identity to use to lookup the object
            // returns: Object
            //      The object in the store that matches the given id.
            return this.data[this.index[id]];
        },

        getIdentity: function(object){
            return object[this.idProperty];
        },

        put: function(object, options){
            var data = this.data,
                index = this.index,
                idProperty = this.idProperty;
            var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
            if(id in index){
                // object exists
                if(options && options.overwrite === false){
                    throw new Error("Object already exists");
                }
                // replace the entry in data
                data[index[id]] = object;
            }else{
                // add the new object
                index[id] = data.push(object) - 1;
            }
            return id;
        },

        add: function(object, options){
            (options = options || {}).overwrite = false;
            // call put with overwrite being false
            return this.put(object, options);
        },

        remove: function(id){
            // summary:
            //      Deletes an object by its identity
            // id: Number
            //      The identity to use to delete the object
            // returns: Boolean
            //      Returns true if an object was removed, falsy (undefined) if no object matched the id
            var index = this.index;
            var data = this.data;
            if(id in index){
                data.splice(index[id], 1);
                // now we have to reindex
                this.setData(data);
                return true;
            }
        },
        query: function(query, options){
            // summary:
            //      Queries the store for objects.
            // query: Object
            //      The query to use for retrieving objects from the store.
            // options: dojo/store/api/Store.QueryOptions?
            //      The optional arguments to apply to the resultset.
            // returns: dojo/store/api/Store.QueryResults
            //      The results of the query, extended with iterative methods.
            //
            // example:
            //      Given the following store:
            //
            //  |   var store = new Memory({
            //  |       data: [
            //  |           {id: 1, name: "one", prime: false },
            //  |           {id: 2, name: "two", even: true, prime: true},
            //  |           {id: 3, name: "three", prime: true},
            //  |           {id: 4, name: "four", even: true, prime: false},
            //  |           {id: 5, name: "five", prime: true}
            //  |       ]
            //  |   });
            //
            //  ...find all items where "prime" is true:
            //
            //  |   var results = store.query({ prime: true });
            //
            //  ...or find all items where "even" is true:
            //
            //  |   var results = store.query({ even: true });
            return QueryResults(this.queryEngine(query, options)(this.data));
        },

        setData: function(data){
            // summary:
            //      Sets the given data as the source for this store, and indexes it
            // data: Object[]
            //      An array of objects to use as the source of data.
            if(data.items){
                // just for convenience with the data format IFRS expects
                this.idProperty = data.identifier || this.idProperty;
                data = this.data = data.items;
            }else{
                this.data = data;
            }
            this.index = {};
            for(var i = 0, l = data.length; i < l; i++){
                this.index[data[i][this.idProperty]] = i;
            }
        },

        init: function(options) {
            for(var i in options){
                this[i] = options[i];
            }
            this.setData(this.data || []);
        }

    });

	return ArrayStore;
});
define('skylark-langx-aspect/aspect',[
    "skylark-langx-ns"
],function(skylark){

  var undefined, nextId = 0;
    function advise(dispatcher, type, advice, receiveArguments){
        var previous = dispatcher[type];
        var around = type == "around";
        var signal;
        if(around){
            var advised = advice(function(){
                return previous.advice(this, arguments);
            });
            signal = {
                remove: function(){
                    if(advised){
                        advised = dispatcher = advice = null;
                    }
                },
                advice: function(target, args){
                    return advised ?
                        advised.apply(target, args) :  // called the advised function
                        previous.advice(target, args); // cancelled, skip to next one
                }
            };
        }else{
            // create the remove handler
            signal = {
                remove: function(){
                    if(signal.advice){
                        var previous = signal.previous;
                        var next = signal.next;
                        if(!next && !previous){
                            delete dispatcher[type];
                        }else{
                            if(previous){
                                previous.next = next;
                            }else{
                                dispatcher[type] = next;
                            }
                            if(next){
                                next.previous = previous;
                            }
                        }

                        // remove the advice to signal that this signal has been removed
                        dispatcher = advice = signal.advice = null;
                    }
                },
                id: nextId++,
                advice: advice,
                receiveArguments: receiveArguments
            };
        }
        if(previous && !around){
            if(type == "after"){
                // add the listener to the end of the list
                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
                while(previous.next && (previous = previous.next)){}
                previous.next = signal;
                signal.previous = previous;
            }else if(type == "before"){
                // add to beginning
                dispatcher[type] = signal;
                signal.next = previous;
                previous.previous = signal;
            }
        }else{
            // around or first one just replaces
            dispatcher[type] = signal;
        }
        return signal;
    }
    function aspect(type){
        return function(target, methodName, advice, receiveArguments){
            var existing = target[methodName], dispatcher;
            if(!existing || existing.target != target){
                // no dispatcher in place
                target[methodName] = dispatcher = function(){
                    var executionId = nextId;
                    // before advice
                    var args = arguments;
                    var before = dispatcher.before;
                    while(before){
                        args = before.advice.apply(this, args) || args;
                        before = before.next;
                    }
                    // around advice
                    if(dispatcher.around){
                        var results = dispatcher.around.advice(this, args);
                    }
                    // after advice
                    var after = dispatcher.after;
                    while(after && after.id < executionId){
                        if(after.receiveArguments){
                            var newResults = after.advice.apply(this, args);
                            // change the return value only if a new value was returned
                            results = newResults === undefined ? results : newResults;
                        }else{
                            results = after.advice.call(this, results, args);
                        }
                        after = after.next;
                    }
                    return results;
                };
                if(existing){
                    dispatcher.around = {advice: function(target, args){
                        return existing.apply(target, args);
                    }};
                }
                dispatcher.target = target;
            }
            var results = advise((dispatcher || existing), type, advice, receiveArguments);
            advice = null;
            return results;
        };
    }

    return skylark.attach("langx.aspect",{
        after: aspect("after"),
 
        around: aspect("around"),
        
        before: aspect("before")
    });
});
define('skylark-langx-aspect/main',[
	"./aspect"
],function(aspect){
	return aspect;
});
define('skylark-langx-aspect', ['skylark-langx-aspect/main'], function (main) { return main; });

define('skylark-langx/aspect',[
    "skylark-langx-aspect"
],function(aspect){
  return aspect;
});
define('skylark-langx-async/async',[
    "skylark-langx-ns",
    "skylark-langx-objects",
    "./Deferred"
],function(skylark,objects,Deferred){
    var each = objects.each;
    
    var async = {
        Deferred : Deferred,

        parallel : function(arr,args,ctx) {
            var rets = [];
            ctx = ctx || null;
            args = args || [];

            each(arr,function(i,func){
                rets.push(func.apply(ctx,args));
            });

            return Deferred.all(rets);
        },

        series : function(arr,args,ctx) {
            var rets = [],
                d = new Deferred(),
                p = d.promise;

            ctx = ctx || null;
            args = args || [];

            d.resolve();
            each(arr,function(i,func){
                p = p.then(function(){
                    return func.apply(ctx,args);
                });
                rets.push(p);
            });

            return Deferred.all(rets);
        },

        waterful : function(arr,args,ctx) {
            var d = new Deferred(),
                p = d.promise;

            ctx = ctx || null;
            args = args || [];

            d.resolveWith(ctx,args);

            each(arr,function(i,func){
                p = p.then(func);
            });
            return p;
        }
    };

	return skylark.attach("langx.async",async);	
});
define('skylark-langx-async/main',[
	"./async"
],function(async){
	return async;
});
define('skylark-langx-async', ['skylark-langx-async/main'], function (main) { return main; });

define('skylark-langx/async',[
    "skylark-langx-async"
],function(async){
    return async;
});
define('skylark-langx-binary/binary',[
  "skylark-langx-ns",
],function(skylark){
	"use strict";


	/**
	 * Create arraybuffer from binary string
	 *
	 * @method fromBinaryString
	 * @param {String} str
	 * @return {Arraybuffer} data
	 */
	function fromBinaryString(str) {
		var length = str.length;
		var arraybuffer = new ArrayBuffer(length);
		var view = new Uint8Array(arraybuffer);

		for(var i = 0; i < length; i++)
		{
			view[i] = str.charCodeAt(i);
		}

		return arraybuffer;
	}

	/**
	 * Create arraybuffer from base64 string
	 *
	 * @method fromBase64
	 * @param {String} base64
	 * @return {Arraybuffer} data
	 */
	function fromBase64(str){
		var encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var length = str.length / 4 * 3;
		var arraybuffer = new ArrayBuffer(length);
		var view = new Uint8Array(arraybuffer);

		var a, b, c, d;

		for(var i = 0, j = 0; i < length; i += 3)
		{
			a = encoding.indexOf(str.charAt(j++));
			b = encoding.indexOf(str.charAt(j++));
			c = encoding.indexOf(str.charAt(j++));
			d = encoding.indexOf(str.charAt(j++));

			view[i] = (a << 2) | (b >> 4);
			if(c !== 64)
			{
				view[i+1] = ((b & 15) << 4) | (c >> 2);
			}
			if(d !== 64)
			{
				view[i+2] = ((c & 3) << 6) | d;
			}
		}

		return arraybuffer;
	}

	/**
	 * Create arraybuffer from Nodejs buffer
	 *
	 * @method fromBuffer
	 * @param {Buffer} buffer
	 * @return {Arraybuffer} data
	 */
	function fromBuffer(buffer)	{
		var array = new ArrayBuffer(buffer.length);
		var view = new Uint8Array(array);

		for(var i = 0; i < buffer.length; i++)
		{
			view[i] = buffer[i];
		}

		return array;

		//Faster but the results is failing the "instanceof ArrayBuffer" test
		//return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
	};

	return skylark.attach("langx.binary",{
		fromBase64,
		fromBinaryString,
		fromBuffer
	});
});
define('skylark-langx-binary/main',[
	"./binary"
],function(binary){
	return binary;
});
define('skylark-langx-binary', ['skylark-langx-binary/main'], function (main) { return main; });

define('skylark-langx/binary',[
	"skylark-langx-binary"
],function(binary){
  return binary;
});
define('skylark-langx-constructs/main',[
	"./constructs",
	"./inherit",
	"./klass"
],function(constructs){
	return constructs;
});
define('skylark-langx-constructs', ['skylark-langx-constructs/main'], function (main) { return main; });

define('skylark-langx/constructs',[
	"skylark-langx-constructs"
],function(constructs){
  return constructs;
});
define('skylark-langx-datetimes/datetimes',[
    "skylark-langx-ns"
],function(skylark){
     function parseMilliSeconds(str) {

        var strs = str.split(' ');
        var number = parseInt(strs[0]);

        if (isNaN(number)){
            return 0;
        }

        var min = 60000 * 60;

        switch (strs[1].trim().replace(/\./g, '')) {
            case 'minutes':
            case 'minute':
            case 'min':
            case 'mm':
            case 'm':
                return 60000 * number;
            case 'hours':
            case 'hour':
            case 'HH':
            case 'hh':
            case 'h':
            case 'H':
                return min * number;
            case 'seconds':
            case 'second':
            case 'sec':
            case 'ss':
            case 's':
                return 1000 * number;
            case 'days':
            case 'day':
            case 'DD':
            case 'dd':
            case 'd':
                return (min * 24) * number;
            case 'months':
            case 'month':
            case 'MM':
            case 'M':
                return (min * 24 * 28) * number;
            case 'weeks':
            case 'week':
            case 'W':
            case 'w':
                return (min * 24 * 7) * number;
            case 'years':
            case 'year':
            case 'yyyy':
            case 'yy':
            case 'y':
                return (min * 24 * 365) * number;
            default:
                return 0;
        }
    };
	
	return skylark.attach("langx.datetimes",{
		parseMilliSeconds
	});
});
define('skylark-langx-datetimes/main',[
	"./datetimes"
],function(datetimes){
	return datetimes;
});
define('skylark-langx-datetimes', ['skylark-langx-datetimes/main'], function (main) { return main; });

define('skylark-langx/datetimes',[
    "skylark-langx-datetimes"
],function(datetimes){
    return datetimes;
});
define('skylark-langx/Deferred',[
    "skylark-langx-async"
],function(async){
    return async.Deferred;
});
define('skylark-langx/Emitter',[
    "skylark-langx-events"
],function(events){
    return events.Emitter;
});
define('skylark-langx/Evented',[
    "./Emitter"
],function(Emitter){
    return Emitter;
});
define('skylark-langx/events',[
	"skylark-langx-events"
],function(events){
	return events;
});
define('skylark-langx/funcs',[
    "skylark-langx-funcs"
],function(funcs){
    return funcs;
});
define('skylark-langx-globals/console',[
	"./globals"
], function(globals) {
	return globals.console = console;
});
define('skylark-langx-globals/main',[
	"./globals",
	"./console",
	"./document",
	"./window"
],function(globals){

	return globals;
});
define('skylark-langx-globals', ['skylark-langx-globals/main'], function (main) { return main; });

define('skylark-langx/globals',[
    "skylark-langx-globals"
],function(globals){
    return globals;
});
define('skylark-langx/hoster',[
	"skylark-langx-hoster"
],function(hoster){
	return hoster;
});
define('skylark-langx-maths/maths',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){


	var _lut = [];

	for ( var i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	var maths = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,



		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * maths.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * maths.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			var cos = Math.cos;
			var sin = Math.sin;

			var c2 = cos( b / 2 );
			var s2 = sin( b / 2 );

			var c13 = cos( ( a + c ) / 2 );
			var s13 = sin( ( a + c ) / 2 );

			var c1_3 = cos( ( a - c ) / 2 );
			var s1_3 = sin( ( a - c ) / 2 );

			var c3_1 = cos( ( c - a ) / 2 );
			var s3_1 = sin( ( c - a ) / 2 );

			if ( order === 'XYX' ) {

				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

			} else if ( order === 'YZY' ) {

				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

			} else if ( order === 'ZXZ' ) {

				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

			} else if ( order === 'XZX' ) {

				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

			} else if ( order === 'YXY' ) {

				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

			} else if ( order === 'ZYZ' ) {

				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

			} else {

				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

			}

		}

	};



	return  skylark.attach("langx.maths",maths);
});
define('skylark-langx-maths/main',[
	"./maths"
],function(maths){
	return maths;
});
define('skylark-langx-maths', ['skylark-langx-maths/main'], function (main) { return main; });

define('skylark-langx/maths',[
    "skylark-langx-maths"
],function(maths){
    return maths;
});
define('skylark-langx-numerics/numerics',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){

	return  skylark.attach("langx.numerics",{
		toFinite : types.toFinite,
		toNumber : types.toNumber,
		toInteger : types.toInteger
	});
});
define('skylark-langx-numerics/maths',[
    "skylark-langx-ns",
    "skylark-langx-types",
    "./numerics"
],function(skylark,types,numerics){


	var _lut = [];

	for ( var i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	var maths = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,



		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * maths.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * maths.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			var cos = Math.cos;
			var sin = Math.sin;

			var c2 = cos( b / 2 );
			var s2 = sin( b / 2 );

			var c13 = cos( ( a + c ) / 2 );
			var s13 = sin( ( a + c ) / 2 );

			var c1_3 = cos( ( a - c ) / 2 );
			var s1_3 = sin( ( a - c ) / 2 );

			var c3_1 = cos( ( c - a ) / 2 );
			var s3_1 = sin( ( c - a ) / 2 );

			if ( order === 'XYX' ) {

				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

			} else if ( order === 'YZY' ) {

				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

			} else if ( order === 'ZXZ' ) {

				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

			} else if ( order === 'XZX' ) {

				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

			} else if ( order === 'YXY' ) {

				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

			} else if ( order === 'ZYZ' ) {

				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

			} else {

				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

			}

		}

	};


	return  numerics.maths = maths;
});
define('skylark-langx-numerics/Quaternion',[
	"skylark-langx-klass",
	"./numerics",
	"./maths"
] ,function(klass,numerics,maths) {

	var Quaternion = klass({
		"klassName" : "Quaternion",

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this._onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this._onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this._onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this._onChangeCallback();

			}

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'mathsQuaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		},

		setFromUnitVectors: function ( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			var EPS = 0.000001;

			var r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		},

		angleTo: function ( q ) {

			return 2 * Math.acos( Math.abs( maths.clamp( this.dot( q ), - 1, 1 ) ) );

		},

		rotateTowards: function ( q, step ) {

			var angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			var t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		},

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'mathsQuaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		},

		_onChange: function ( callback ) {

			this._onChangeCallback = callback;

			return this;

		},

		_onChangeCallback: function () {},


		"_construct" : function ( x, y, z, w ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;

		}


	})


	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.assign( Quaternion.prototype, {


	} );


	return numerics.Quaternion = Quaternion;


});
define('skylark-langx-numerics/Vector3',[
	"skylark-langx-klass",
	"./numerics",
	"./maths",
	"./Quaternion"
] ,function(
	klass,
	numerics,
	maths,
	Quaternion
) {

	var _quaternion = new Quaternion();

	var Vector3 = klass({
		"klassName" : "Vector3",

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'mathsVector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

		},

		applyAxisAngle: function ( axis, angle ) {

			return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyNormalMatrix: function ( m ) {

			return this.applyMatrix3( m ).normalize();

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function ( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		},

		unproject: function ( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		},

		transformDirection: function ( m ) {

			// input: mathsMatrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'mathsVector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( v ) {

			var denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			var scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		},

		projectOnPlane: function ( planeNormal ) {

			_vector.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector );

		},

		reflect: function ( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		},

		angleTo: function ( v ) {

			var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			var theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		},

		setFromSphericalCoords: function ( radius, phi, theta ) {

			var sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		},

		setFromCylindricalCoords: function ( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		setFromMatrix3Column: function ( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'mathsVector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		},


		"_construct" : function ( x, y, z ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;

		}

	});

	var _vector = new Vector3();


	return numerics.Vector3 = Vector3;
});
define('skylark-langx-numerics/Matrix4',[
	"skylark-langx-klass",
	"./numerics",
	"./Vector3"
] ,function(
	klass,
	numerics,
	Vector3
) {

	var _v1 = new Vector3();
	var _zero = new Vector3( 0, 0, 0 );
	var _one = new Vector3( 1, 1, 1 );
	var _x = new Vector3();
	var _y = new Vector3();
	var _z = new Vector3();

	var Matrix4 = klass({
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function ( m ) {

			// this method does not support reflection matrices

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'mathsMatrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function ( q ) {

			return this.compose( _zero, q, _one );

		},

		lookAt: function ( eye, target, up ) {

			var te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		},

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'mathsMatrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( x, y, z ) {

			var te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			if ( throwOnDegenerate !== undefined ) {

				console.warn( "mathsMatrix4: .getInverse() can no longer be configured to throw on degenerate." );

			}

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			var sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		},

		decompose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1.copy( this );

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			_m1.elements[ 0 ] *= invSX;
			_m1.elements[ 1 ] *= invSX;
			_m1.elements[ 2 ] *= invSX;

			_m1.elements[ 4 ] *= invSY;
			_m1.elements[ 5 ] *= invSY;
			_m1.elements[ 6 ] *= invSY;

			_m1.elements[ 8 ] *= invSZ;
			_m1.elements[ 9 ] *= invSZ;
			_m1.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		},

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'mathsMatrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		"_construct" : function() {

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'mathsMatrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

	});

	var _m1 = new Matrix4();

	return numerics.Matrix4 =  Matrix4 ;

});
define('skylark-langx-numerics/Euler',[
	"skylark-langx-klass",
	"./numerics",
	"./maths",
	"./Quaternion",
	"./Vector3",
	"./Matrix4"
] ,function(
	klass,
	numerics,
	maths,
	Quaternion,
	Vector3,
	Matrix4
) {

	var _matrix = new Matrix4();
	var _quaternion = new Quaternion();

	var Euler = klass({
		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this._onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this._onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this._onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this._onChangeCallback();

			}

		},

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this._onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = maths.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'skylark-nunustudio/editor/gui/element/RendererCanvasEuler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this._onChangeCallback();

			return this;

		},

		setFromQuaternion: function ( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		},

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function ( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion.setFromEuler( this );

			return this.setFromQuaternion( _quaternion, newOrder );

		},

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		_onChange: function ( callback ) {

			this._onChangeCallback = callback;

			return this;

		},

		_onChangeCallback: function () {},


		"_construct" : function ( x, y, z, order ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;

		}


	});


	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';


	return numerics.Euler = Euler ;
});

define('skylark-langx-numerics/Matrix3',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Matrix3 = klass({
		"klassName" : "Matrix3",

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( throwOnDegenerate !== undefined ) {

				console.warn( "mathsMatrix3: .getInverse() can no longer be configured to throw on degenerate." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		},


		"_construct" : function () {

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

	});


	return numerics.Matrix3 = Matrix3;
});
define('skylark-langx-numerics/Transform',[
	"skylark-langx-klass",	
    "./numerics",
], function(klass,numerics) {

    var Transform =  klass({
        "klassName": "Transform",
		"value": {
			get : function(){
				return this._.value;
			}
		}
	});

	return numerics.Transform =Transform;
});

define('skylark-langx-numerics/MatrixTransform',[
    "./numerics",
	"./Transform"
],function(numerics,Transform) {

    var MatrixTransform =  Transform.inherit({
        "klassName": "MatrixTransform",

		"value"	:	{
			get : function(){
				return this.matrix.clone();
			}
		},
		
		"matrix" : {
			get : function(){
				return this._.matrix;
			}
		},

		clone : /*ScaleTransform*/function() {
		},
		
		transform : /*Point*/function(/*Point*/point) {
		},
		
		//wE{bNXAi[sE{bNXB
		transformBounds : /*Rect*/function(/*Rect*/rect) {
		},		
		"_construct" : function(/*Martix*/matrix) {
            var _ = this._ = {};
			
			_.matrix = matrix;
		}
				
	});

	return numerics.MatrixTransform = MatrixTransform;
	
});	

define('skylark-langx-numerics/Plane',[
	"skylark-langx-klass",
	"./numerics",
	"./Matrix3",
	"./Vector3"
] ,function(
	klass,
	numerics,
	Matrix3,
	Vector3
) {


	var _vector1 = new Vector3();
	var _vector2 = new Vector3();
	var _normalMatrix = new Matrix3();

	var Plane = klass({
		"klassName" : "Plane",

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function ( a, b, c ) {

			var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function ( line, target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .intersectLine() target is now required' );
				target = new Vector3();

			}

			var direction = line.delta( _vector1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		},

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'mathsPlane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function ( matrix, optionalNormalMatrix ) {

			var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		},

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		},


		"_construct" : function( normal, constant ) {

			// normal is assumed to be normalized

			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;

		}

	});


	return numerics.Plane = Plane;
});
define('skylark-langx-numerics/RotateTransform',[
    "./numerics",
	"./Transform",
	"./MatrixTransform"
],function(numerics,Transform,Matrix) {


    var RotateTransform = numerics.RotateTransform = Transform.inherit({
        "klassName": "RotateTransform",

        "value": {
            get: function() {
                return Matrix.rotateAt(this.angle, this.centerX, this.centerY);
            }
        },

        "angle": {
            get : function() {
                return this._.angle;
            }
        },
        // cy: Number
        //		The Y coordinate of the center of the circle, default value 0.
        "centerX": {
            get : function() {
                return this._.centerX;
            }
        },
        // r: Number
        //		The radius, default value 100.
        "centerY": {
            get : function() {
                return this._.centerY;
            }
        },

		clone : /*ScaleTransform*/function() {
		},
		
		transform : /*Point*/function(/*Point*/point) {
		},
		
		transformBounds : /*Rect*/function(/*Rect*/rect) {
		},
		
		"init" : function(/*Number*/angle,/*Number*/centerX,/*Number*/centerY) {
			var _ = this._ = {};
			_.angle = angle ? angle :0;
			_.centerX = centerX ? centerX :0;
			_.centerY = centerY ? centerY :0;
		}
	});

	return RotateTransform;
	
});	

define('skylark-langx-numerics/ScaleTransform',[
    "./numerics",
    "./Transform",
    "./MatrixTransform"
], function(numerics, Transform, Matrix) {

   var ScaleTransform =  Transform.inherit({
        "klassName": "ScaleTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.scaleX, this.scaleY, this.centerX, this.centerY);
            }
        },

        "scaleX": {
            get : function() {
                return this._.scaleX;
            }
        },

        "scaleY": {
            get : function() {
                return this._.scaleY;
            }
        },

        // cy: Number
        //      The Y coordinate of the center of the circle, default value 0.
        "centerX": {
            get : function() {
                return this._.centerX;
            }
        },
        // r: Number
        //      The radius, default value 100.
        "centerY": {
            get : function() {
                return this._.centerY;
            }
        },

        clone: /*ScaleTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "_construct": function( /*Number*/ scaleX, /*Number*/ scaleY, /*Number*/ centerX, /*Number*/ centerY) {
            var _ = this._ = {};

            _.scaleX = scaleX ? scaleX : 1;
            _.scaleY = scaleY ? scaleY : 1;
            _.centerX = centerX ? centerX : 0;
            _.centerY = centerY ? centerY : 0;
        }
    });

    return numerics.ScaleTransform = ScaleTransform;

});

define('skylark-langx-numerics/SkewTransform',[
    "./numerics",
    "./Transform",
    "./MatrixTransform"
], function(numerics, Transform, Matrix) {

   var SkewTransform = Transform.inherit({
        "klassName": "SkewTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.skewX, this.skewY);
            }
        },

        "skewX": {
            get : function() {
                return this._.skewX;
            }
        },

        "skewY": {
            get : function() {
                return this._.skewY;
            }
        },

        clone: /*SkewTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "_construct": function( /*Number*/ skewX, /*Number*/ skewY) {
            var _ = this._ = {};

            _.skewX = skewX ? skewX : 0;
            _.skewY = skewY ? skewY : 0;
        }
    });

    return numerics.SkewTransform = SkewTransform;

});

define('skylark-langx-numerics/Vector2',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Vector2 = klass({
		"klassName" : "Vector2",

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;
		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},


		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		cross: function ( v ) {

			return this.x * v.y - this.y * v.x;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},


		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;
		},

		"_construct" : function ( x, y ) {

			this.x = x || 0;
			this.y = y || 0;

		}


	});


	/*
	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );
	*/




	return numerics.Vector2 = Vector2 ;
});

define( 'skylark-langx-numerics/TransformMatrix',[
    "skylark-langx-klass",
    "./numerics",
    "./Vector2"
], function(klass,numerics,Vector2){
	// reference easeljs/numerics/Matrix2D  and dojox/gfx/matrix
	
	var DEG_TO_RAD = Math.PI/180;
	var _degToRadCache = {};
	var degToRad = function(degree){
		return _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));
	};
	var radToDeg = function(radian){ return radian / Math.PI * 180; };
	

	//Represents a 3 x 3 affine transformation matrix used for transformation in 2-D space.
	//|----------|
	//|m11|m21|dx| 
	//|----------|
	//|m12|m22|dy|
	//|----------|
	//|  0|  0| 1|
	//|----------|
	
    var TransformMatrix =  klass({
        "klassName": "TransformMatrix",

		"_multiplyPoint"	: 	function(p){
			// summary:
			//		applies the matrix to a point
			// p: Point
			//		a point
			// returns: Point
			var _ = this._,
				x = p.x * _.m11 + p.y * _.m21  + _.dx,
			    y = p.x * _.m12 +  p.y * _.m22 + _.dy;

			return new Vector2(x,y); // Point
		},

       "m11": {
       		//Position (0, 0) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m11;
            }
        },

       "m12": {
       		//Position (0, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m12;
            }
        },

       "m21": {
       		//Position (1, 0) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m21;
            }
        },

       "m22": {
       		//Position (1, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.m22;
            }
        },

       "dx": {
       		// Position (2, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.dx;
            }
        },

       "dy": {
       		// Position (2, 1) in a 3x3 affine transformation matrix.
            get : function() {
                return this._.dy;
            }
        },

       "alpha": {
       		// Property representing the alpha that will be applied to a display object. This is not part of matrix
       		// operations, but is used for operations like getConcatenatedMatrix to provide concatenated alpha values.
            get : function() {
                return this._.alpha;
            }
        },

       "shadow": {
       		// Property representing the shadow that will be applied to a display object. This is not part of matrix
       		// operations, but is used for operations like getConcatenatedMatrix to provide concatenated shadow values..
            get : function() {
                return this._.shadow;
            }
        },

       "compositeOperation": {
			/**
			 * Property representing the compositeOperation that will be applied to a display object. This is not part of
			 * matrix operations, but is used for operations like getConcatenatedMatrix to provide concatenated
			 * compositeOperation values. You can find a list of valid composite operations at:
			 * <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>
			 * @property compositeOperation
			 * @type String
			 **/
            get : function() {
                return this._.compositeOperation;
            }
        },

        //Converts the specified point with TransformMatrix and returns the result.
		multiplyPoint: /*Vector2*/function(/*Vector2 */ p){
			// summary:
			//		applies the matrix to a point
			return this._multiplyPoint(p); // Vector2
		},
				/**
				 *  TransformMatrix 
				 */
		multiplyRectangle: /*Rect*/function(/*Rect*/ rect){
			// summary:
			//		Applies the matrix to a rectangle.
			// returns: Rect
			if(this.isIdentity())
				return rect.clone(); // Rect
			var p0 = this.multiplyPoint(rect.leftTop),
				p1 = this.multiplyPoint(rect.leftBottom),
				p2 = this.multiplyPoint(rect.right),
				p3 = this.multiplyPoint(rect.rightBottom),
				minx = Math.min(p0.x, p1.x, p2.x, p3.x),
				miny = Math.min(p0.y, p1.y, p2.y, p3.y),
				maxx = Math.max(p0.x, p1.x, p2.x, p3.x),
				maxy = Math.max(p0.y, p1.y, p2.y, p3.y);
			return new Rect(minx,miny,maxx-minx,maxy-miny);  // Rect
		},
		/**
		 * Concatenates the specified matrix properties with this matrix. All parameters are required.
		 * @method prepend
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		prepend : function(m11, m12, m21, m22, dx, dy) {
			var tx1 = this.dx;
			if (m11 != 1 || m12 != 0 || m21 != 0 || m22 != 1) {
				var a1 = this.m11;
				var c1 = this.m21;
				this.m11  = a1*m11+this.m12*m21;
				this.m12  = a1*m12+this.m12*m22;
				this.m21  = c1*m11+this.m22*m21;
				this.m22  = c1*m12+this.m22*m22;
			}
			this.dx = tx1*m11+this.dy*m21+dx;
			this.dy = tx1*m12+this.dy*m22+dy;
			return this;
		},

		/**
		 * Appends the specified matrix properties with this matrix. All parameters are required.
		 *  Matrix Matrix
		 * @method append
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		append : function(m11, m12, m21, m22, dx, dy) {
			var a1 = this.m11;
			var b1 = this.m12;
			var c1 = this.m21;
			var d1 = this.m22;

			this.m11  = m11*a1+m12*c1;
			this.m12  = m11*b1+m12*d1;
			this.m21  = m21*a1+m22*c1;
			this.m22  = m21*b1+m22*d1;
			this.dx = dx*a1+dy*c1+this.dx;
			this.dy = dx*b1+dy*d1+this.dy;
			return this;
		},

		/**
		 * Prepends the specified matrix with this matrix.
		 * @method prependMatrix
		 * @param {TransformMatrix} matrix
		 **/
		prependMatrix : function(matrix) {
			this.prepend(matrix.m11, matrix.m12, matrix.m21, matrix.m22, matrix.dx, matrix.dy);
			this.prependProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
			return this;
		},

		/**
		 * Appends the specified matrix with this matrix.
		 *  Matrix Matrix
		 * @method appendMatrix
		 * @param {TransformMatrix} matrix
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		appendMatrix : function(matrix) {
			this.append(matrix.m11, matrix.m12, matrix.m21, matrix.m22, matrix.dx, matrix.dy);
			this.appendProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
			return this;
		},

		/**
		 * Generates matrix properties from the specified display object transform properties, and prepends them with this matrix.
		 * For example, you can use this to generate a matrix from a display object: var mtx = new TransformMatrix();
		 * mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method prependTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		prependTransform : function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}

			if (regX || regY) {
				// append the registration offset:
				this.dx -= regX; this.dy -= regY;
			}
			if (skewX || skewY) {
				// TODO: can this be combined into a single prepend operation?
				skewX *= DEG_TO_RAD;
				skewY *= DEG_TO_RAD;
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
				this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			} else {
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}
			return this;
		},

		/**
		 * Generates matrix properties from the specified display object transform properties, and appends them with this matrix.
		 * For example, you can use this to generate a matrix from a display object: var mtx = new TransformMatrix();
		 * mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method appendTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		appendTransform : function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}

			if (skewX || skewY) {
				// TODO: can this be combined into a single append?
				skewX *= DEG_TO_RAD;
				skewY *= DEG_TO_RAD;
				this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			} else {
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}

			if (regX || regY) {
				// prepend the registration offset:
				this.dx -= regX*this.m11+regY*this.m21; 
				this.dy -= regX*this.m12+regY*this.m22;
			}
			return this;
		},

		/**
		 * Applies a rotation transformation to the matrix.
		 * @method rotate
		 * @param {Number} angle The angle in degrees.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		rotate : function(angle) {
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);

			var a1 = this.m11;
			var c1 = this.m21;
			var tx1 = this.dx;

			this.m11 = a1*cos-this.m12*sin;
			this.m12 = a1*sin+this.m12*cos;
			this.m21 = c1*cos-this.m22*sin;
			this.m22 = c1*sin+this.m22*cos;
			this.dx = tx1*cos-this.dy*sin;
			this.dy = tx1*sin+this.dy*cos;
			return this;
		},

		/**
		 * Applies a skew transformation to the matrix.
		 * @method skew
		 * @param {Number} skewX The amount to skew horizontally in degrees.
		 * @param {Number} skewY The amount to skew vertically in degrees.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		skew : function(skewX, skewY) {
			skewX = skewX*DEG_TO_RAD;
			skewY = skewY*DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
			return this;
		},

		/**
		 * Applies a scale transformation to the matrix.
		 * @method scale
		 * @param {Number} x
		 * @param {Number} y
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		scale : function(x, y) {
			this.m11 *= x;
			this.m22 *= y;
			this.dx *= x;
			this.dy *= y;
			return this;
		},

		/**
		 * Translates the matrix on the x and y axes.
		 * @method translate
		 * @param {Number} x
		 * @param {Number} y
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		translate : function(x, y) {
			this.dx += x;
			this.dy += y;
			return this;
		},

		/**
		 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
		 * @method identity
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		identity : function() {
			this.alpha = this.m11 = this.m22 = 1;
			this.m12 = this.m21 = this.dx = this.dy = 0;
			this.shadow = this.compositeOperation = null;
			return this;
		},

		/**
		 * Inverts the matrix, causing it to perform the opposite transformation.
		 * @method invert
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		 **/
		invert : function() {
			var a1 = this.m11;
			var b1 = this.m12;
			var c1 = this.m21;
			var d1 = this.m22;
			var tx1 = this.dx;
			var n = a1*d1-b1*c1;

			this.m11 = d1/n;
			this.m12 = -b1/n;
			this.m21 = -c1/n;
			this.m22 = a1/n;
			this.dx = (c1*this.dy-d1*tx1)/n;
			this.dy = -(a1*this.dy-b1*tx1)/n;
			return this;
		},

		/**
		 * Returns true if the matrix is an identity matrix.
		 * @method isIdentity
		 * @return {Boolean}
		 **/
		isIdentity : function() {
			return this.dx == 0 && this.dy == 0 && this.m11 == 1 && this.m12 == 0 && this.m21 == 0 && this.m22 == 1;
		},

		/**
		 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that this these values
		 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
		 * results.
		 * @method decompose
		 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		decompose : function(target) {
			// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation
			// even when scale is negative
			if (target == null) { target = {}; }
			target.x = this.dx;
			target.y = this.dy;
			target.scaleX = Math.sqrt(this.m11 * this.m11 + this.m12 * this.m12);
			target.scaleY = Math.sqrt(this.m21 * this.m21 + this.m22 * this.m22);

			var skewX = Math.atan2(-this.m21, this.m22);
			var skewY = Math.atan2(this.m12, this.m11);

			if (skewX == skewY) {
				target.rotation = skewY/DEG_TO_RAD;
				if (this.m11 < 0 && this.m22 >= 0) {
					target.rotation += (target.rotation <= 0) ? 180 : -180;
				}
				target.skewX = target.skewY = 0;
			} else {
				target.skewX = skewX/DEG_TO_RAD;
				target.skewY = skewY/DEG_TO_RAD;
			}
			return target;
		},

		/**
		 * Reinitializes all matrix properties to those specified.
		 * @method appendProperties
		 * @param {Number} m11
		 * @param {Number} m12
		 * @param {Number} m21
		 * @param {Number} m22
		 * @param {Number} dx
		 * @param {Number} dy
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		reinitialize : function(m11,m12,m21,m22,dx,dy,alpha,shadow,compositeOperation) {
			this._initialize(m11,m12,m21,m22,dx,dy);
			this.alpha = alpha || 1;
			this.shadow = shadow;
			this.compositeOperation = compositeOperation;
			return this;
		},

		/**
		 * Appends the specified visual properties to the current matrix.
		 * @method appendProperties
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		appendProperties : function(alpha, shadow, compositeOperation) {
			this.alpha *= alpha;
			this.shadow = shadow || this.shadow;
			this.compositeOperation = compositeOperation || this.compositeOperation;
			return this;
		},

		/**
		 * Prepends the specified visual properties to the current matrix.
		 * @method prependProperties
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 * @return {TransformMatrix} This matrix. Useful for chaining method calls.
		*/
		prependProperties : function(alpha, shadow, compositeOperation) {
			this.alpha *= alpha;
			this.shadow = this.shadow || shadow;
			this.compositeOperation = this.compositeOperation || compositeOperation;
			return this;
		},

		/**
		 *Multiply TransformMatrix by another TransformMatrix.
		 */
		multiply: function(matrix){
			// summary:
			//		combines matrices by multiplying them sequentially in the given order
			// matrix: TransformMatrix
			//		a 2D matrix-like object,
			//		all subsequent arguments are matrix-like objects too

			// combine matrices
			var m11 = this.m11,m12 = this.m12,m21 = this.m21,m22=this.m22,dx=this.dx,dy=this.dy;
			var r = matrix;
			this.m11 = m11 * r.m11 + m21 * r.m12;
			this.m12 = m12 * r.m11 + m22 * r.m12;
			this.m21 = m11 * r.m21 + m21 * r.m22;
			this.m22 = m12 * r.m21 + m22 * r.m22;
			this.dx =  m11 * r.dx + m21 * r.dy + dx;
			this.dy =  m12 * r.dx + m22 * r.dy + dy;
			return this // TransformMatrix
		},

		/**
		 * Returns a clone of the TransformMatrix instance.
		 * @method clone
		 * @return {TransformMatrix} a clone of the TransformMatrix instance.
		 **/
		clone : function() {

			var _ = this._,
				mtx = new TransformMatrix(_.m11, _.m12, _.m21, _.m22, _.dx, _.dy);
			mtx.shadow = this.shadow;
			mtx.alpha = this.alpha;
			mtx.compositeOperation = this.compositeOperation;
			return mtx;
		},

		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		toString : function() {
			var _ = this._;
			return "[TransformMatrix (m11="+_.m11+" m12="+_.m12+" m21="+_.m21+" m22="+_.m22+" dx="+_.dx+" dy="+_.dy+")]";
		},
		
		"_construct" : function(m11, m12, m21, m22, dx, dy) {
			var _ = this._ = {};
			_.m11 = m11 || 1;
			_.m12 = m12 || 0;
			_.m21 = m21 || 0;
			_.m22 = m22 || 1;
			_.dx = dx || 0;
			_.dy = dy || 0;
		}

	});
	
	Object.assign(TransformMatrix,{
		translate: function(a, b){
			// summary:
			//		forms a translation matrix
			// description:
			//		The resulting matrix is used to translate (move) points by specified offsets.
			// a: Number
			//		an x coordinate value
			// b: Number
			//		a y coordinate value
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1|   0| a|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   1| b|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|

			return new TransformMatrix(1,0,0,1,a,b); // TransformMatrix
		},
		scale: function(a, b){
			// summary:
			//		forms a scaling matrix
			// description:
			//		The resulting matrix is used to scale (magnify) points by specified offsets.
			// a: Number
			//		a scaling factor used for the x coordinate
			// b: Number?
			//		a scaling factor used for the y coordinate
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  a|   0| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   b| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			return new TransformMatrix(a,0,0,b?b:a,0,0); // TransformMatrix
		},
		rotate: function(angle){
			// summary:
			//		forms a rotating matrix
			// description:
			//		The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		an angle of rotation in radians (>0 for CW)
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |cos|-sin| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |sin| cos| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);
			return new TransformMatrix(cos,sin,-sin,cos,0,0); // TransformMatrix
		},
		rotateg: function(degree){
			// summary:
			//		forms a rotating matrix
			// description:
			//		The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified degree.
			//		Seerotate() for comparison.
			// degree: Number
			//		an angle of rotation in degrees (>0 for CW)
			// returns: TransformMatrix
			return this.rotate(degToRad(degree)); // TransformMatrix
		},
		skewX: function(angle) {
			//TODO : will be modified
			// summary:
			//		forms an x skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		a skewing angle in radians
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1| tan| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |  0|   1| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var tan = Math.tan(angle);
			return new TransformMatrix(1,0,tan,1); // TransformMatrix
		},
		skewXg: function(degree){
			//TODO : will be modified
			// summary:
			//		forms an x skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox/gfx/matrix.skewX() for comparison.
			// degree: Number
			//		a skewing angle in degrees
			// returns: TransformMatrix
			return this.skewX(degToRad(degree)); // dojox/gfx/matrix.TransformMatrix
		},
		skewY: function(angle){
			//TODO : will be modified
			// summary:
			//		forms a y skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number
			//		a skewing angle in radians
			// returns: TransformMatrix
			//|----------| |-----------|
			//|m11|m21|dx| |  1|   0| 0|
			//|----------| |-----------|
			//|m12|m22|dy| |tan|   1| 0|
			//|----------| |-----------|
			//|  0|  0| 1| |  0|   0| 1|
			//|----------| |-----------|
			var tan = Math.tan(angle);

			return new TransformMatrix(1,tan,0,1); // TransformMatrix
		},
		skewYg: function(degree){
			//TODO : will be modified
			// summary:
			//		forms a y skewing matrix
			// description:
			//		The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See skewY() for comparison.
			// degree: Number
			//		a skewing angle in degrees
			// returns: TransformMatrix
			return this.skewY(degToRad(degree)); // TransformMatrix
		},
		reflect: function(a, b){
			// summary:
			//		forms a reflection matrix
			// description:
			//		The resulting matrix is used to reflect points around a vector,
			//		which goes through the origin.
			// a: dojox/gfx.Point|Number
			//		a point-like object, which specifies a vector of reflection, or an X value
			// b: Number?
			//		a Y value
			// returns: TransformMatrix
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, 
				xx=2 * a2 / n2 - 1, 
				xy = 2 * a * b / n2,
				yx = xy,
				yy = 2 * b2 / n2 - 1;
			return new TransformMatrix(xx,yx,xy, yy); // TransformMatrix
		},
		project: function(a, b){
			// summary:
			//		forms an orthogonal projection matrix
			// description:
			//		The resulting matrix is used to project points orthogonally on a vector,
			//		which goes through the origin.
			// a:   Number
			//		an x coordinate value
			// b: Number?
			//		a y coordinate value
			// returns: TransformMatrix

			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, 
				xx = a2 / n2,
				xy = a * b / n2
				yx = xy,
				yy = b2 / n2;
			return new TransformMatrix(xx,yx,xy,yy); // TransformMatrix
		},

		// common operations

		// high level operations

		_sandwich: function(matrix, x, y){
			// summary:
			//		applies a matrix at a central point
			// matrix: TransformMatrix
			//		a 2D matrix-like object, which is applied at a central point
			// x: Number
			//		an x component of the central point
			// y: Number
			//		a y component of the central point
			return this.translate(x, y).multiply(matrix)
			                           .multiply(this.translate(-x, -y)); // TransformMatrix
		},
		scaleAt: function(a, b, c, d){
			// summary:
			//		scales a picture using a specified point as a center of scaling
			// description:
			//		Compare with scale().
			// a: Number
			//		a scaling factor used for the x coordinate, or a uniform scaling factor used for both coordinates
			// b: Number?
			//		a scaling factor used for the y coordinate
			// c: Number|Point
			//		an x component of a central point, or a central point
			// d: Number
			//		a y component of a central point
			// returns: TransformMatrix
			switch(arguments.length){
				case 4:
					// a and b are scale factor components, c and d are components of a point
					return this._sandwich(this.scale(a, b), c, d); // TransformMatrix
				case 3:
					if(typeof c == "number"){
						return this._sandwich(this.scale(a), b, c); // TransformMatrix
					}
					return this._sandwich(this.scale(a, b), c.x, c.y); // TransformMatrix
			}
			return this._sandwich(this.scale(a), b.x, b.y); // TransformMatrix
		},
		rotateAt: function(angle, a, b){
			// summary:
			//		rotates a picture using a specified point as a center of rotation
			// description:
			//		Compare with rotate().
			// angle: Number
			//		an angle of rotation in radians (>0 for CW)
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.rotate(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.rotate(angle), a.x, a.y); // TransformMatrix
		},
		rotategAt: function(degree, a, b){
			// summary:
			//		rotates a picture using a specified point as a center of rotation
			// description:
			//		Compare with rotateg().
			// degree: Number
			//		an angle of rotation in degrees (>0 for CW)
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.rotateg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.rotateg(degree), a.x, a.y); // TransformMatrix
		},
		skewXAt: function(angle, a, b){
			// summary:
			//		skews a picture along the x axis using a specified point as a center of skewing
			// description:
			//		Compare with skewX().
			// angle: Number
			//		a skewing angle in radians
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewX(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewX(angle), a.x, a.y); // TransformMatrix
		},
		skewXgAt: function(degree, a, b){
			// summary:
			//		skews a picture along the x axis using a specified point as a center of skewing
			// description:
			//		Compare with skewXg().
			// degree: Number
			//		a skewing angle in degrees
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewXg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewXg(degree), a.x, a.y); // TransformMatrix
		},
		skewYAt: function(angle, a, b){
			// summary:
			//		skews a picture along the y axis using a specified point as a center of skewing
			// description:
			//		Compare with skewY().
			// angle: Number
			//		a skewing angle in radians
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewY(angle), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewY(angle), a.x, a.y); // TransformMatrix
		},
		skewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number? */ b){
			// summary:
			//		skews a picture along the y axis using a specified point as a center of skewing
			// description:
			//		Compare with skewYg().
			// degree: Number
			//		a skewing angle in degrees
			// a: Number|dojox/gfx.Point
			//		an x component of a central point, or a central point
			// b: Number?
			//		a y component of a central point
			// returns: TransformMatrix
			if(arguments.length > 2){
				return this._sandwich(this.skewYg(degree), a, b); // TransformMatrix
			}
			return this._sandwich(this.skewYg(degree), a.x, a.y); // TransformMatrix
		}
	
	
	});

	return numerics.TransformMatrix = TransformMatrix;
});

define('skylark-langx-numerics/TranslateTransform',[
    "./numerics",
    "./Transform",
    "./MatrixTransform"
],function(numerics,Transform,Matrix,Point,Rect) {

    //|1   0   dx|
    //|0   1   dy|
    //|0   0    1|

   var TranslateTransform =  Transform.inherit({
        "klassName": "TranslateTransform",

        "value": {
            get: function() {
                    return Matrix.scaleAt(this.x, this.y);
            }
        },

        "x": {
            get : function() {
                return this._.x;
            }
        },

        "y": {
            get : function() {
                return this._.y;
            }
        },

        clone: /*SkewTransform*/ function() {},

        transform: /*Point*/ function( /*Point*/ point) {},

        transformBounds: /*Rect*/ function( /*Rect*/ rect) {},

        "init": function( /*Number*/ x, /*Number*/ y) {
            var _ = this._;

            _.x = x ? x : 0;
            _.y = y ? y : 0;
        }
    });

    return numerics.TranslateTransform =TranslateTransform;
});	

define('skylark-langx-numerics/Vector4',[
	"skylark-langx-klass",
	"./numerics"
] ,function(klass,numerics) {

	var Vector4 = klass({
		"klassName" : "Vector4",

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;
		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;
		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		},


		"_construct" :function ( x, y, z, w ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;

		}

	});

/*
	Object.defineProperties( Vector4.prototype, {

		"width": {

			get: function () {

				return this.z;

			},

			set: function ( value ) {

				this.z = value;

			}

		},

		"height": {

			get: function () {

				return this.w;

			},

			set: function ( value ) {

				this.w = value;

			}

		}

	} );
*/

	return numerics.Vector4 = Vector4 ;

});
define('skylark-langx-numerics/main',[
	"./numerics",
	"./Euler",
	"./maths",
	"./Matrix3",
	"./Matrix4",
	"./MatrixTransform",
	"./Plane",
	"./Quaternion",
	"./RotateTransform",
	"./ScaleTransform",
	"./SkewTransform",
	"./Transform",
	"./TransformMatrix",
	"./TranslateTransform",
	"./Vector2",
	"./Vector3",
	"./Vector4"
],function(numerics){
	return numerics;
});
define('skylark-langx-numerics', ['skylark-langx-numerics/main'], function (main) { return main; });

define('skylark-langx/numerics',[
	"skylark-langx-numerics"
],function(numerics){
	return numerics;
});
define('skylark-langx/objects',[
    "skylark-langx-objects"
],function(objects){
    return objects;
});
define('skylark-langx-strings/strings',[
    "skylark-langx-ns"
],function(skylark){
    // add default escape function for escaping HTML entities
    var escapeCharMap = Object.freeze({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;',
        '=': '&#x3D;',
    });
    function replaceChar(c) {
        return escapeCharMap[c];
    }
    var escapeChars = /[&<>"'`=]/g;


     /*
     * Converts camel case into dashes.
     * @param {String} str
     * @return {String}
     * @exapmle marginTop -> margin-top
     */
    function dasherize(str) {
        return str.replace(/::/g, '/')
            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
            .replace(/([a-z\d])([A-Z])/g, '$1_$2')
            .replace(/_/g, '-')
            .toLowerCase();
    }

    function deserializeValue(value) {
        try {
            return value ?
                value == "true" ||
                (value == "false" ? false :
                    value == "null" ? null :
                    +value + "" == value ? +value :
                    /^[\[\{]/.test(value) ? JSON.parse(value) :
                    value) : value;
        } catch (e) {
            return value;
        }
    }

    function escapeHTML(str) {
        if (str == null) {
            return '';
        }
        if (!str) {
            return String(str);
        }

        return str.toString().replace(escapeChars, replaceChar);
    }

    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0;
            var v = c === 'x' ? r : ((r & 0x3) | 0x8);
            return v.toString(16);
        });
    }

    function trim(str) {
        return str == null ? "" : String.prototype.trim.call(str);
    }

    function substitute( /*String*/ template,
        /*Object|Array*/
        map,
        /*Function?*/
        transform,
        /*Object?*/
        thisObject) {
        // summary:
        //    Performs parameterized substitutions on a string. Throws an
        //    exception if any parameter is unmatched.
        // template:
        //    a string with expressions in the form `${key}` to be replaced or
        //    `${key:format}` which specifies a format function. keys are case-sensitive.
        // map:
        //    hash to search for substitutions
        // transform:
        //    a function to process all parameters before substitution takes


        thisObject = thisObject || window;
        transform = transform ?
            proxy(thisObject, transform) : function(v) {
                return v;
            };

        function getObject(key, map) {
            if (key.match(/\./)) {
                var retVal,
                    getValue = function(keys, obj) {
                        var _k = keys.pop();
                        if (_k) {
                            if (!obj[_k]) return null;
                            return getValue(keys, retVal = obj[_k]);
                        } else {
                            return retVal;
                        }
                    };
                return getValue(key.split(".").reverse(), map);
            } else {
                return map[key];
            }
        }

        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
            function(match, key, format) {
                var value = getObject(key, map);
                if (format) {
                    value = getObject(format, thisObject).call(thisObject, value, key);
                }
                return transform(value, key).toString();
            }); // String
    }

    var idCounter = 0;
    function uniqueId (prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    }


    /**
     * https://github.com/cho45/micro-template.js
     * (c) cho45 http://cho45.github.com/mit-license
     */
    function template (id, data) {

        function include(name, args) {
            var stash = {};
            for (var key in template.context.stash) if (template.context.stash.hasOwnProperty(key)) {
                stash[key] = template.context.stash[key];
            }
            if (args) for (var key in args) if (args.hasOwnProperty(key)) {
                stash[key] = args[key];
            }
            var context = template.context;
            context.ret += template(name, stash);
            template.context = context;
        }

        function wrapper(name, fun) {
            var current = template.context.ret;
            template.context.ret = '';
            fun.apply(template.context);
            var content = template.context.ret;
            var orig_content = template.context.stash.content;
            template.context.stash.content = content;
            template.context.ret = current + template(name, template.context.stash);
            template.context.stash.content = orig_content;
        }

        var me = arguments.callee;
        if (!me.cache[id]) me.cache[id] = (function () {
            var name = id, string = /^[\w\-]+$/.test(id) ? me.get(id): (name = 'template(string)', id); // no warnings
            var line = 1, body = (
                "try { " +
                    (me.variable ?  "var " + me.variable + " = this.stash;" : "with (this.stash) { ") +
                        "this.ret += '"  +
                        string.
                            replace(/<%/g, '\x11').replace(/%>/g, '\x13'). // if you want other tag, just edit this line
                            replace(/'(?![^\x11\x13]+?\x13)/g, '\\x27').
                            replace(/^\s*|\s*$/g, '').
                            replace(/\n|\r\n/g, function () { return "';\nthis.line = " + (++line) + "; this.ret += '\\n" }).
                            replace(/\x11=raw(.+?)\x13/g, "' + ($1) + '").
                            replace(/\x11=(.+?)\x13/g, "' + this.escapeHTML($1) + '").
                            replace(/\x11(.+?)\x13/g, "'; $1; this.ret += '") +
                    "'; " + (me.variable ? "" : "}") + "return this.ret;" +
                "} catch (e) { throw 'TemplateError: ' + e + ' (on " + name + "' + ' line ' + this.line + ')'; } " +
                "//@ sourceURL=" + name + "\n" // source map
            ).replace(/this\.ret \+= '';/g, '');
            var func = new Function(body);
            var map  = { '&' : '&amp;', '<' : '&lt;', '>' : '&gt;', '\x22' : '&#x22;', '\x27' : '&#x27;' };
            var escapeHTML = function (string) { return (''+string).replace(/[&<>\'\"]/g, function (_) { return map[_] }) };
            return function (stash) { return func.call(me.context = { escapeHTML: escapeHTML, line: 1, ret : '', stash: stash }) };
        })();
        return data ? me.cache[id](data) : me.cache[id];
    }

    template.cache = {};
    

    template.get = function (id) {
        return document.getElementById(id).innerHTML;
    };


    function ltrim(str) {
        return str.replace(/^\s+/, '');
    }
    
    function rtrim(str) {
        return str.replace(/\s+$/, '');
    }

    // Slugify a string
    function slugify(str) {
        str = str.replace(/^\s+|\s+$/g, '');

        // Make the string lowercase
        str = str.toLowerCase();

        // Remove accents, swap  for n, etc
        var from = "a/_,:;";
        var to   = "AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------";
        for (var i=0, l=from.length ; i<l ; i++) {
            str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
        }

        // Remove invalid chars
        //str = str.replace(/[^a-z0-9 -]/g, '') 
        // Collapse whitespace and replace by -
        str = str.replace(/\s+/g, '-') 
        // Collapse dashes
        .replace(/-+/g, '-'); 

        return str;
    }    

    // return boolean if string 'true' or string 'false', or if a parsable string which is a number
    // also supports JSON object and/or arrays parsing
    function toType(str) {
        var type = typeof str;
        if (type !== 'string') {
            return str;
        }
        var nb = parseFloat(str);
        if (!isNaN(nb) && isFinite(str)) {
            return nb;
        }
        if (str === 'false') {
            return false;
        }
        if (str === 'true') {
            return true;
        }

        try {
            str = JSON.parse(str);
        } catch (e) {}

        return str;
    }

	return skylark.attach("langx.strings",{
        camelCase: function(str) {
            return str.replace(/-([\da-z])/g, function(a) {
                return a.toUpperCase().replace('-', '');
            });
        },

        dasherize: dasherize,

        deserializeValue: deserializeValue,

        escapeHTML : escapeHTML,

        generateUUID : generateUUID,

        ltrim : ltrim,

        lowerFirst: function(str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
        },

        rtrim : rtrim,

        serializeValue: function(value) {
            return JSON.stringify(value)
        },


        substitute: substitute,

        slugify : slugify,

        //template : template,

        trim: trim,

        uniqueId: uniqueId,

        upperFirst: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
	}) ; 

});
define('skylark-langx-strings/base64',[
	"./strings"
],function(strings) {

	// private property
	const _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

	// private method for UTF-8 encoding
	function _utf8_encode(string) {
		string = string.replace(/\r\n/g,"\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			}
			else if((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			}
			else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	}

	// private method for UTF-8 decoding
	function _utf8_decode(utftext) {
		var string = "";
		var i = 0;
		var c = c1 = c2 = 0;

		while ( i < utftext.length ) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			}
			else if((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i+1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			}
			else {
				c2 = utftext.charCodeAt(i+1);
				c3 = utftext.charCodeAt(i+2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}

		}

		return string;
	}

	// public method for encoding
	function encode(input, binary) {
		binary = (binary != null) ? binary : false;
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		if (!binary)
		{
			input = _utf8_encode(input);
		}

		while (i < input.length) {

			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

		}

		return output;
	}

	// public method for decoding
	function decode(input, binary) {
		binary = (binary != null) ? binary : false;
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		if (!binary) {
			output = _utf8_decode(output);
		}

		return output;

	}


	return strings.base64 = {
		decode,
		encode
	};
	
});
define('skylark-langx-strings/main',[
	"./strings",
	"./base64"
],function(strings){
	return strings;
});
define('skylark-langx-strings', ['skylark-langx-strings/main'], function (main) { return main; });

define('skylark-langx/strings',[
    "skylark-langx-strings"
],function(strings){
    return strings;
});
define('skylark-langx/Stateful',[
	"./Evented",
  "./strings",
  "./objects"
],function(Evented,strings,objects){
    var isEqual = objects.isEqual,
        mixin = objects.mixin,
        result = objects.result,
        isEmptyObject = objects.isEmptyObject,
        clone = objects.clone,
        uniqueId = strings.uniqueId;

    var Stateful = Evented.inherit({
        _construct : function(attributes, options) {
            var attrs = attributes || {};
            options || (options = {});
            this.cid = uniqueId(this.cidPrefix);
            this.attributes = {};
            if (options.collection) this.collection = options.collection;
            if (options.parse) attrs = this.parse(attrs, options) || {};
            var defaults = result(this, 'defaults');
            attrs = mixin({}, defaults, attrs);
            this.set(attrs, options);
            this.changed = {};
        },

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: 'c',


        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return clone(this.attributes);
        },


        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null) return this;

          // Handle both `"key", value` and `{key: value}` -style arguments.
          var attrs;
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }

          options || (options = {});

          // Run validation.
          if (!this._validate(attrs, options)) return false;

          // Extract attributes and options.
          var unset      = options.unset;
          var silent     = options.silent;
          var changes    = [];
          var changing   = this._changing;
          this._changing = true;

          if (!changing) {
            this._previousAttributes = clone(this.attributes);
            this.changed = {};
          }

          var current = this.attributes;
          var changed = this.changed;
          var prev    = this._previousAttributes;

          // For each `set` attribute, update or delete the current value.
          for (var attr in attrs) {
            val = attrs[attr];
            if (!isEqual(current[attr], val)) changes.push(attr);
            if (!isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }

          // Update the `id`.
          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

          // Trigger all relevant attribute changes.
          if (!silent) {
            if (changes.length) this._pending = options;
            for (var i = 0; i < changes.length; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }

          // You might be wondering why there's a `while` loop here. Changes can
          // be recursively nested within `"change"` events.
          if (changing) return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, mixin({}, options, {unset: true}));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes) attrs[key] = void 0;
          return this.set(attrs, mixin({}, options, {unset: true}));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !isEmptyObject(this.changed);
          return this.changed[attr] !== undefined;
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff) return this.hasChanged() ? clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          for (var attr in diff) {
            var val = diff[attr];
            if (isEqual(old[attr], val)) continue;
            changed[attr] = val;
          }
          return !isEmptyObject(changed) ? changed : false;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;
          return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return clone(this._previousAttributes);
        },

        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },

        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, mixin({}, options, {validate: true}));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate) return true;
          attrs = mixin({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error) return true;
          this.trigger('invalid', this, error, mixin(options, {validationError: error}));
          return false;
        }
    });

	return Stateful;
});
define('skylark-langx-topic/topic',[
	"skylark-langx-ns",
	"skylark-langx-events"
],function(skylark,events){
	var hub = new events.Emitter();

	return skylark.attach("langx.topic",{
	    publish: function(name, arg1,argn) {
	        var data = [].slice.call(arguments, 1);

	        return hub.trigger({
	            type : name,
	            data : data
	        });
	    },

        subscribe: function(name, listener,ctx) {
        	var handler = function(e){
                listener.apply(ctx,e.data);
            };
            hub.on(name, handler);
            return {
            	remove : function(){
            		hub.off(name,handler);
            	}
            }

        }

	});
});
define('skylark-langx-topic/main',[
	"./topic"
],function(topic){
	return topic;
});
define('skylark-langx-topic', ['skylark-langx-topic/main'], function (main) { return main; });

define('skylark-langx/topic',[
	"skylark-langx-topic"
],function(topic){
	return topic;
});
define('skylark-langx/types',[
    "skylark-langx-types"
],function(types){
    return types;
});
define('skylark-langx/langx',[
    "./skylark",
    "./arrays",
    "./ArrayStore",
    "./aspect",
    "./async",
    "./binary",
    "./constructs",
    "./datetimes",
    "./Deferred",
    "./Emitter",
    "./Evented",
    "./events",
    "./funcs",
    "./globals",
    "./hoster",
    "./klass",
    "./maths",
    "./numerics",
    "./objects",
    "./Stateful",
    "./strings",
    "./topic",
    "./types"
], function(
    skylark,
    arrays,
    ArrayStore,
    aspect,
    async,
    binary,
    constructs,
    datetimes,
    Deferred,
    Emitter,
    Evented,
    events,
    funcs,
    globals,
    hoster,
    klass,
    maths,
    numerics,
    objects,
    Stateful,
    strings,
    topic,
    types
) {
    "use strict";
    var toString = {}.toString,
        concat = Array.prototype.concat,
        indexOf = Array.prototype.indexOf,
        slice = Array.prototype.slice,
        filter = Array.prototype.filter,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin,
        isFunction = types.isFunction;


    function funcArg(context, arg, idx, payload) {
        return isFunction(arg) ? arg.call(context, idx, payload) : arg;
    }

    function getQueryParams(url) {
        var url = url || window.location.href,
            segs = url.split("?"),
            params = {};

        if (segs.length > 1) {
            segs[1].split("&").forEach(function(queryParam) {
                var nv = queryParam.split('=');
                params[nv[0]] = nv[1];
            });
        }
        return params;
    }


    function toPixel(value) {
        // style values can be floats, client code may want
        // to round for integer pixels.
        return parseFloat(value) || 0;
    }


    var _uid = 1;

    function uid(obj) {
        return obj._uid || (obj._uid = _uid++);
    }

    function langx() {
        return langx;
    }

    mixin(langx, {
        createEvent : Emitter.createEvent,

        funcArg: funcArg,

        getQueryParams: getQueryParams,

        toPixel: toPixel,

        uid: uid,

        URL: typeof window !== "undefined" ? window.URL || window.webkitURL : null

    });


    mixin(langx, arrays,aspect,datetimes,funcs,numerics,objects,strings,types,{
        ArrayStore : ArrayStore,

        async : async,
        
        Deferred: Deferred,

        Emitter: Emitter,

        Evented: Evented,

        hoster : hoster,

        klass : klass,
       
        Stateful: Stateful,

        topic : topic
    });

    return skylark.langx = langx;
});
define('skylark-domx-browser/browser',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {
    "use strict";

    var browser = langx.hoster.browser;


    langx.mixin(browser, {

        isIE : !!/msie/i.exec( window.navigator.userAgent ),

        location: function() {
            return window.location;
        },

        support : {

        }

    });



    return skylark.attach("domx.browser",browser);
});

define('skylark-domx-browser/support/css3',[
    "skylark-langx/langx",
    "../browser"
], function(langx,browser) {
    "use strict";

    var checkedCssProperties = {
            "transitionproperty": "TransitionProperty",
        },
        transEndEventNames = {
          WebkitTransition : 'webkitTransitionEnd',
          MozTransition    : 'transitionend',
          OTransition      : 'oTransitionEnd otransitionend',
          transition       : 'transitionend'
        },
        transEndEventName = null;


    var css3PropPrefix = "",
        css3StylePrefix = "",
        css3EventPrefix = "",

        cssStyles = {},
        cssProps = {},

        vendorPrefix,
        vendorPrefixRE,
        vendorPrefixesRE = /^(Webkit|webkit|O|Moz|moz|ms)(.*)$/,

        document = window.document,
        testEl = document.createElement("div"),

        matchesSelector = testEl.webkitMatchesSelector ||
                          testEl.mozMatchesSelector ||
                          testEl.oMatchesSelector ||
                          testEl.matchesSelector,

        testStyle = testEl.style;

    for (var name in testStyle) {
        var matched = name.match(vendorPrefixRE || vendorPrefixesRE);
        if (matched) {
            if (!vendorPrefixRE) {
                vendorPrefix = matched[1];
                vendorPrefixRE = new RegExp("^(" + vendorPrefix + ")(.*)$");

                css3StylePrefix = vendorPrefix;
                css3PropPrefix = '-' + vendorPrefix.toLowerCase() + '-';
                css3EventPrefix = vendorPrefix.toLowerCase();
            }

            cssStyles[langx.lowerFirst(matched[2])] = name;
            var cssPropName = langx.dasherize(matched[2]);
            cssProps[cssPropName] = css3PropPrefix + cssPropName;

            if (transEndEventNames[name]) {
              transEndEventName = transEndEventNames[name];
            }
        }
    }

    if (!transEndEventName) {
        if (testStyle["transition"] !== undefined) {
            transEndEventName = transEndEventNames["transition"];
        }
    }

    function normalizeCssEvent(name) {
        return css3EventPrefix ? css3EventPrefix + name : name.toLowerCase();
    }

    function normalizeCssProperty(name) {
        return cssProps[name] || name;
    }

    function normalizeStyleProperty(name) {
        return cssStyles[name] || name;
    }


    var css3 = {

        normalizeStyleProperty: normalizeStyleProperty,

        normalizeCssProperty: normalizeCssProperty,

        normalizeCssEvent: normalizeCssEvent,

        matchesSelector: matchesSelector        
    };

    langx.mixin(browser,css3);

    browser.css3PropPrefix = css3.propPrefix =  css3PropPrefix;

    if  (transEndEventName) {
        browser.support.transition = css3.transition = {
            end : transEndEventName
        };
    }

    browser.support.cssPointerEvents = css3.pointerEvents =  (function() {
        testEl.style.cssText = 'pointer-events:auto';
        return testEl.style.pointerEvents === 'auto';
    })(),




    testEl = null;

    return browser.support.css3 = css3;
});

define('skylark-domx-browser/support/fullscreen',[
	"../browser"
],function(browser){

    const FullscreenApi = { 
    	prefixed: true 
    };

    const apiMap = [
        [
            'requestFullscreen',
            'exitFullscreen',
            'fullscreenElement',
            'fullscreenEnabled',
            'fullscreenchange',
            'fullscreenerror',
            'fullscreen'
        ],
        [
            'webkitRequestFullscreen',
            'webkitExitFullscreen',
            'webkitFullscreenElement',
            'webkitFullscreenEnabled',
            'webkitfullscreenchange',
            'webkitfullscreenerror',
            '-webkit-full-screen'
        ],
        [
            'mozRequestFullScreen',
            'mozCancelFullScreen',
            'mozFullScreenElement',
            'mozFullScreenEnabled',
            'mozfullscreenchange',
            'mozfullscreenerror',
            '-moz-full-screen'
        ],
        [
            'msRequestFullscreen',
            'msExitFullscreen',
            'msFullscreenElement',
            'msFullscreenEnabled',
            'MSFullscreenChange',
            'MSFullscreenError',
            '-ms-fullscreen'
        ]
    ];
    const specApi = apiMap[0];
    let browserApi;
    for (let i = 0; i < apiMap.length; i++) {
        if (apiMap[i][1] in document) {
            browserApi = apiMap[i];
            break;
        }
    }
    if (browserApi) {
        for (let i = 0; i < browserApi.length; i++) {
            FullscreenApi[specApi[i]] = browserApi[i];
        }
        FullscreenApi.prefixed = browserApi[0] !== specApi[0];

        browser.requestFullscreen = document.body[FullscreenApi["requestFullscreen"]];
        browser.exitFullscreen = document[FullscreenApi["exitFullscreen"]];

        browser.support.fullscreen = FullscreenApi;
    } else {
	    browser.support.fullscreen = null;
    }

    return browser.support.fullscreen;
});
define('skylark-domx-browser/main',[
	"./browser",
	"./support/css3",
	"./support/fullscreen"
],function(browser){
	return browser;
});
define('skylark-domx-browser', ['skylark-domx-browser/main'], function (main) { return main; });

define('skylark-domx/browser',[
    "skylark-domx-browser"
], function(browser) {
    "use strict";

    return browser;
});

define('skylark-domx-noder/noder',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser"
], function(skylark, langx, browser) {
    var isIE = !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g),
        fragmentRE = /^\s*<(\w+|!)[^>]*>/,
        singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        div = document.createElement("div"),
        table = document.createElement('table'),
        tableBody = document.createElement('tbody'),
        tableRow = document.createElement('tr'),
        containers = {
            'tr': tableBody,
            'tbody': table,
            'thead': table,
            'tfoot': table,
            'td': tableRow,
            'th': tableRow,
            '*': div
        },
        rootNodeRE = /^(?:body|html)$/i,
        map = Array.prototype.map,
        slice = Array.prototype.slice;



    function normalizeContent(content) {
        if (typeof content === 'function') {
            content = content();
        }
        return map.call(langx.isArrayLike(content) ? content : [content],value => {
            if (typeof value === 'function') {
                value = value();
            }
            if (isElement(value) || isTextNode(value)) {
                return value;
            }
            if (typeof value === 'string' && /\S/.test(value)) {
                return document.createTextNode(value);
            }
        }).filter(value => value);
    }

    function ensureNodes(content, copyByClone) {
        var nodes = normalizeContent(content);


        //if (!langx.isArrayLike(nodes)) {
        //    nodes = [nodes];
        //}
        if (copyByClone) {
            nodes = map.call(nodes, function(node) {
                return node.cloneNode(true);
            });
        }
        return langx.flatten(nodes);
    }

    function nodeName(elm, chkName) {
        var name = elm.nodeName && elm.nodeName.toLowerCase();
        if (chkName !== undefined) {
            return name === chkName.toLowerCase();
        }
        return name;
    };


    function activeElement(doc) {
        doc = doc || document;
        var el;

        // Support: IE 9 only
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
            el = doc.activeElement;
        } catch ( error ) {
            el = doc.body;
        }

        // Support: IE 9 - 11 only
        // IE may return null instead of an element
        // Interestingly, this only seems to occur when NOT in an iframe
        if ( !el ) {
            el = doc.body;
        }

        // Support: IE 11 only
        // IE11 returns a seemingly empty object in some cases when accessing
        // document.activeElement from an <iframe>
        if ( !el.nodeName ) {
            el = doc.body;
        }

        return el;
    };

    function enhancePlaceContent(placing,node) {
        if (langx.isFunction(placing)) {
            return placing.apply(node,[]);
        }
        if (langx.isArrayLike(placing)) {
            var neddsFlattern;
            for (var i=0;i<placing.length;i++) {
                if (langx.isFunction(placing[i])) {
                    placing[i] = placing[i].apply(node,[]);
                    if (langx.isArrayLike(placing[i])) {
                        neddsFlattern = true;
                    }
                }
            }
            if (neddsFlattern) {
                placing = langx.flatten(placing);
            }
        }
        return placing;
    }
    function after(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone),
                refNode = refNode.nextSibling;

            for (var i = 0; i < nodes.length; i++) {
                if (refNode) {
                    parent.insertBefore(nodes[i], refNode);
                } else {
                    parent.appendChild(nodes[i]);
                }
            }
        }
        return this;
    }

    function append(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var parentNode = node,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            parentNode.appendChild(nodes[i]);
        }
        return this;
    }

    function before(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone);
            for (var i = 0; i < nodes.length; i++) {
                parent.insertBefore(nodes[i], refNode);
            }
        }
        return this;
    }
    /*   
     * Get the children of the specified node, including text and comment nodes.
     * @param {HTMLElement} elm
     */
    function contents(elm) {
        if (nodeName(elm, "iframe")) {
            return elm.contentDocument;
        }
        return elm.childNodes;
    }

    /*   
     * Create a element and set attributes on it.
     * @param {HTMLElement} tag
     * @param {attrs} attrs
     * @param } parent
     */
    function createElement(tag, props,attrs, parent) {
        var node;

        if (/svg/i.test(tag)) {
            node = document.createElementNS("http://www.w3.org/2000/svg", tag)
        } else {
            node = document.createElement(tag);
        }

        if (langx.isHtmlNode(props)) {
            parent = props;
            props = null;
            attrs = null;
        } else if (langx.isHtmlNode(attrs)){
            parent = attrs;
            attrs = null;
        }

        if (props) {
            for (var name in props) {
                node[name] = props[name];
            }
        }

        if (attrs) {
            for (var name in attrs) {
                node.setAttribute(name, attrs[name]);
            }
        }
        if (parent) {
            append(parent, node);
        }
        return node;
    }

function removeSelfClosingTags(xml) {
    var split = xml.split("/>");
    var newXml = "";
    for (var i = 0; i < split.length - 1;i++) {
        var edsplit = split[i].split("<");
        newXml += split[i] + "></" + edsplit[edsplit.length - 1].split(" ")[0] + ">";
    }
    return newXml + split[split.length-1];
}

    /*   
     * Create a DocumentFragment from the HTML fragment.
     * @param {String} html
     */
    function createFragment(html) {
        // A special case optimization for a single tag
        html = langx.trim(html);
        if (singleTagRE.test(html)) {
            return [createElement(RegExp.$1)];
        }

        var name = fragmentRE.test(html) && RegExp.$1
        if (!(name in containers)) {
            name = "*"
        }
        var container = containers[name];
        container.innerHTML = removeSelfClosingTags("" + html);
        dom = slice.call(container.childNodes);

        dom.forEach(function(node) {
            container.removeChild(node);
        })

        return dom;
    }

    /*   
     * Create a deep copy of the set of matched elements.
     * @param {HTMLElement} node
     * @param {Boolean} deep
     */
    function clone(node, deep) {
        var self = this,
            clone;

        // TODO: Add feature detection here in the future
        if (!isIE || node.nodeType !== 1 || deep) {
            return node.cloneNode(deep);
        }

        // Make a HTML5 safe shallow copy
        if (!deep) {
            clone = document.createElement(node.nodeName);

            // Copy attribs
            each(self.getAttribs(node), function(attr) {
                self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
            });

            return clone;
        }
    }

    /*   
     * Check to see if a dom node is a descendant of another dom node .
     * @param {String} node
     * @param {Node} child
     */
    function contains(node, child) {
        return isChildOf(child, node);
    }

    /*   
     * Create a new Text node.
     * @param {String} text
     * @param {Node} child
     */
    function createTextNode(text) {
        return document.createTextNode(text);
    }

    /*   
     * Get the current document object.
     */
    function doc() {
        return document;
    }

    /*   
     * Remove all child nodes of the set of matched elements from the DOM.
     * @param {Object} node
     */
    function empty(node) {
        while (node.hasChildNodes()) {
            var child = node.firstChild;
            node.removeChild(child);
        }
        return this;
    }

    var fulledEl = null;

    function fullscreen(el) {
        if (el === false) {
            return browser.exitFullscreen.apply(document);
        } else if (el) {
            return browser.requestFullscreen.apply(el);
            fulledEl = el;
        } else {
            return (
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement
            )
        }
    }

    function isFullscreen(el) {
        return fullscreen() === el;
    }


    // Selectors
    function focusable( element, hasTabindex ) {
        var map, mapName, img, focusableIfVisible, fieldset,
            nodeName = element.nodeName.toLowerCase();

        if ( "area" === nodeName ) {
            map = element.parentNode;
            mapName = map.name;
            if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                return false;
            }
            img = $( "img[usemap='#" + mapName + "']" );
            return img.length > 0 && img.is( ":visible" );
        }

        if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
            focusableIfVisible = !element.disabled;

            if ( focusableIfVisible ) {

                // Form controls within a disabled fieldset are disabled.
                // However, controls within the fieldset's legend do not get disabled.
                // Since controls generally aren't placed inside legends, we skip
                // this portion of the check.
                fieldset = $( element ).closest( "fieldset" )[ 0 ];
                if ( fieldset ) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ( "a" === nodeName ) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }

        return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
    };

    function fromPoint(x,y) {
        return document.elementFromPoint(x,y);
    }

    /**
     * Generate id
     * @param   {HTMLElement} el
     * @returns {String}
     * @private
     */
    function generateId(el) {
        var str = el.tagName + el.className + el.src + el.href + el.textContent,
            i = str.length,
            sum = 0;

        while (i--) {
            sum += str.charCodeAt(i);
        }

        return sum.toString(36);
    }


   var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
 
    /*   
     * Get the HTML contents of the first element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} html
     */
    function html(node, html) {
        if (html === undefined) {
            return node.innerHTML;
        } else {
            this.empty(node);
            html = html || "";
            if (langx.isString(html)) {
                html = html.replace( rxhtmlTag, "<$1></$2>" );
            }
            if (langx.isString(html) || langx.isNumber(html)) {               
                node.innerHTML = html;
            } else if (langx.isArrayLike(html)) {
                for (var i = 0; i < html.length; i++) {
                    node.appendChild(html[i]);
                }
            } else {
                node.appendChild(html);
            }

            return this;
        }
    }


    /*   
     * Check to see if a dom node is a descendant of another dom node.
     * @param {Node} node
     * @param {Node} parent
     * @param {Node} directly
     */
    function isChildOf(node, parent, directly) {
        if (directly) {
            return node.parentNode === parent;
        }
        if (document.documentElement.contains) {
            return parent.contains(node);
        }
        while (node) {
            if (parent === node) {
                return true;
            }

            node = node.parentNode;
        }

        return false;
    }

    /*   
     * Check to see if a dom node is a document.
     * @param {Node} node
     */
    function isDocument(node) {
        return node != null && node.nodeType == node.DOCUMENT_NODE
    }

    /*   
     * Check to see if a dom node is in the document
     * @param {Node} node
     */
    function isInDocument(node) {
      return (node === document.body) ? true : document.body.contains(node);
    }        

    var blockNodes = ["div", "p", "ul", "ol", "li", "blockquote", "hr", "pre", "h1", "h2", "h3", "h4", "h5", "table"];

    function isBlockNode(node) {
        if (!node || node.nodeType === 3) {
          return false;
        }
        return new RegExp("^(" + (blockNodes.join('|')) + ")$").test(node.nodeName.toLowerCase());
    }

    function isActive (elem) {
            return elem === document.activeElement && (elem.type || elem.href);
    }


    function isTextNode(node) {
        return node && node.nodeType === 3;
    }


    function isElement(node) {
        return node && node.nodeType === 1;
    }

    function isInFrame() {
        try {
            return window.parent !== window.self;
        } catch (x) {
            return true;
        }
    }

    /*   
     * Get the owner document object for the specified element.
     * @param {Node} elm
     */
    function ownerDoc(elm) {
        if (!elm) {
            return document;
        }

        if (elm.nodeType == 9) {
            return elm;
        }

        return elm.ownerDocument;
    }

    /*   
     *
     * @param {Node} elm
     */
    function ownerWindow(elm) {
        var doc = ownerDoc(elm);
        return doc.defaultView || doc.parentWindow;
    }

    /*   
     * insert one or more nodes as the first children of the specified node.
     * @param {Node} node
     * @param {Node or ArrayLike} placing
     * @param {Boolean Optional} copyByClone
     */
    function prepend(node, placing, copyByClone) {
        var parentNode = node,
            refNode = parentNode.firstChild,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            if (refNode) {
                parentNode.insertBefore(nodes[i], refNode);
            } else {
                parentNode.appendChild(nodes[i]);
            }
        }
        return this;
    }

    /*   
     *
     * @param {Node} elm
     */
    function offsetParent(elm) {
        var parent = elm.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && document.defaultView.getComputedStyle(parent).position == "static") {
            parent = parent.offsetParent;
        }
        return parent;
    }

    /*   
     * Remove the set of matched elements from the DOM.
     * @param {Node} node
     */
    function remove(node) {
        if (node && node.parentNode) {
            try {
                node.parentNode.removeChild(node);
            } catch (e) {
                console.warn("The node is already removed", e);
            }
        }
        return this;
    }

    function removeChild(node,children) {
        if (!langx.isArrayLike(children)) {
            children = [children];
        }
        for (var i=0;i<children.length;i++) {
            node.removeChild(children[i]);
        }

        return this;
    }

    function scrollParent( elm, includeHidden ) {
        var position = document.defaultView.getComputedStyle(elm).position,
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollParent = this.parents().filter( function() {
                var parent = $( this );
                if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                    return false;
                }
                return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                    parent.css( "overflow-x" ) );
            } ).eq( 0 );

        return position === "fixed" || !scrollParent.length ?
            $( this[ 0 ].ownerDocument || document ) :
            scrollParent;
    };


    function reflow(elm) {
        if (el == null) {
          elm = document;
        }
        elm.offsetHeight;

        return this;      
    }

    /*   
     * Replace an old node with the specified node.
     * @param {Node} node
     * @param {Node} oldNode
     */
    function replace(node, oldNode) {
        oldNode.parentNode.replaceChild(node, oldNode);
        return this;
    }


    function selectable(elem, selectable) {
        if (elem === undefined || elem.style === undefined)
            return;
        elem.onselectstart = selectable ? function () {
            return false;
        } : function () {
        };
        elem.style.MozUserSelect = selectable ? 'auto' : 'none';
        elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
        elem.unselectable = selectable ? 'on' : 'off';
    }

    /*   
     * traverse the specified node and its descendants, perform the callback function on each
     * @param {Node} node
     * @param {Function} fn
     */
    function traverse(node, fn) {
        fn(node)
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            traverse(node.childNodes[i], fn);
        }
        return this;
    }

    /*   
     *
     * @param {Node} node
     */
    function reverse(node) {
        var firstChild = node.firstChild;
        for (var i = node.children.length - 1; i > 0; i--) {
            if (i > 0) {
                var child = node.children[i];
                node.insertBefore(child, firstChild);
            }
        }
    }

    /*   
     * Wrap an HTML structure around each element in the set of matched elements.
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapper(node, wrapperNode) {
        if (langx.isString(wrapperNode)) {
            wrapperNode = this.createFragment(wrapperNode).firstChild;
        }
        node.parentNode.insertBefore(wrapperNode, node);
        wrapperNode.appendChild(node);
    }

    /*   
     * Wrap an HTML structure around the content of each element in the set of matched
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapperInner(node, wrapperNode) {
        var childNodes = slice.call(node.childNodes);
        node.appendChild(wrapperNode);
        for (var i = 0; i < childNodes.length; i++) {
            wrapperNode.appendChild(childNodes[i]);
        }
        return this;
    }

    /*   
     * Remove the parents of the set of matched elements from the DOM, leaving the matched
     * @param {Node} node
     */
    function unwrap(node) {
        var child, parent = node.parentNode;
        if (parent) {
            if (this.isDoc(parent.parentNode)) return;
            parent.parentNode.insertBefore(node, parent);
        }
    }



    function isInput (el) { 
        return el.tagName === 'INPUT' || 
               el.tagName === 'TEXTAREA' || 
               el.tagName === 'SELECT' || 
               isEditable(el); 
    }
    
    function isEditable (el) {
      if (!el) { return false; } // no parents were editable
      if (el.contentEditable === 'false') { return false; } // stop the lookup
      if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain
      return isEditable(el.parentNode); // contentEditable is set to 'inherit'
    }

    function noder() {
        return noder;
    }

    langx.mixin(noder, {
        active  : activeElement,

        after: after,

        append: append,

        before: before,

        blur : function(el) {
            el.blur();
        },

        body: function() {
            return document.body;
        },

        clone: clone,

        contains: contains,

        contents: contents,

        createElement: createElement,

        createFragment: createFragment,

        createTextNode: createTextNode,

        doc: doc,

        empty: empty,

        generateId,

        fullscreen: fullscreen,

        focusable: focusable,

        fromPoint,

        html: html,

        isActive,

        isChildOf,

        isDocument,

        isEditable,
        
        isElement,

        isFullscreen,

        isInDocument,

        isInFrame,

        isInput,

        isTextNode,

        isWindow: langx.isWindow,

        nodeName : nodeName,

        offsetParent: offsetParent,

        ownerDoc: ownerDoc,

        ownerWindow: ownerWindow,

        prepend: prepend,

        reflow: reflow,

        remove: remove,

        removeChild : removeChild,

        replace: replace,

        selectable,

        traverse: traverse,

        reverse: reverse,

        wrapper: wrapper,

        wrapperInner: wrapperInner,

        unwrap: unwrap
    });

    return skylark.attach("domx.noder" , noder);
});
define('skylark-domx-styler/styler',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark, langx) {
    var every = Array.prototype.every,
        forEach = Array.prototype.forEach,
        camelCase = langx.camelCase,
        dasherize = langx.dasherize;

    function maybeAddPx(name, value) {
        return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
    }

    var cssNumber = {
            'column-count': 1,
            'columns': 1,
            'font-weight': 1,
            'line-height': 1,
            'opacity': 1,
            'z-index': 1,
            'zoom': 1
        },
        classReCache = {

        };

    function classRE(name) {
        return name in classReCache ?
            classReCache[name] : (classReCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'));
    }

    // access className property while respecting SVGAnimatedString
    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} value
     */
    function className(node, value) {
        var klass = node.className || '',
            svg = klass && klass.baseVal !== undefined

        if (value === undefined) return svg ? klass.baseVal : klass
        svg ? (klass.baseVal = value) : (node.className = value)
    }

    function disabled(elm, value ) {
        if (arguments.length < 2) {
            return !!this.dom.disabled;
        }

        elm.disabled = value;

        return this;
    }

    var elementDisplay = {};

    function defaultDisplay(nodeName) {
        var element, display
        if (!elementDisplay[nodeName]) {
            element = document.createElement(nodeName)
            document.body.appendChild(element)
            display = getStyles(element).getPropertyValue("display")
            element.parentNode.removeChild(element)
            display == "none" && (display = "block")
            elementDisplay[nodeName] = display
        }
        return elementDisplay[nodeName]
    }
    /*
     * Display the matched elements.
     * @param {HTMLElement} elm
     */
    function show(elm) {
        styler.css(elm, "display", "");
        if (styler.css(elm, "display") == "none") {
            styler.css(elm, "display", defaultDisplay(elm.nodeName));
        }
        return this;
    }

    function isInvisible(elm) {
        return styler.css(elm, "display") == "none" || styler.css(elm, "opacity") == 0 || styler.css(elm,"visibility") == "hidden";
    }

    /*
     * Hide the matched elements.
     * @param {HTMLElement} elm
     */
    function hide(elm) {
        styler.css(elm, "display", "none");
        return this;
    }

    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function addClass(elm, name) {
        if (!name) return this
        var cls = className(elm),
            names;
        if (langx.isString(name)) {
            names = name.split(/\s+/g);
        } else {
            names = name;
        }
        names.forEach(function(klass) {
            var re = classRE(klass);
            if (!cls.match(re)) {
                cls += (cls ? " " : "") + klass;
            }
        });

        className(elm, cls);

        return this;
    }

    function getStyles( elem ) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if ( !view || !view.opener ) {
            view = window;
        }

        return view.getComputedStyle( elem);
    }


    /*
     * Get the value of a computed style property for the first element in the set of matched elements or set one or more CSS properties for every matched element.
     * @param {HTMLElement} elm
     * @param {String} property
     * @param {Any} value
     */
    function css(elm, property, value) {
        //if (arguments.length < 3) {
        if (value == void 0) {
            var computedStyle,
                computedStyle = getStyles(elm)
            if (property == void 0) {
                return computedStyle;
            } else if (langx.isString(property)) {
                return elm.style[camelCase(property)] || computedStyle.getPropertyValue(dasherize(property))
            } else if (langx.isArrayLike(property)) {
                var props = {}
                forEach.call(property, function(prop) {
                    props[prop] = (elm.style[camelCase(prop)] || computedStyle.getPropertyValue(dasherize(prop)))
                })
                return props
            }
        }

        var css = '';
        if (typeof(property) == 'string') {
            if (!value && value !== 0) {
                elm.style.removeProperty(dasherize(property));
            } else {
                css = dasherize(property) + ":" + maybeAddPx(property, value)
            }
        } else {
            for (key in property) {
                if (property[key] === undefined) {
                    continue;
                }
                if (!property[key] && property[key] !== 0) {
                    elm.style.removeProperty(dasherize(key));
                } else {
                    css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
                }
            }
        }

        elm.style.cssText += ';' + css;
        return this;
    }

    /*
     * Determine whether any of the matched elements are assigned the given class.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function hasClass(elm, name) {
        var re = classRE(name);
        return elm.className && elm.className.match(re);
    }

    /*
     * Remove a single class, multiple classes, or all classes from each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function removeClass(elm, name) {
        if (name) {
            var cls = className(elm),
                names;

            if (langx.isString(name)) {
                names = name.split(/\s+/g);
            } else {
                names = name;
            }

            names.forEach(function(klass) {
                var re = classRE(klass);
                if (cls.match(re)) {
                    cls = cls.replace(re, " ");
                }
            });

            className(elm, cls.trim());
        } else {
            className(elm, "");
        }

        return this;
    }

    /*
     * Add or remove one or more classes from the specified element.
     * @param {HTMLElement} elm
     * @param {String} name
     * @param {} when
     */
    function toggleClass(elm, name, when) {
        var self = this;
        name.split(/\s+/g).forEach(function(klass) {
            if (when === undefined) {
                when = !hasClass(elm, klass);
            }
            if (when) {
                addClass(elm, klass);
            } else {
                removeClass(elm, klass)
            }
        });

        return self;
    }

    var styler = function() {
        return styler;
    };

    langx.mixin(styler, {
        autocssfix: false,
        cssHooks: {

        },

        addClass: addClass,
        className: className,
        css: css,
        disabled : disabled,        
        hasClass: hasClass,
        hide: hide,
        isInvisible: isInvisible,
        removeClass: removeClass,
        show: show,
        toggleClass: toggleClass
    });

    return skylark.attach("domx.styler", styler);
});
define('skylark-domx-styler/main',[
	"./styler"
],function(styler,velm,$){
	
	return styler;
});
define('skylark-domx-styler', ['skylark-domx-styler/main'], function (main) { return main; });

define('skylark-domx-noder/overlay',[
	"skylark-domx-styler",
	"./noder"
],function(styler,noder){
    /*   
     *
     * @param {Node} elm
     * @param {Node} params
     */
    function overlay(elm, params) {
        var overlayDiv = noder.createElement("div", params);
        styler.css(overlayDiv, {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            zIndex: 0x7FFFFFFF,
            opacity: 0.7
        });
        elm.appendChild(overlayDiv);
        return overlayDiv;

    }

    return noder.overlay = overlay;
 });
define('skylark-domx-noder/throb',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./noder"
],function(langx,styler,noder) {

    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};

        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "class": params.className || "throbber"
            }),
            //_overlay = overlay(throbber, {
            //    "class": 'overlay fade'
            //}),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };

        if (params.style) {
            styler.css(throbber,params.style);
        }

        //throb = noder.createElement("div", {
        //   "class": params.throb && params.throb.className || "throb"
        //}),
        //textNode = noder.createTextNode(text || ""),
 
        var content = params.content ||  '<span class="throb"></span>';

        //throb.appendChild(textNode);
        //throbber.appendChild(throb);

        noder.html(throbber,content);
        
        elm.appendChild(throbber);

        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            throbber : throbber,
            remove: remove,
            update: update
        };
    }

    return noder.throb = throb;
});
define('skylark-domx-noder/main',[
	"./noder",
	"./overlay",
	"./throb"
],function(noder){
	return noder;
});
define('skylark-domx-noder', ['skylark-domx-noder/main'], function (main) { return main; });

define('skylark-domx-css/css',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder"
], function(skylark, langx, noder) {
    "use strict";

    var head = document.getElementsByTagName("head")[0],
        count = 0,
        sheetsByUrl = {},
        sheetsById = {},
        defaultSheetId = _createStyleSheet(),
        defaultSheet = sheetsById[defaultSheetId],
        rulesPropName = ("cssRules" in defaultSheet) ? "cssRules" : "rules",
        insertRuleFunc,
        deleteRuleFunc = defaultSheet.deleteRule || defaultSheet.removeRule;

    if (defaultSheet.insertRule) {
        var _insertRule = defaultSheet.insertRule;
        insertRuleFunc = function(selector, css, index) {
            _insertRule.call(this, selector + "{" + css + "}", index);
        };
    } else {
        insertRuleFunc = defaultSheet.addRule;
    }

    function normalizeSelector(selectorText) {
        var selector = [],
            last, len;
        last = defaultSheet[rulesPropName].length;
        insertRuleFunc.call(defaultSheet, selectorText, ';');
        len = defaultSheet[rulesPropName].length;
        for (var i = len - 1; i >= last; i--) {
            selector.push(_sheet[_rules][i].selectorText);
            deleteRuleFunc.call(defaultSheet, i);
        }
        return selector.reverse().join(', ');
    }

    /*
     * create a stylesheet element.
     * @param {Boolean} external
     * @param {Object} options
     * @param {String} [options.media = null]
     */
    function _createStyleSheet(external,options ) {
        var node,
            props = {
                type : "text/css"
            },
            id = (count++);

        options = options || {};
        if (options.media) {
            props.media = options.media;
        }

        if (external) {
            node = noder.create("link",langx.mixin(props,{
                rel  : "stylesheet",
                async : false
            }));
        } else {
            node = noder.createElement("style",props);
        }

        noder.append(head,node);
        sheetsById[id] = {
            id : id,
            node :node
        };

        return id;
    }

    function createStyleSheet(css,options) {
        if (!options) {
            options = {};
        }
        var sheetId = _createStyleSheet(false,options);
        if (css) {
            addSheetRules(sheetId,css);
        }

        return sheetId;
    }

    function loadStyleSheet(url, options,loadedCallback, errorCallback) {
        if (langx.isFunction(options)) {
            errorCallback = loadedCallback;
            loadedCallback = options;
            options = {};
        }
        var sheet = sheetsByUrl[url];
        if (!sheet) {
            var sheetId = _createStyleSheet(true,options);

            sheet = sheetsByUrl[url] = sheetsById[sheetId];
            langx.mixin(sheet,{
                state: 0, //0:unload,1:loaded,-1:loaderror
                url : url,
                deferred : new langx.Deferred()
            });

            var node = sheet.node;

            startTime = new Date().getTime();

            node.onload = function() {
                sheet.state = 1;
                sheet.deferred.resolve(sheet.id);
            },
            node.onerror = function(e) {
                sheet.state = -1;
                sheet.deferred.reject(e);
            };

            node.href = sheet.url;
        }
        if (loadedCallback || errorCallback) {
            sheet.deferred.promise.then(loadedCallback,errorCallback);
        }
        return sheet.id;
    }

    function deleteSheetRule(sheetId, rule) {
        var sheet = sheetsById[sheetId];
        if (langx.isNumber(rule)) {
            deleteRuleFunc.call(sheet, rule);
        } else {
            langx.each(sheet[rulesPropName], function(i, _rule) {
                if (rule === _rule) {
                    deleteRuleFunc.call(sheet, i);
                    return false;
                }
            });
        }
        return this;
    }

    function deleteRule(rule) {
        deleteSheetRule(defaultSheetId, rule);
        return this;
    }

    function removeStyleSheet(sheetId) {
        if (sheetId === defaultSheetId) {
            throw new Error("The default stylesheet can not be deleted");
        }
        var sheet = sheetsById[sheetId];
        delete sheetsById[sheetId];

        noder.remove(sheet.node);
        return this;
    }

    /*
     * insert a rule to the default stylesheet.
     * @param {String} selector
     * @param {String} css
     * @param {Number} index 
     */
    function insertRule(selector, css, index) {
        return this.insertSheetRule(defaultSheetId, selector, css, index);
    }

    /*
     * Add rules to the default stylesheet.
     * @param {Object} rules
     */
    function addRules(rules) {
        return this.addRules(defaultSheetId,rules);
    }

    /*
     * insert a rule to the stylesheet specified by sheetId.
     * @param {Number} sheetId  
     * @param {String} selector
     * @param {String} css
     * @param {Number} index 
     */
    function insertSheetRule(sheetId, selector, css, index) {
        if (!selector || !css) {
            return -1;
        }

        var sheet = sheetsById[sheetId];
        index = index || sheet[rulesPropName].length;

        return insertRuleFunc.call(sheet, selector, css, index);
    }

    /*
     * Add  rules to stylesheet.
     * @param {Number} sheetId  
     * @param {Object|String} rules
     * @return this
     * @example insertSheetRules(sheetId,{
     * 
     * });
     */
    function addSheetRules(sheetId,rules) {
        var sheet = sheetsById[sheetId],
            css;
        if (langx.isString(rules)) {
            css = rules;
        } else {
            css = toString(rules);
        }

        noder.append(sheet.node,noder.createTextNode(css));
        
        return this;
    }

    function isAtRule(str) {
        return str.startsWith("@");
    }

    function toString(json){
        var adjust = function(parentName,name,depth) {
            if (parentName) {
                if (isAtRule(parentName)) {
                    depth += 1;
                } else {
                    name =  parentName + " " + name;
                }                
            }
            return {
                name : name,
                depth : depth
            }
        };

        var strNode = function (name, values, depth) {
            var str = "",
                atFlg = isAtRule(name);


            if (isAtRule(name)) {
                // at rule
                if (langx.isString(values)) {
                    // an at rule without block
                    // ex: (1) @charset 'utf8';
                    str = css.SPACE.repeat(depth) + name.trim() + " \"" + values.trim() + " \";\n";
                } else {
                    // an at rule with block, ex :
                    //  @media 'screen' {
                    //  }
                    str += css.SPACE.repeat(depth) + name.trim() + " {\n";
                    str += strNode("",values,depth+1);
                    str += css.SPACE.repeat(depth) + " }\n";
                }
            } else {
                // a selector or a property
                if (langx.isString(values)) {
                    // a css property 
                    // ex : (1) font-color : red;
                    str = css.SPACE.repeat(depth) + name.trim() ;
                    if (atFlg) {
                        str = str +  " \"" + values.trim() + " \";\n";
                    } else {
                        str = str + ': ' + values.trim() + ";\n";
                    }

                } else {
                    // a selector rule 
                    // ex : (1) .class1 : {
                    //            font-color : red;
                    //          }
                    if (langx.isArray(values)) {
                        // array for ordering
                        for (var n =0; n<values.length; n ++) {
                           str +=  strNode(name,values[n],depth);
                        }
                    } else {
                        // plain object

                        if (name) {
                            str += css.SPACE.repeat(depth) + name.trim() + " {\n";

                            for (var n in values) {
                                var value =values[n];
                                if (langx.isString(value)) {
                                    // css property
                                    str += strNode(n,value,depth+1)
                                }
                            }

                            str += css.SPACE.repeat(depth) + "}\n";
                        }

                        for (var n in values) {
                            var value =values[n];
                            if (!langx.isString(value)) {
                                var adjusted = adjust(name,n,depth);
                                str +=  strNode(adjusted.name,value,adjusted.depth);
                            } 
                        }

                    }
                }
            }   

            return str;
        };


        return strNode("",json,0);
    }
 

    function css() {
        return css;
    }

    langx.mixin(css, {
        SPACE : "\t",

        addRules : addRules,

        addSheetRules : addSheetRules,

        createStyleSheet: createStyleSheet,

        deleteSheetRule : deleteSheetRule,

        deleteRule : deleteRule,

        insertRule : insertRule,

        insertSheetRule : insertSheetRule,

        loadStyleSheet : loadStyleSheet,

        removeStyleSheet : removeStyleSheet,

        toString : toString
    });

    return skylark.attach("domx.css", css);
});

define('skylark-domx-css/main',[
	"./css"
],function(css){
	return css;
});
define('skylark-domx-css', ['skylark-domx-css/main'], function (main) { return main; });

define('skylark-domx/css',[
    "skylark-domx-css"
], function( css) {
    "use strict";

     return css;
});

define('skylark-domx-finder/finder',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-styler"
], function(skylark, langx, browser, noder,styler) {
    var local = {},
        filter = Array.prototype.filter,
        slice = Array.prototype.slice,
        nativeMatchesSelector = browser.matchesSelector;

    /*
    ---
    name: Slick.Parser
    description: Standalone CSS3 Selector parser
    provides: Slick.Parser
    ...
    */
    ;
    (function() {

        var parsed,
            separatorIndex,
            combinatorIndex,
            reversed,
            cache = {},
            reverseCache = {},
            reUnescape = /\\/g;

        var parse = function(expression, isReversed) {
            if (expression == null) return null;
            if (expression.Slick === true) return expression;
            expression = ('' + expression).replace(/^\s+|\s+$/g, '');
            reversed = !!isReversed;
            var currentCache = (reversed) ? reverseCache : cache;
            if (currentCache[expression]) return currentCache[expression];
            parsed = {
                Slick: true,
                expressions: [],
                raw: expression,
                reverse: function() {
                    return parse(this.raw, true);
                }
            };
            separatorIndex = -1;
            while (expression != (expression = expression.replace(regexp, parser)));
            parsed.length = parsed.expressions.length;
            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;
        };

        var reverseCombinator = function(combinator) {
            if (combinator === '!') return ' ';
            else if (combinator === ' ') return '!';
            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');
            else return '!' + combinator;
        };

        var reverse = function(expression) {
            var expressions = expression.expressions;
            for (var i = 0; i < expressions.length; i++) {
                var exp = expressions[i];
                var last = {
                    parts: [],
                    tag: '*',
                    combinator: reverseCombinator(exp[0].combinator)
                };

                for (var j = 0; j < exp.length; j++) {
                    var cexp = exp[j];
                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
                    cexp.combinator = cexp.reverseCombinator;
                    delete cexp.reverseCombinator;
                }

                exp.reverse().push(last);
            }
            return expression;
        };

        var escapeRegExp = (function() {
            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
            var from = /(?=[\-\[\]{}()*+?.\\\^$|,#\s])/g,
                to = '\\';
            return function(string) {
                return string.replace(from, to)
            }
        }())

        var regexp = new RegExp(
            "^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
            .replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']')
            .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
            .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
        );

        function parser(
            rawMatch,

            separator,
            combinator,
            combinatorChildren,

            tagName,
            id,
            className,

            attributeKey,
            attributeOperator,
            attributeQuote,
            attributeValue,

            pseudoMarker,
            pseudoClass,
            pseudoQuote,
            pseudoClassQuotedValue,
            pseudoClassValue
        ) {
            if (separator || separatorIndex === -1) {
                parsed.expressions[++separatorIndex] = [];
                combinatorIndex = -1;
                if (separator) return '';
            }

            if (combinator || combinatorChildren || combinatorIndex === -1) {
                combinator = combinator || ' ';
                var currentSeparator = parsed.expressions[separatorIndex];
                if (reversed && currentSeparator[combinatorIndex])
                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
                currentSeparator[++combinatorIndex] = {
                    combinator: combinator,
                    tag: '*'
                };
            }

            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];

            if (tagName) {
                currentParsed.tag = tagName.replace(reUnescape, '');

            } else if (id) {
                currentParsed.id = id.replace(reUnescape, '');

            } else if (className) {
                className = className.replace(reUnescape, '');

                if (!currentParsed.classList) currentParsed.classList = [];
                if (!currentParsed.classes) currentParsed.classes = [];
                currentParsed.classList.push(className);
                currentParsed.classes.push({
                    value: className,
                    regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
                });

            } else if (pseudoClass) {
                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;

                if (!currentParsed.pseudos) currentParsed.pseudos = [];
                currentParsed.pseudos.push({
                    key: pseudoClass.replace(reUnescape, ''),
                    value: pseudoClassValue,
                    type: pseudoMarker.length == 1 ? 'class' : 'element'
                });

            } else if (attributeKey) {
                attributeKey = attributeKey.replace(reUnescape, '');
                attributeValue = (attributeValue || '').replace(reUnescape, '');

                var test, regexp;

                switch (attributeOperator) {
                    case '^=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue));
                        break;
                    case '$=':
                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');
                        break;
                    case '~=':
                        regexp = new RegExp('(^|\\s)' + escapeRegExp(attributeValue) + '(\\s|$)');
                        break;
                    case '|=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');
                        break;
                    case '=':
                        test = function(value) {
                            return attributeValue == value;
                        };
                        break;
                    case '*=':
                        test = function(value) {
                            return value && value.indexOf(attributeValue) > -1;
                        };
                        break;
                    case '!=':
                        test = function(value) {
                            return attributeValue != value;
                        };
                        break;
                    default:
                        test = function(value) {
                            return !!value;
                        };
                }

                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {
                    return false;
                };

                if (!test) test = function(value) {
                    return value && regexp.test(value);
                };

                if (!currentParsed.attributes) currentParsed.attributes = [];
                currentParsed.attributes.push({
                    key: attributeKey,
                    operator: attributeOperator,
                    value: attributeValue,
                    test: test
                });

            }

            return '';
        };

        // Slick NS

        var Slick = (this.Slick || {});

        Slick.parse = function(expression) {
            return parse(expression);
        };

        Slick.escapeRegExp = escapeRegExp;

        if (!this.Slick) this.Slick = Slick;

    }).apply(local);


    var simpleClassSelectorRE = /^\.([\w-]*)$/,
        simpleIdSelectorRE = /^#([\w-]*)$/,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        slice = Array.prototype.slice;


    local.parseSelector = local.Slick.parse;


    var pseudos = local.pseudos = {
        // custom pseudos
        "button": function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        'checked': function(elm) {
            return !!elm.checked;
        },

        'contains': function(elm, idx, nodes, text) {
            if ($(this).text().indexOf(text) > -1) return this
        },

        'disabled': function(elm) {
            return !!elm.disabled;
        },

        'enabled': function(elm) {
            return !elm.disabled;
        },

        'eq': function(elm, idx, nodes, value) {
            return (idx == value);
        },

        'even': function(elm, idx, nodes, value) {
            return (idx % 2) === 0;
        },

        'focus': function(elm) {
            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);
        },

        'focusable': function( elm ) {
            return noder.focusable(elm, elm.tabindex != null );
        },

        'first': function(elm, idx) {
            return (idx === 0);
        },

        'gt': function(elm, idx, nodes, value) {
            return (idx > value);
        },

        'has': function(elm, idx, nodes, sel) {
            return find(elm, sel);
        },

        // Element/input types
        "header": function(elem) {
            return rheader.test(elem.nodeName);
        },

        'hidden': function(elm) {
            return !local.pseudos["visible"](elm);
        },

        "input": function(elem) {
            return rinputs.test(elem.nodeName);
        },

        'last': function(elm, idx, nodes) {
            return (idx === nodes.length - 1);
        },

        'lt': function(elm, idx, nodes, value) {
            return (idx < value);
        },

        'not': function(elm, idx, nodes, sel) {
            return !matches(elm, sel);
        },

        'odd': function(elm, idx, nodes, value) {
            return (idx % 2) === 1;
        },

        /*   
         * Get the parent of each element in the current set of matched elements.
         * @param {Object} elm
         */
        'parent': function(elm) {
            return !!elm.parentElement;
        },

        'selected': function(elm) {
            return !!elm.selected;
        },

        'tabbable': function(elm) {
            var tabIndex = elm.tabindex,
                hasTabindex = tabIndex != null;
            return ( !hasTabindex || tabIndex >= 0 ) && noder.focusable( element, hasTabindex );
        },

        'text': function(elm) {
            return elm.type === "text";
        },

        'visible': function(elm) {
            return elm.offsetWidth && elm.offsetWidth
        },
        'empty': function(elm) {
            return !elm.hasChildNodes();
        }
    };

    ["first", "eq", "last"].forEach(function(item) {
        pseudos[item].isArrayFilter = true;
    });



    pseudos["nth"] = pseudos["eq"];

    function createInputPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
        };
    }

    function createButtonPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
        };
    }

    // Add button/input type pseudos
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
    }) {
        pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
    }) {
        pseudos[i] = createButtonPseudo(i);
    }


    local.divide = function(cond) {
        var nativeSelector = "",
            customPseudos = [],
            tag,
            id,
            classes,
            attributes,
            pseudos;


        if (id = cond.id) {
            nativeSelector += ("#" + id);
        }
        if (classes = cond.classes) {
            for (var i = classes.length; i--;) {
                nativeSelector += ("." + classes[i].value);
            }
        }
        if (attributes = cond.attributes) {
            for (var i = 0; i < attributes.length; i++) {
                if (attributes[i].operator) {
                    nativeSelector += ("[" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value) + "]");
                } else {
                    nativeSelector += ("[" + attributes[i].key + "]");
                }
            }
        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (this.pseudos[part.key]) {
                    customPseudos.push(part);
                } else {
                    if (part.value !== undefined) {
                        nativeSelector += (":" + part.key + "(" + JSON.stringify(part))
                    }
                }
            }
        }

        if (tag = cond.tag) {
            if (tag !== "*") {
                nativeSelector = tag.toUpperCase() + nativeSelector;
            }
        }

        if (!nativeSelector) {
            nativeSelector = "*";
        }

        return {
            nativeSelector: nativeSelector,
            customPseudos: customPseudos
        }

    };

    local.check = function(node, cond, idx, nodes, arrayFilte) {
        var tag,
            id,
            classes,
            attributes,
            pseudos,

            i, part, cls, pseudo;

        if (!arrayFilte) {
            if (tag = cond.tag) {
                var nodeName = node.nodeName.toUpperCase();
                if (tag == '*') {
                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes
                } else {
                    if (nodeName != (tag || "").toUpperCase()) return false;
                }
            }

            if (id = cond.id) {
                if (node.getAttribute('id') != id) {
                    return false;
                }
            }


            if (classes = cond.classes) {
                for (i = classes.length; i--;) {
                    cls = node.getAttribute('class');
                    if (!(cls && classes[i].regexp.test(cls))) return false;
                }
            }

            if (attributes = cond.attributes) {
                for (i = attributes.length; i--;) {
                    part = attributes[i];
                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;
                }
            }

        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (pseudo = this.pseudos[part.key]) {
                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {
                        if (!pseudo(node, idx, nodes, part.value)) {
                            return false;
                        }
                    }
                } else {
                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    local.match = function(node, selector) {

        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            parsed = selector;
        }

        if (!parsed) {
            return true;
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            simpleExpCounter = 0,
            i,
            currentExpression;
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];
                if (this.check(node, exp)) {
                    return true;
                }
                simpleExpCounter++;
            }
        }

        if (simpleExpCounter == parsed.length) {
            return false;
        }

        var nodes = this.query(document, parsed),
            item;
        for (i = 0; item = nodes[i++];) {
            if (item === node) {
                return true;
            }
        }
        return false;
    };


    local.filterSingle = function(nodes, exp) {
        var matchs = filter.call(nodes, function(node, idx) {
            return local.check(node, exp, idx, nodes, false);
        });

        matchs = filter.call(matchs, function(node, idx) {
            return local.check(node, exp, idx, matchs, true);
        });
        return matchs;
    };

    local.filter = function(nodes, selector) {
        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            return local.filterSingle(nodes, selector);
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            i,
            currentExpression,
            ret = [];
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];

                var matchs = local.filterSingle(nodes, exp);

                ret = langx.uniq(ret.concat(matchs));
            } else {
                throw new Error("not supported selector:" + selector);
            }
        }

        return ret;

    };

    local.combine = function(elm, bit) {
        var op = bit.combinator,
            cond = bit,
            node1,
            nodes = [];

        switch (op) {
            case '>': // direct children
                nodes = children(elm, cond);
                break;
            case '+': // next sibling
                node1 = nextSibling(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '^': // first child
                node1 = firstChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '~': // next siblings
                nodes = nextSiblings(elm, cond);
                break;
            case '++': // next sibling and previous sibling
                var prev = previousSibling(elm, cond, true),
                    next = nextSibling(elm, cond, true);
                if (prev) {
                    nodes.push(prev);
                }
                if (next) {
                    nodes.push(next);
                }
                break;
            case '~~': // next siblings and previous siblings
                nodes = siblings(elm, cond);
                break;
            case '!': // all parent nodes up to document
                nodes = ancestors(elm, cond);
                break;
            case '!>': // direct parent (one level)
                node1 = parent(elm, cond);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!+': // previous sibling
                nodes = previousSibling(elm, cond, true);
                break;
            case '!^': // last child
                node1 = lastChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!~': // previous siblings
                nodes = previousSiblings(elm, cond);
                break;
            default:
                var divided = this.divide(bit);
                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));
                if (divided.customPseudos) {
                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {
                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, false)
                        });

                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, true)
                        });
                    }
                }
                break;

        }
        return nodes;
    }

    local.query = function(node, selector, single) {


        var parsed = this.Slick.parse(selector);

        var
            founds = [],
            currentExpression, currentBit,
            expressions = parsed.expressions;

        for (var i = 0;
            (currentExpression = expressions[i]); i++) {
            var currentItems = [node],
                found;
            for (var j = 0;
                (currentBit = currentExpression[j]); j++) {
                found = langx.map(currentItems, function(item, i) {
                    return local.combine(item, currentBit)
                });
                if (found) {
                    currentItems = found;
                }
            }
            if (found) {
                founds = founds.concat(found);
            }
        }

        return founds;
    }

    /*
     * Get the nearest ancestor of the specified element,optional matched by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestor(node, selector, root) {
        var rootIsSelector = root && langx.isString(root);
        while (node = node.parentElement) {
            if (matches(node, selector)) {
                return node;
            }
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
        }
        return null;
    }

    /*
     * Get the ancestors of the specitied element , optionally filtered by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestors(node, selector, root) {
        var ret = [],
            rootIsSelector = root && langx.isString(root);
        while ((node = node.parentElement) && (node.nodeType !== 9)) {
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (langx.isArrayLike(root)) {
                    if (langx.inArray(node,root)>-1) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
            if (!selector || matches(node, selector)) {
              ret.push(node); 
            }
        }

        //if (selector) {
        //    ret = local.filter(ret, selector);
        //}
        return ret;
    }


    /*
     * Returns a element by its ID.
     * @param {string} id
     */
    function byId(id, doc) {
        doc = doc || noder.doc();
        return doc.getElementById(id);
    }

    /*
     * Get the children of the specified element , optionally filtered by a selector.
     * @param {string} node
     * @param {String optionlly} selector
     */
    function children(node, selector) {
        var childNodes = node.childNodes,
            ret = [];
        for (var i = 0; i < childNodes.length; i++) {
            var node = childNodes[i];
            if (node.nodeType == 1) {
                ret.push(node);
            }
        }
        if (selector) {
            ret = local.filter(ret, selector);
        }
        return ret;
    }



    /**
     * Gets nth child of elm, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
     * and non-draggable elements
     * @param  {HTMLElement} elm       The parent element
     * @param  {Number} idx      The index of the child
     * @param  {Object} options       Parent's options
     * @return {HTMLElement}          The child at index idx, or null if not found
     */
    function childAt(elm, idx, options) {
        var currentChild = 0,
            children = elm.children;

        options = langx.mixin({
            ignoreHidden : true,
            excluding : null,
            closesting : null
        },options);

        for(var i=0;i < children.length;i++) {
            var child = children[i];
            if (options.ignoreHidden && styler.css(child) === "none") {
                continue;
            }
            if (options.excluding && options.excluding.includes(child)) {
                continue;
            }

            if (options.closesting &&  !closest(child, options.closesting, elm, false)) {
                continue;
            }

            if (currentChild === idx) {
                return child;
            }
            currentChild++;
        }
        return null;
    }



    //function closest(node, selector) {
    //    while (node && !(matches(node, selector))) {
    //        node = node.parentElement;
    //    }
    //   return node;
    //}


    function closest(/**HTMLElement*/elm, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
        if (elm) {
            ctx = ctx || document;

            do {
                if (
                    selector != null &&
                    (
                        selector[0] === '>' ?
                        elm.parentElement === ctx && matches(elm, selector) :
                        matches(elm, selector)
                    ) ||
                    includeCTX && elm === ctx
                ) {
                    return elm;
                }

                if (elm === ctx) break;
                /* jshint boss:true */
            } while (elm = parent(elm));
        }

        return null;
    }
    /*
     * Get the decendant of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendants(elm, selector) {
        // Selector
        try {
            return slice.call(elm.querySelectorAll(selector));
        } catch (matchError) {
            //console.log(matchError);
        }
        return local.query(elm, selector);
    }

    /*
     * Get the nearest decendent of the specified element,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendant(elm, selector) {
        // Selector
        try {
            return elm.querySelector(selector);
        } catch (matchError) {
            //console.log(matchError);
        }
        var nodes = local.query(elm, selector);
        if (nodes.length > 0) {
            return nodes[0];
        } else {
            return null;
        }
    }

    /*
     * Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function find(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        if (matches(elm, selector)) {
            return elm;
        } else {
            return descendant(elm, selector);
        }
    }

    /*
     * Get the findAll of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function findAll(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        return descendants(elm, selector);
    }

    /*
     * Get the first child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String} first
     */
    function firstChild(elm, selector, first) {
        var childNodes = elm.childNodes,
            node = childNodes[0];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (first) {
                    break;
                }
            }
            node = node.nextSibling;
        }

        return null;
    }


    /**
     * Returns the index of an element within its parent for a selected set of
     * elements
     * @param  {HTMLElement} el
     * @param  {selector} selector
     * @return {number}
     */
    function index(el, selector) {
        var index = 0;

        if (!el || !el.parentNode) {
            return -1;
        }

        while (el && (el = el.previousElementSibling)) {
            if (langx.isString(selector)) {
                if (matches(el, selector)) {
                    index++;
                }
            } else if (langx.isFunction(selector)) {
                if (selector(el)) {
                    index++;
                }
            }
            index++;
        }

        return index;
    }    

    /*
     * Get the last child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String } last
     */
    function lastChild(elm, selector, last) {
        var childNodes = elm.childNodes,
            node = childNodes[childNodes.length - 1];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (last) {
                    break;
                }
            }
            node = node.previousSibling;
        }

        return null;
    }

    /*
     * Check the specified element against a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function matches(elm, selector) {
        if (!selector || !elm || elm.nodeType !== 1) {
            return false
        }

        if (langx.isString(selector)) {
            try {
                return nativeMatchesSelector.call(elm, selector.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]'));
            } catch (matchError) {
                //console.log(matchError);
            }
            return local.match(elm, selector);
        } else if (langx.isArrayLike(selector)) {
            return langx.inArray(elm, selector) > -1;
        } else if (langx.isPlainObject(selector)) {
            return local.check(elm, selector);
        } else {
            return elm === selector;
        }

    }

    /*
     * Get the nearest next sibing of the specitied element , optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional} adjacent
     */
    function nextSibling(elm, selector, adjacent) {
        var node = elm.nextSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.nextSibling;
        }
        return null;
    }

    /*
     * Get the next siblings of the specified element , optional filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function nextSiblings(elm, selector) {
        var node = elm.nextSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    /*
     * Get the parent element of the specified element. if a selector is provided, it retrieves the parent element only if it matches that selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function parent(elm, selector) {
        var node = (elm.host && elm !== document && elm.host.nodeType) ? elm.host : elm.parentElement;

        if (node && (!selector || matches(node, selector))) {
            return node;
        }

        return null;
    }

    /*
     * Get hte nearest previous sibling of the specified element ,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional } adjacent
     */
    function previousSibling(elm, selector, adjacent) {
        var node = elm.previousSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.previousSibling;
        }
        return null;
    }

    /*
     * Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function previousSiblings(elm, selector) {
        var node = elm.previousSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.previousSibling;
        }
        return ret;
    }

    /*
     * Selects all sibling elements that follow after the prev element, have the same parent, and match the filtering siblings selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function siblings(elm, selector) {
        var node = elm.parentElement.firstChild,
            ret = [];
        while (node) {
            if (node.nodeType == 1 && node !== elm) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    var finder = function() {
        return finder;
    };

    langx.mixin(finder, {

        ancestor: ancestor,

        ancestors: ancestors,

        byId: byId,

        childAt: childAt,

        children: children,

        closest: closest,

        descendant: descendant,

        descendants: descendants,

        find: find,

        findAll: findAll,

        firstChild: firstChild,

        index,

        lastChild: lastChild,

        matches: matches,

        nextSibling: nextSibling,

        nextSiblings: nextSiblings,

        parent: parent,

        previousSibling,

        previousSiblings,

        pseudos: local.pseudos,

        siblings: siblings
    });

    return skylark.attach("domx.finder", finder);
});
define('skylark-domx-finder/main',[
	"./finder"
],function(finder){

	return finder;
});
define('skylark-domx-finder', ['skylark-domx-finder/main'], function (main) { return main; });

define('skylark-domx-data/data',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-finder",
    "skylark-domx-noder"
], function(skylark, langx, finder,noder) {
    var map = Array.prototype.map,
        filter = Array.prototype.filter,
        camelCase = langx.camelCase,
        deserializeValue = langx.deserializeValue,

        capitalRE = /([A-Z])/g,
        propMap = {
            'tabindex': 'tabIndex',
            'readonly': 'readOnly',
            'for': 'htmlFor',
            'class': 'className',
            'maxlength': 'maxLength',
            'cellspacing': 'cellSpacing',
            'cellpadding': 'cellPadding',
            'rowspan': 'rowSpan',
            'colspan': 'colSpan',
            'usemap': 'useMap',
            'frameborder': 'frameBorder',
            'contenteditable': 'contentEditable'
        };

    // Strip and collapse whitespace according to HTML spec
    function stripAndCollapse( value ) {
      var tokens = value.match( /[^\x20\t\r\n\f]+/g ) || [];
      return tokens.join( " " );
    }


    var valHooks = {
      option: {
        get: function( elem ) {
          var val = elem.getAttribute( "value" );
          return val != null ?  val :  stripAndCollapse(text( elem ) );
        }
      },
      select: {
        get: function( elem ) {
          var value, option, i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;

          if ( index < 0 ) {
            i = max;

          } else {
            i = one ? index : 0;
          }

          // Loop through all the selected options
          for ( ; i < max; i++ ) {
            option = options[ i ];

            if ( option.selected &&

                // Don't return options that are disabled or in a disabled optgroup
                !option.disabled &&
                ( !option.parentNode.disabled ||
                  !noder.nodeName( option.parentNode, "optgroup" ) ) ) {

              // Get the specific value for the option
              value = val(option);

              // We don't need an array for one selects
              if ( one ) {
                return value;
              }

              // Multi-Selects return an array
              values.push( value );
            }
          }

          return values;
        },

        set: function( elem, value ) {
          var optionSet, option,
            options = elem.options,
            values = langx.makeArray( value ),
            i = options.length;

          while ( i-- ) {
            option = options[ i ];

            /* eslint-disable no-cond-assign */

            if ( option.selected =
              langx.inArray( valHooks.option.get( option ), values ) > -1
            ) {
              optionSet = true;
            }

            /* eslint-enable no-cond-assign */
          }

          // Force browsers to behave consistently when non-matching value is set
          if ( !optionSet ) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    };


    // Radios and checkboxes getter/setter
    langx.each( [ "radio", "checkbox" ], function() {
      valHooks[ this ] = {
        set: function( elem, value ) {
          if ( langx.isArray( value ) ) {
            return ( elem.checked = langx.inArray( val(elem), value ) > -1 );
          }
        }
      };
    });



    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function setAttribute(elm, name, value) {
        if (value == null) {
            elm.removeAttribute(name);
        } else {
            elm.setAttribute(name, value);
        }
    }

    function aria(elm, name, value) {
        return this.attr(elm, "aria-" + name, value);
    }

    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function attr(elm, name, value) {
        if (value === undefined) {
            if (typeof name === "object") {
                for (var attrName in name) {
                    attr(elm, attrName, name[attrName]);
                }
                return this;
            } else {
                return elm.getAttribute ? elm.getAttribute(name) : elm[name];
            }
        } else {
            elm.setAttribute ? elm.setAttribute(name, value) : elm[name] = value;
            return this;
        }
    }


    /*
     *  Read all "data-*" attributes from a node
     * @param {Object} elm  
     */

    function _attributeData(elm) {
        var store = {}
        langx.each(elm.attributes || [], function(i, attr) {
            if (attr.name.indexOf('data-') == 0) {
                store[camelCase(attr.name.replace('data-', ''))] = deserializeValue(attr.value);
            }
        })
        return store;
    }

    function _store(elm, confirm) {
        var store = elm["_$_store"];
        if (!store && confirm) {
            store = elm["_$_store"] = _attributeData(elm);
        }
        return store;
    }

    function _getData(elm, name) {
        if (name === undefined) {
            return _store(elm, true);
        } else {
            var store = _store(elm);
            if (store) {
                if (name in store) {
                    return store[name];
                }
                var camelName = camelCase(name);
                if (camelName in store) {
                    return store[camelName];
                }
            }
            var attrName = 'data-' + name.replace(capitalRE, "-$1").toLowerCase()
            var value = attr(elm, attrName);
            if (!langx.isString(value)) {
              value = undefined;
            }
            return value;
        }

    }

    function _setData(elm, name, value) {
        var store = _store(elm, true);
        store[camelCase(name)] = value;
    }


    /*
     * xxx
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function data(elm, name, value) {

        if (value === undefined) {
            if (typeof name === "object") {
                for (var dataAttrName in name) {
                    _setData(elm, dataAttrName, name[dataAttrName]);
                }
                return this;
            } else {
                return _getData(elm, name);
            }
        } else {
            _setData(elm, name, value);
            return this;
        }
    } 
    /*
     * Remove from the element all items that have not yet been run. 
     * @param {Object} elm  
     */

    function cleanData(elm) {
        if (elm["_$_store"]) {
            delete elm["_$_store"];
        }
    }

    /*
     * Remove a previously-stored piece of data. 
     * @param {Object} elm  
     * @param {Array} names
     */
    function removeData(elm, names) {
        if (names) {
            if (langx.isString(names)) {
                names = names.split(/\s+/);
            }
            var store = _store(elm, true);
            names.forEach(function(name) {
                delete store[name];
            });            
        } else {
            cleanData(elm);
        }
        return this;
    }

    /*
     * xxx 
     * @param {Object} elm  
     * @param {Array} names
     */
    function pluck(nodes, property) {
        return map.call(nodes, function(elm) {
            return elm[property];
        });
    }

    /*
     * Get or set the value of an property for the specified element.
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function prop(elm, name, value) {
        name = propMap[name] || name;
        if (value === undefined) {
            return elm[name];
        } else {
            elm[name] = value;
            return this;
        }
    }

    /*
     * remove Attributes  
     * @param {Object} elm  
     * @param {String} name
     */
    function removeAttr(elm, name) {
        name.split(' ').forEach(function(attr) {
            setAttribute(elm, attr);
        });
        return this;
    }


    /*
     * Remove the value of a property for the first element in the set of matched elements or set one or more properties for every matched element.
     * @param {Object} elm  
     * @param {String} name
     */
    function removeProp(elm, name) {
        name.split(' ').forEach(function(prop) {
            delete elm[prop];
        });
        return this;
    }

    /*   
     * Get the combined text contents of each element in the set of matched elements, including their descendants, or set the text contents of the matched elements.  
     * @param {Object} elm  
     * @param {String} txt
     */
    function text(elm, txt) {
        if (txt === undefined) {
            return elm.textContent !==undefined  ? elm.textContent : elm.innerText;
        } else {
            txt = txt == null ? '' : '' + txt ;
            if (elm.textContent !==undefined ) {
              elm.textContent = txt ;
            } else {
              elm.innerText = txt ;
            }
            return this;
        }
    }

    /*   
     * Get the current value of the first element in the set of matched elements or set the value of every matched element.
     * @param {Object} elm  
     * @param {String} value
     */
    function val(elm, value) {
        var hooks = valHooks[ elm.type ] || valHooks[ elm.nodeName.toLowerCase() ];
        if (value === undefined) {
/*
            if (elm.multiple) {
                // select multiple values
                var selectedOptions = filter.call(finder.find(elm, "option"), (function(option) {
                    return option.selected;
                }));
                return pluck(selectedOptions, "value");
            } else {
                if (/input|textarea/i.test(elm.tagName)) {
                  return elm.value;
                }
                return text(elm);
            }
*/

          if ( hooks &&  "get" in hooks &&  ( ret = hooks.get( elm, "value" ) ) !== undefined ) {
            return ret;
          }

          ret = elm.value;

          // Handle most common string cases
          if ( typeof ret === "string" ) {
            return ret.replace( /\r/g, "" );
          }

          // Handle cases where value is null/undef or number
          return ret == null ? "" : ret;

        } else {
/*          
            if (/input|textarea/i.test(elm.tagName)) {
              elm.value = value;
            } else {
              text(elm,value);
            }
            return this;
*/
          // Treat null/undefined as ""; convert numbers to string
          if ( value == null ) {
            value = "";

          } else if ( typeof value === "number" ) {
            value += "";

          } else if ( langx.isArray( value ) ) {
            value = langx.map( value, function( value1 ) {
              return value1 == null ? "" : value1 + "";
            } );
          }

          // If set returns undefined, fall back to normal setting
          if ( !hooks || !( "set" in hooks ) || hooks.set( elm, value, "value" ) === undefined ) {
            elm.value = value;
          }
        }      
    }


    finder.pseudos.data = function( elem, i, match,dataName ) {
        return !!data( elem, dataName || match[3]);
    };
   

    function datax() {
        return datax;
    }

    langx.mixin(datax, {
        aria: aria,

        attr: attr,

        cleanData: cleanData,

        data: data,

        pluck: pluck,

        prop: prop,

        removeAttr: removeAttr,

        removeData: removeData,

        removeProp: removeProp,

        text: text,

        val: val,

        valHooks : valHooks
    });

    return skylark.attach("domx.data", datax);
});
define('skylark-domx-query/query',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder"
], function(skylark, langx, noder, finder) {
    var some = Array.prototype.some,
        push = Array.prototype.push,
        every = Array.prototype.every,
        concat = Array.prototype.concat,
        slice = Array.prototype.slice,
        map = Array.prototype.map,
        filter = Array.prototype.filter,
        forEach = Array.prototype.forEach,
        indexOf = Array.prototype.indexOf,
        sort = Array.prototype.sort,
        isQ;

    var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;

    var funcArg = langx.funcArg,
        isArrayLike = langx.isArrayLike,
        isString = langx.isString,
        uniq = langx.uniq,
        isFunction = langx.isFunction;

    var type = langx.type,
        isArray = langx.isArray,

        isWindow = langx.isWindow,

        isDocument = langx.isDocument,

        isObject = langx.isObject,

        isPlainObject = langx.isPlainObject,

        compact = langx.compact,

        flatten = langx.flatten,

        camelCase = langx.camelCase,

        dasherize = langx.dasherize,
        children = finder.children;

    function wrapper_node_operation(func, context, oldValueFunc) {
        return function(html) {
            var argType, nodes = langx.map(arguments, function(arg) {
                argType = type(arg)
                return argType == "function" || argType == "object" || argType == "array" || arg == null ?
                    arg : noder.createFragment(arg)
            });
            if (nodes.length < 1) {
                return this
            }
            this.each(function(idx) {
                func.apply(context, [this, nodes, idx > 0]);
            });
            return this;
        }
    }

    function wrapper_map(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            var result = langx.map(self, function(elem, idx) {
                return func.apply(context, [elem].concat(params));
            });
            return query(uniq(result));
        }
    }

    function wrapper_selector(func, context, last) {
        return function(selector) {
            var self = this,
                params = slice.call(arguments);
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) {
                if (elem.querySelector) {
                    return func.apply(context, last ? [elem] : [elem, selector]);
                } else {
                    return [];
                }
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }

    function wrapper_selector_until(func, context, last) {
        return function(util, selector) {
            var self = this,
                params = slice.call(arguments);
            //if (selector === undefined) { //TODO : needs confirm?
            //    selector = util;
            //    util = undefined;
            //}
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) { // TODO
                //if (elem.querySelector) {
                    return func.apply(context, last ? [elem, util] : [elem, selector, util]);
                //} else {
                //    return [];
                //}
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }


    function wrapper_every_act(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            this.each(function(idx,node) {
                func.apply(context, [this].concat(params));
            });
            return self;
        }
    }

    function wrapper_every_act_firstArgFunc(func, context, oldValueFunc) {
        return function(arg1) {
            var self = this,
                params = slice.call(arguments);
            forEach.call(self, function(elem, idx) {
                var newArg1 = funcArg(elem, arg1, idx, oldValueFunc(elem));
                func.apply(context, [elem, newArg1].concat(params.slice(1)));
            });
            return self;
        }
    }

    function wrapper_some_chk(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            return some.call(self, function(elem) {
                return func.apply(context, [elem].concat(params));
            });
        }
    }

    function wrapper_name_value(func, context, oldValueFunc) {
        return function(name, value) {
            var self = this;

            if (langx.isPlainObject(name) || langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem, name));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem,name,newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0], name]);
                }
            }

        }
    }

    function wrapper_value(func, context, oldValueFunc) {
        return function(value) {
            var self = this;

            if (langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem, newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0]]);
                }
            }

        }
    }


    var NodeList = langx.klass({
        klassName: "SkNodeList",
        init: function(selector, context) {
            var self = this,
                match, nodes, node, props;

            if (selector) {
                self.context = context = context || noder.doc();

                if (isString(selector)) {
                    // a html string or a css selector is expected
                    self.selector = selector;

                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        match = [null, selector, null];
                    } else {
                        match = rquickExpr.exec(selector);
                    }

                    if (match) {
                        if (match[1]) {
                            // if selector is html
                            nodes = noder.createFragment(selector);

                            if (langx.isPlainObject(context)) {
                                props = context;
                            }

                        } else {
                            node = finder.byId(match[2], noder.ownerDoc(context));

                            if (node) {
                                // if selector is id
                                nodes = [node];
                            }

                        }
                    } else {
                        // if selector is css selector
                        if (langx.isString(context)) {
                            context = finder.find(context);
                        }

                        nodes = finder.descendants(context, selector);
                    }
                } else {
                    if (!noder.isWindow(selector) && isArrayLike(selector)) {
                        // a dom node array is expected
                        nodes = selector;
                    } else {
                        // a dom node is expected
                        nodes = [selector];
                    }
                    //self.add(selector, false);
                }
            }


            if (nodes) {

                push.apply(self, nodes);

                if (props) {
                    for ( var name  in props ) {
                        // Properties of context are called as methods if possible
                        if ( langx.isFunction( this[ name ] ) ) {
                            this[ name ]( props[ name ] );
                        } else {
                            this.attr( name, props[ name ] );
                        }
                    }
                }
            }

            return self;
        }
    });

    var query = (function() {
        isQ = function(object) {
            return object instanceof NodeList;
        }
        init = function(selector, context) {
            return new NodeList(selector, context);
        }

        var $ = function(selector, context) {
            if (isFunction(selector)) {
                $.ready(function() {
                    selector($);
                });
                return rootQuery;
            } else if (isQ(selector)) {
                return selector;
            } else {
                if (context && isQ(context) && isString(selector)) {
                    return context.find(selector);
                }
                return init(selector, context);
            }
        },rootQuery = $(document);

        $.fn = NodeList.prototype;
        langx.mixin($.fn, {
            // `map` and `slice` in the jQuery API work differently
            // from their array counterparts
            length : 0,

            map: function(fn) {
                return $(uniq(langx.map(this, function(el, i) {
                    return fn.call(el, i, el)
                })));
            },

            slice: function() {
                return $(slice.apply(this, arguments))
            },

            forEach: function() {
                return forEach.apply(this,arguments);
            },

            get: function(idx) {
                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
            },

            indexOf: function() {
                return indexOf.apply(this,arguments);
            },

            sort : function() {
                return sort.apply(this,arguments);
            },

            toArray: function() {
                return slice.call(this);
            },

            size: function() {
                return this.length
            },

            //remove: wrapper_every_act(noder.remove, noder),
            remove : function(selector) {
                if (selector) {
                    return this.find(selector).remove();
                }
                this.each(function(i,node){
                    noder.remove(node);
                });
                return this;
            },

            each: function(callback) {
                langx.each(this, callback);
                return this;
            },

            filter: function(selector) {
                if (isFunction(selector)) return this.not(this.not(selector))
                return $(filter.call(this, function(element) {
                    return finder.matches(element, selector)
                }))
            },

            add: function(selector, context) {
                return $(uniq(this.toArray().concat($(selector, context).toArray())));
            },

            is: function(selector) {
                if (this.length > 0) {
                    var self = this;
                    if (langx.isString(selector)) {
                        return some.call(self,function(elem) {
                            return finder.matches(elem, selector);
                        });
                    } else if (langx.isArrayLike(selector)) {
                       return some.call(self,function(elem) {
                            return langx.inArray(elem, selector) > -1;
                        });
                    } else if (langx.isHtmlNode(selector)) {
                       return some.call(self,function(elem) {
                            return elem ==  selector;
                        });
                    }
                }
                return false;
            },
            
            not: function(selector) {
                var nodes = []
                if (isFunction(selector) && selector.call !== undefined)
                    this.each(function(idx,node) {
                        if (!selector.call(this, idx,node)) nodes.push(this)
                    })
                else {
                    var excludes = typeof selector == 'string' ? this.filter(selector) :
                        (isArrayLike(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
                    this.forEach(function(el) {
                        if (excludes.indexOf(el) < 0) nodes.push(el)
                    })
                }
                return $(nodes)
            },

            has: function(selector) {
                return this.filter(function() {
                    return isObject(selector) ?
                        noder.contains(this, selector) :
                        $(this).find(selector).size()
                })
            },

            eq: function(idx) {
                return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
            },

            first: function() {
                return this.eq(0);
            },

            last: function() {
                return this.eq(-1);
            },

            find: wrapper_selector(finder.descendants, finder),

            closest: wrapper_selector(finder.closest, finder),
            /*
                        closest: function(selector, context) {
                            var node = this[0],
                                collection = false
                            if (typeof selector == 'object') collection = $(selector)
                            while (node && !(collection ? collection.indexOf(node) >= 0 : finder.matches(node, selector)))
                                node = node !== context && !isDocument(node) && node.parentNode
                            return $(node)
                        },
            */


            parents: wrapper_selector(finder.ancestors, finder),

            parentsUntil: wrapper_selector_until(finder.ancestors, finder),


            parent: wrapper_selector(finder.parent, finder),

            children: wrapper_selector(finder.children, finder),

            contents: wrapper_map(noder.contents, noder),

            empty: wrapper_every_act(noder.empty, noder),

            html: wrapper_value(noder.html, noder),

            // `pluck` is borrowed from Prototype.js
            pluck: function(property) {
                return langx.map(this, function(el) {
                    return el[property]
                })
            },

            pushStack : function(elms) {
                var ret = $(elms);
                ret.prevObject = this;
                return ret;
            },
            
            replaceWith: function(newContent) {
                return this.before(newContent).remove();
            },

            wrap: function(html) {
                /*
                var func = isFunction(structure)
                if (this[0] && !func)
                    var dom = $(structure).get(0),
                        clone = dom.parentNode || this.length > 1

                return this.each(function(index,node) {
                    $(this).wrapAll(
                        func ? structure.call(this, index,node) :
                        clone ? dom.cloneNode(true) : dom
                    )
                })
                */
                var htmlIsFunction = typeof html === "function";

                return this.each( function( i ) {
                    $( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
                } );                
            },

            wrapAll: function(html) {
                /*
                if (this[0]) {
                    $(this[0]).before(wrappingElement = $(wrappingElement));
                    var children;
                    // drill down to the inmost element
                    while ((children = wrappingElement.children()).length) {
                        wrappingElement = children.first();
                    }
                    $(wrappingElement).append(this);
                }
                return this
                */
                var wrap;

                if ( this[ 0 ] ) {
                    if ( typeof html === "function" ) {
                        html = html.call( this[ 0 ] );
                    }

                    // The elements to wrap the target around
                    wrap = $( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                    if ( this[ 0 ].parentNode ) {
                        wrap.insertBefore( this[ 0 ] );
                    }

                    wrap.map( function() {
                        var elem = this;

                        while ( elem.firstElementChild ) {
                            elem = elem.firstElementChild;
                        }

                        return elem;
                    } ).append( this );
                }

                return this;

            },

            wrapInner: function(html) {
                /*
                var func = isFunction(wrappingElement)
                return this.each(function(index,node) {
                    var self = $(this),
                        contents = self.contents(),
                        dom = func ? wrappingElement.call(this, index,node) : wrappingElement
                    contents.length ? contents.wrapAll(dom) : self.append(dom)
                })
                */
                if ( typeof html === "function" ) {
                    return this.each( function( i ) {
                        $( this ).wrapInner( html.call( this, i ) );
                    } );
                }

                return this.each( function() {
                    var self = $( this ),
                        contents = self.contents();

                    if ( contents.length ) {
                        contents.wrapAll( html );

                    } else {
                        self.append( html );
                    }
                } );

            },

            unwrap: function(selector) {
                /*
                if (this.parent().children().length === 0) {
                    // remove dom without text
                    this.parent(selector).not("body").each(function() {
                        $(this).replaceWith(document.createTextNode(this.childNodes[0].textContent));
                    });
                } else {
                    this.parent().each(function() {
                        $(this).replaceWith($(this).children())
                    });
                }
                return this
                */
                this.parent(selector).not("body").each( function() {
                    $(this).replaceWith(this.childNodes);
                });
                return this;

            },

            clone: function() {
                return this.map(function() {
                    return this.cloneNode(true)
                })
            },


            toggle: function(setting) {
                return this.each(function() {
                    var el = $(this);
                    (setting === undefined ? el.css("display") == "none" : setting) ? el.show(): el.hide()
                })
            },

            prev: function(selector) {
                return $(this.pluck('previousElementSibling')).filter(selector || '*')
            },

            prevAll: wrapper_selector(finder.previousSiblings, finder),

            next: function(selector) {
                return $(this.pluck('nextElementSibling')).filter(selector || '*')
            },

            nextAll: wrapper_selector(finder.nextSiblings, finder),

            siblings: wrapper_selector(finder.siblings, finder),

            index: function(elem) {
                if (elem) {
                    return this.indexOf($(elem)[0]);
                } else {
                    return this.parent().children().indexOf(this[0]);
                }
            }
        });

        // for now
        $.fn.detach = $.fn.remove;

        $.fn.hover = function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        };


        var traverseNode = noder.traverse;


        $.fn.after = wrapper_node_operation(noder.after, noder);

        $.fn.prepend = wrapper_node_operation(noder.prepend, noder);

        $.fn.before = wrapper_node_operation(noder.before, noder);

        $.fn.append = wrapper_node_operation(noder.append, noder);


        langx.each( {
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function( name, original ) {
            $.fn[ name ] = function( selector ) {
                var elems,
                    ret = [],
                    insert = $( selector ),
                    last = insert.length - 1,
                    i = 0;

                for ( ; i <= last; i++ ) {
                    elems = i === last ? this : this.clone( true );
                    $( insert[ i ] )[ original ]( elems );

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // .get() because push.apply(_, arraylike) throws on ancient WebKit
                    push.apply( ret, elems.get() );
                }

                return this.pushStack( ret );
            };
        } );

/*
        $.fn.insertAfter = function(html) {
            $(html).after(this);
            return this;
        };

        $.fn.insertBefore = function(html) {
            $(html).before(this);
            return this;
        };

        $.fn.appendTo = function(html) {
            $(html).append(this);
            return this;
        };

        $.fn.prependTo = function(html) {
            $(html).prepend(this);
            return this;
        };

        $.fn.replaceAll = function(selector) {
            $(selector).replaceWith(this);
            return this;
        };
*/
        return $;
    })();

    (function($) {
        $.fn.scrollParent = function( includeHidden ) {
            var position = this.css( "position" ),
                excludeStaticParent = position === "absolute",
                overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                scrollParent = this.parents().filter( function() {
                    var parent = $( this );
                    if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                        return false;
                    }
                    return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                        parent.css( "overflow-x" ) );
                } ).eq( 0 );

            return position === "fixed" || !scrollParent.length ?
                $( this[ 0 ].ownerDocument || document ) :
                scrollParent;
        };

    })(query);


    (function($) {
        $.fn.end = function() {
            return this.prevObject || $()
        }

        $.fn.andSelf = function() {
            return this.add(this.prevObject || $())
        }

        $.fn.addBack = function(selector) {
            if (this.prevObject) {
                if (selector) {
                    return this.add(this.prevObject.filter(selector));
                } else {
                    return this.add(this.prevObject);
                }
            } else {
                return this;
            }
        }

        'filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings,prev,prevAll,next,nextAll'.split(',').forEach(function(property) {
            var fn = $.fn[property]
            $.fn[property] = function() {
                var ret = fn.apply(this, arguments)
                ret.prevObject = this
                return ret
            }
        })
    })(query);


    (function($) {
        $.fn.query = $.fn.find;

        $.fn.place = function(refNode, position) {
            // summary:
            //      places elements of this node list relative to the first element matched
            //      by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
            // queryOrNode:
            //      may be a string representing any valid CSS3 selector or a DOM node.
            //      In the selector case, only the first matching element will be used
            //      for relative positioning.
            // position:
            //      can be one of:
            //
            //      -   "last" (default)
            //      -   "first"
            //      -   "before"
            //      -   "after"
            //      -   "only"
            //      -   "replace"
            //
            //      or an offset in the childNodes
            if (langx.isString(refNode)) {
                refNode = finder.descendant(refNode);
            } else if (isQ(refNode)) {
                refNode = refNode[0];
            }
            return this.each(function(i, node) {
                switch (position) {
                    case "before":
                        noder.before(refNode, node);
                        break;
                    case "after":
                        noder.after(refNode, node);
                        break;
                    case "replace":
                        noder.replace(refNode, node);
                        break;
                    case "only":
                        noder.empty(refNode);
                        noder.append(refNode, node);
                        break;
                    case "first":
                        noder.prepend(refNode, node);
                        break;
                        // else fallthrough...
                    default: // aka: last
                        noder.append(refNode, node);
                }
            });
        };

        $.fn.addContent = function(content, position) {
            if (content.template) {
                content = langx.substitute(content.template, content);
            }
            return this.append(content);
        };



        $.fn.disableSelection = ( function() {
            var eventType = "onselectstart" in document.createElement( "div" ) ?
                "selectstart" :
                "mousedown";

            return function() {
                return this.on( eventType + ".ui-disableSelection", function( event ) {
                    event.preventDefault();
                } );
            };
        } )();

        $.fn.enableSelection = function() {
            return this.off( ".ui-disableSelection" );
        };

        $.fn.reflow = function() {
            return noder.flow(this[0]);
        };

        $.fn.isBlockNode = function() {
            return noder.isBlockNode(this[0]);
        };
       

    })(query);

    query.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue = this;

        this.each(function(){
            returnValue = plugins.instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };


    query.wraps = {
        wrapper_node_operation,
        wrapper_map,
        wrapper_value,
        wrapper_selector,
        wrapper_some_chk,
        wrapper_selector_until,
        wrapper_every_act_firstArgFunc,
        wrapper_every_act,
        wrapper_name_value

    };

    return skylark.attach("domx.query", query);

});
define('skylark-domx-query/main',[
	"./query",
	"skylark-domx-styler"
],function($,styler){

    $.fn.style = $.wraps.wrapper_name_value(styler.css, styler);

    $.fn.css = $.wraps.wrapper_name_value(styler.css, styler);

    //hasClass(name)
    $.fn.hasClass = $.wraps.wrapper_some_chk(styler.hasClass, styler);

    //addClass(name)
    $.fn.addClass = $.wraps.wrapper_every_act_firstArgFunc(styler.addClass, styler, styler.className);

    //removeClass(name)
    $.fn.removeClass = $.wraps.wrapper_every_act_firstArgFunc(styler.removeClass, styler, styler.className);

    //toogleClass(name,when)
    $.fn.toggleClass = $.wraps.wrapper_every_act_firstArgFunc(styler.toggleClass, styler, styler.className);

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };
        

	return $;
});
define('skylark-domx-query', ['skylark-domx-query/main'], function (main) { return main; });

define('skylark-domx-velm/velm',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query"
], function(skylark, langx, noder, finder, $) {
    var map = Array.prototype.map,
        slice = Array.prototype.slice;
    /*
     * VisualElement is a skylark class type wrapping a visule dom node,
     * provides a number of prototype methods and supports chain calls.
     */
    var VisualElement = langx.klass({
        klassName: "VisualElement",

        "_construct": function(node) {
            if (langx.isString(node)) {
                if (node.charAt(0) === "<") {
                    //html
                    node = noder.createFragment(node)[0];
                } else {
                    // id
                    node = document.getElementById(node);
                }
            }
            this._elm = node;
        }
    });

    VisualElement.prototype.$ = VisualElement.prototype.query = function(selector) {
        return $(selector,this._elm);
    };

    VisualElement.prototype.elm = function() {
        return this._elm;
    };

    /*
     * the VisualElement object wrapping document.body
     */
    var root = new VisualElement(document.body),
        velm = function(node) {
            if (node) {
                return new VisualElement(node);
            } else {
                return root;
            }
        };
    /*
     * Extend VisualElement prototype with wrapping the specified methods.
     * @param {ArrayLike} fn
     * @param {Object} context
     */
    function _delegator(fn, context) {
        return function() {
            var self = this,
                elem = self._elm,
                ret = fn.apply(context, [elem].concat(slice.call(arguments)));

            if (ret) {
                if (ret === context) {
                    return self;
                } else {
                    if (ret instanceof HTMLElement) {
                        ret = new VisualElement(ret);
                    } else if (langx.isArrayLike(ret)) {
                        ret = map.call(ret, function(el) {
                            if (el instanceof HTMLElement) {
                                return new VisualElement(el);
                            } else {
                                return el;
                            }
                        })
                    }
                }
            }
            return ret;
        };
    }

    langx.mixin(velm, {
        batch: function(nodes, action, args) {
            nodes.forEach(function(node) {
                var elm = (node instanceof VisualElement) ? node : velm(node);
                elm[action].apply(elm, args);
            });

            return this;
        },

        root: new VisualElement(document.body),

        VisualElement: VisualElement,

        partial: function(name, fn) {
            var props = {};

            props[name] = fn;

            VisualElement.partial(props);
        },

        delegate: function(names, context,matching) {
            var props = {};

            names.forEach(function(name) {
                var matchedName = name;
                if (matching && matching[name]) {
                    matchedName = matching[name];
                } 
                props[name] = _delegator(context[matchedName], context);
            });

            VisualElement.partial(props);
        }
    });

    // from ./finder
    velm.delegate([
        "ancestor",
        "ancestors",
        "children",
        "descendant",
        "find",
        "findAll",
        "firstChild",
        "lastChild",
        "matches",
        "nextSibling",
        "nextSiblings",
        "parent",
        "previousSibling",
        "previousSiblings",
        "siblings"
    ], finder);

    /*
     * find a dom element matched by the specified selector.
     * @param {String} selector
     */
    velm.find = function(selector) {
        if (selector === "body") {
            return this.root;
        } else {
            return this.root.descendant(selector);
        }
    };


    // from ./noder
    velm.delegate([
        "after",
        "append",
        "before",
        "clone",
        "contains",
        "contents",
        "empty",
        "html",
        "isChildOf",
        "isDocument",
        "isInDocument",
        "isWindow",
        "ownerDoc",
        "prepend",
        "remove",
        "removeChild",
        "replace",
        "reverse",
        "throb",
        "traverse",
        "wrapper",
        "wrapperInner",
        "unwrap"
    ], noder);


    return skylark.attach("domx.velm", velm);
});
define('skylark-domx-velm/main',[
	"./velm",
	"skylark-domx-styler"
],function(velm,styler){
    // from ./styler
    velm.delegate([
        "addClass",
        "className",
        "css",
        "hasClass",
        "hide",
        "isInvisible",
        "removeClass",
        "show",
        "toggleClass"
    ], styler);

    // properties

    var properties = [ 'position', 'left', 'top', 'right', 'bottom', 'width', 'height', 'border', 'borderLeft',
    'borderTop', 'borderRight', 'borderBottom', 'borderColor', 'display', 'overflow', 'margin', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'padding', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'color',
    'background', 'backgroundColor', 'opacity', 'fontSize', 'fontWeight', 'textAlign', 'textDecoration', 'textTransform', 'cursor', 'zIndex' ];

    properties.forEach( function ( property ) {

        var method = property;

        velm.VisualElement.prototype[method ] = function (value) {

            this.css( property, value );

            return this;

        };

    });

	return velm;
});
define('skylark-domx-velm', ['skylark-domx-velm/main'], function (main) { return main; });

define('skylark-domx-data/main',[
    "./data",
    "skylark-domx-velm",
    "skylark-domx-query"    
],function(data,velm,$){
    // from ./data
    velm.delegate([
        "attr",
        "data",
        "prop",
        "removeAttr",
        "removeData",
        "text",
        "val"
    ], data);

    $.fn.text = $.wraps.wrapper_value(data.text, data, data.text);

    $.fn.attr = $.wraps.wrapper_name_value(data.attr, data, data.attr);

    $.fn.removeAttr = $.wraps.wrapper_every_act(data.removeAttr, data);

    $.fn.prop = $.wraps.wrapper_name_value(data.prop, data, data.prop);

    $.fn.removeProp = $.wraps.wrapper_every_act(data.removeProp, data);

    $.fn.data = $.wraps.wrapper_name_value(data.data, data);

    $.fn.removeData = $.wraps.wrapper_every_act(data.removeData);

    $.fn.val = $.wraps.wrapper_value(data.val, data, data.val);


    return data;
});
define('skylark-domx-data', ['skylark-domx-data/main'], function (main) { return main; });

define('skylark-domx/data',[
    "skylark-domx-data"
], function( data) {
 
    return data;
});
define('skylark-domx-eventer/eventer',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-finder",
    "skylark-domx-noder",
    "skylark-domx-data"
], function(skylark, langx, browser, finder, noder, datax) {
    var mixin = langx.mixin,
        each = langx.each,
        slice = Array.prototype.slice,
        uid = langx.uid,
        ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,
        eventMethods = {
            preventDefault: "isDefaultPrevented",
            stopImmediatePropagation: "isImmediatePropagationStopped",
            stopPropagation: "isPropagationStopped"
        },
        readyRE = /complete|loaded|interactive/;

    function compatible(event, source) {
        if (source || !event.isDefaultPrevented) {
            if (!source) {
                source = event;
            }

            langx.each(eventMethods, function(name, predicate) {
                var sourceMethod = source[name];
                event[name] = function() {
                    this[predicate] = langx.returnTrue;
                    return sourceMethod && sourceMethod.apply(source, arguments);
                }
                event[predicate] = langx.returnFalse;
            });
        }
        return event;
    }

    function parse(event) {
        if (event) {
            var segs = ("" + event).split(".");
            return {
                type: segs[0],
                ns: segs.slice(1).sort().join(" ")
            };
        } else {
            return {
                type : null,
                ns : null
            }
        }
    }

    function isHandler(callback) {
        return callback && (langx.isFunction(callback) || langx.isFunction(callback.handleEvent));
    }

    var NativeEventCtors = [
            window["CustomEvent"], // 0 default
            window["CompositionEvent"], // 1
            window["DragEvent"], // 2
            window["Event"], // 3
            window["FocusEvent"], // 4
            window["KeyboardEvent"], // 5
            window["MessageEvent"], // 6
            window["MouseEvent"], // 7
            window["MouseScrollEvent"], // 8
            window["MouseWheelEvent"], // 9
            window["MutationEvent"], // 10
            window["ProgressEvent"], // 11
            window["TextEvent"], // 12
            window["TouchEvent"], // 13
            window["UIEvent"], // 14
            window["WheelEvent"], // 15
            window["ClipboardEvent"] // 16
        ],
        NativeEvents = {
            "compositionstart": 1, // CompositionEvent
            "compositionend": 1, // CompositionEvent
            "compositionupdate": 1, // CompositionEvent

            "beforecopy": 16, // ClipboardEvent
            "beforecut": 16, // ClipboardEvent
            "beforepaste": 16, // ClipboardEvent
            "copy": 16, // ClipboardEvent
            "cut": 16, // ClipboardEvent
            "paste": 16, // ClipboardEvent

            "drag": 2, // DragEvent
            "dragend": 2, // DragEvent
            "dragenter": 2, // DragEvent
            "dragexit": 2, // DragEvent
            "dragleave": 2, // DragEvent
            "dragover": 2, // DragEvent
            "dragstart": 2, // DragEvent
            "drop": 2, // DragEvent

            "abort": 3, // Event
            "change": 3, // Event
            "error": 3, // Event
            "selectionchange": 3, // Event
            "submit": 3, // Event
            "reset": 3, // Event
            'fullscreenchange':3,
            'fullscreenerror':3,

/*
            'disablepictureinpicturechanged':3,
            'ended':3,
            'enterpictureinpicture':3,
            'durationchange':3,
            'leavepictureinpicture':3,
            'loadstart' : 3,
            'loadedmetadata':3,
            'pause' : 3,
            'play':3,
            'posterchange':3,
            'ratechange':3,
            'seeking' : 3,
            'sourceset':3,
            'suspend':3,
            'textdata':3,
            'texttrackchange':3,
            'timeupdate':3,
            'volumechange':3,
            'waiting' : 3,
*/


            "focus": 4, // FocusEvent
            "blur": 4, // FocusEvent
            "focusin": 4, // FocusEvent
            "focusout": 4, // FocusEvent

            "keydown": 5, // KeyboardEvent
            "keypress": 5, // KeyboardEvent
            "keyup": 5, // KeyboardEvent

            "message": 6, // MessageEvent

            "click": 7, // MouseEvent
            "contextmenu": 7, // MouseEvent
            "dblclick": 7, // MouseEvent
            "mousedown": 7, // MouseEvent
            "mouseup": 7, // MouseEvent
            "mousemove": 7, // MouseEvent
            "mouseover": 7, // MouseEvent
            "mouseout": 7, // MouseEvent
            "mouseenter": 7, // MouseEvent
            "mouseleave": 7, // MouseEvent


            "progress" : 11, //ProgressEvent

            "textInput": 12, // TextEvent

            "tap": 13,
            "touchstart": 13, // TouchEvent
            "touchmove": 13, // TouchEvent
            "touchend": 13, // TouchEvent

            "load": 14, // UIEvent
            "resize": 14, // UIEvent
            "select": 14, // UIEvent
            "scroll": 14, // UIEvent
            "unload": 14, // UIEvent,

            "wheel": 15, // WheelEvent



        };

    //create a custom dom event
    var createEvent = (function() {

        function getEventCtor(type) {
            var idx = NativeEvents[type];
            if (!idx) {
                idx = 0;
            }
            return NativeEventCtors[idx];
        }

        return function(type, props) {
            //create a custom dom event

            if (langx.isString(type)) {
                props = props || {};
            } else {
                props = type || {};
                type = props.type || "";
            }
            var parsed = parse(type);
            type = parsed.type;

            props = langx.mixin({
                bubbles: true,
                cancelable: true
            }, props);

            if (parsed.ns) {
                props.namespace = parsed.ns;
            }

            var ctor = getEventCtor(type),
                e = new ctor(type, props);

            langx.safeMixin(e, props);

            return compatible(e);
        };
    })();

    function createProxy(src, props) {
        var key,
            proxy = {
                originalEvent: src
            };
        for (key in src) {
            if (key !== "keyIdentifier" && !ignoreProperties.test(key) && src[key] !== undefined) {
                proxy[key] = src[key];
            }
        }
        if (props) {
            langx.mixin(proxy, props);
        }
        return compatible(proxy, src);
    }

    var
        specialEvents = {},
        focusinSupported = "onfocusin" in window,
        focus = { focus: "focusin", blur: "focusout" },
        hover = { mouseenter: "mouseover", mouseleave: "mouseout" },
        realEvent = function(type) {
            return hover[type] || (focusinSupported && focus[type]) || type;
        },
        handlers = {},
        EventBindings = langx.klass({
            init: function(target, event) {
                this._target = target;
                this._event = event;
                this._bindings = [];
            },

            add: function(fn, options) {
                var bindings = this._bindings,
                    binding = {
                        fn: fn,
                        options: langx.mixin({}, options)
                    };

                bindings.push(binding);

                var self = this;
                if (!self._listener) {
                    self._listener = function(domEvt) {
                        var elm = this,
                            e = createProxy(domEvt),
                            args = domEvt._args,
                            bindings = self._bindings,
                            ns = e.namespace;

                        if (langx.isDefined(args)) {
                            args = [e].concat(args);
                        } else {
                            args = [e];
                        }

                        e.type = self._event; // convert realEvent to listened event

                        langx.each(bindings, function(idx, binding) {
                            var match = elm;
                            if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                                return false;
                            }
                            var fn = binding.fn,
                                options = binding.options || {},
                                selector = options.selector,
                                one = options.one,
                                data = options.data;

                            if (ns && ns != options.ns && options.ns.indexOf(ns) === -1) {
                                return;
                            }
                            if (selector) {
                                match = finder.closest(e.target, selector);
                                if (match && match !== elm) {
                                    langx.mixin(e, {
                                        currentTarget: match,
                                        liveFired: elm
                                    });
                                } else {
                                    return;
                                }
                            }

                            var originalEvent = self._event;
                            if (originalEvent in hover) {
                                var related = e.relatedTarget;
                                if (related && (related === match || noder.contains(match, related))) {
                                    return;
                                }
                            }

                            if (langx.isDefined(data)) {
                                e.data = data;
                            }

                            if (one) {
                                self.remove(fn, options);
                            }

                            var result ;
                            if (fn.handleEvent) {
                                result = fn.handleEvent.apply(fn,args);
                            } else {
                                if (options.ctx) {
                                    result = fn.apply(options.ctx, args);                                   
                                } else {
                                    result = fn.apply(match, args);                                   
                                }
                            }

                            if (result === false) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });;
                    };

                    var event = self._event;
                    /*
                                        if (event in hover) {
                                            var l = self._listener;
                                            self._listener = function(e) {
                                                var related = e.relatedTarget;
                                                if (!related || (related !== this && !noder.contains(this, related))) {
                                                    return l.apply(this, arguments);
                                                }
                                            }
                                        }
                    */

                    if (self._target.addEventListener) {
                        self._target.addEventListener(realEvent(event), self._listener, false);
                    } else {
                        console.warn("invalid eventer object", self._target);
                    }
                }

            },
            remove: function(fn, options) {
                options = langx.mixin({}, options);

                function matcherFor(ns) {
                    return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
                }
                var matcher;
                if (options.ns) {
                    matcher = matcherFor(options.ns);
                }

                this._bindings = this._bindings.filter(function(binding) {
                    var removing = (!fn || fn === binding.fn) &&
                        (!matcher || matcher.test(binding.options.ns)) &&
                        (!options.selector || options.selector == binding.options.selector);

                    return !removing;
                });
                if (this._bindings.length == 0) {
                    if (this._target.removeEventListener) {
                        this._target.removeEventListener(realEvent(this._event), this._listener, false);
                    }
                    this._listener = null;
                }
            }
        }),
        EventsHandler = langx.klass({
            init: function(elm) {
                this._target = elm;
                this._handler = {};
            },

            // add a event listener
            // selector Optional
            register: function(event, callback, options) {
                // Seperate the event from the namespace
                var parsed = parse(event),
                    event = parsed.type,
                    specialEvent = specialEvents[event],
                    bindingEvent = specialEvent && (specialEvent.bindType || specialEvent.bindEventName);

                var events = this._handler;

                // Check if there is already a handler for this event
                if (events[event] === undefined) {
                    events[event] = new EventBindings(this._target, bindingEvent || event);
                }

                // Register the new callback function
                events[event].add(callback, langx.mixin({
                    ns: parsed.ns
                }, options)); // options:{selector:xxx}
            },

            // remove a event listener
            unregister: function(event, fn, options) {
                // Check for parameter validtiy
                var events = this._handler,
                    parsed = parse(event);
                event = parsed.type;

                if (event) {
                    var listener = events[event];

                    if (listener) {
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                } else {
                    //remove all events
                    for (event in events) {
                        var listener = events[event];
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                }
            }
        }),

        findHandler = function(elm) {
            var id = uid(elm),
                handler = handlers[id];
            if (!handler) {
                handler = handlers[id] = new EventsHandler(elm);
            }
            return handler;
        };


    /*   
     * Remove all event handlers from the specified element.
     * @param {HTMLElement} elm  
     */
    function clear(elm) {
        var handler = findHandler(elm);

        handler.unregister();

        return this;
    }

    /*   
     * Remove an event handler for one or more events from the specified element.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {StringOptional } selector
     * @param {Function} callback
     */
    function off(elm, events, selector, callback) {
        var $this = this
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                off(elm, type, selector, fn);
            })
            return $this;
        }

        if (!langx.isString(selector) && !isHandler(callback) && callback !== false) {
            callback = selector;
            selector = undefined;
        }

        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        if (events) events.forEach(function(event) {

            handler.unregister(event, callback, {
                selector: selector,
            });
        });
        return this;
    }

    /*   
     * Attach an event handler function for one or more events to the selected elements.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {StringOptional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     * @param {BooleanOptional} one
     */
    function on(elm, events, selector, data, callback, ctx,one) {

        var autoRemove, delegator;
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                on(elm, type, selector, data, fn, one);
            });
            return this;
        }

        if (!langx.isString(selector) && !isHandler(callback)) {
            one = ctx;
            ctx = callback;
            callback = data;
            data = selector;
            selector = undefined;
        }

        if (isHandler(data)) {
            one = ctx;
            ctx = callback;
            callback = data;
            data = undefined;
        }

        if (langx.isBoolean(ctx)) {
            one = ctx;
            ctx = undefined;
        }
        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        events.forEach(function(event) {
            if (event == "ready") {
                return ready(callback);
            }
            handler.register(event, callback, {
                data: data,
                selector: selector,
                ctx : ctx,
                one: !!one
            });
        });
        return this;
    }

    /*   
     * Attach a handler to an event for the elements. The handler is executed at most once per 
     * @param {HTMLElement} elm  
     * @param {String} event
     * @param {StringOptional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     */
    function one(elm, events, selector, data, callback) {
        on(elm, events, selector, data, callback, 1);

        return this;
    }

    /*   
     * Prevents propagation and clobbers the default action of the passed event. The same as calling event.preventDefault() and event.stopPropagation(). 
     * @param {String} event
     */
    function stop(event) {
        if (window.document.all) {
            event.keyCode = 0;
        }
        if (event.preventDefault) {
            event.preventDefault();
            event.stopPropagation();
        }
        return this;
    }
    /*   
     * Execute all handlers and behaviors attached to the matched elements for the given event  
     * @param {String} evented
     * @param {String} type
     * @param {Array or PlainObject } args
     */
    function trigger(evented, type, args) {
        var e;
        if (type instanceof Event) {
            e = type;
        } else {
            e = createEvent(type, args);
        }
        e._args = args;

        var fn = (evented.dispatchEvent || evented.trigger);
        if (fn) {
            fn.call(evented, e);
        } else {
            console.warn("The evented parameter is not a eventable object");
        }

        return this;
    }
    /*   
     * Specify a function to execute when the DOM is fully loaded.  
     * @param {Function} callback
     */
    function ready(callback) {
        // need to check if document.body exists for IE as that browser reports
        // document ready when it hasn't yet created the body elm
        if (readyRE.test(document.readyState) && document.body) {
            langx.defer(callback);
        } else {
            document.addEventListener('DOMContentLoaded', callback, false);
        }

        return this;
    }

    var keyCodeLookup = {
        "backspace": 8,
        "comma": 188,
        "delete": 46,
        "down": 40,
        "end": 35,
        "enter": 13,
        "escape": 27,
        "home": 36,
        "left": 37,
        "page_down": 34,
        "page_up": 33,
        "period": 190,
        "right": 39,
        "space": 32,
        "tab": 9,
        "up": 38
    };
    //example:
    //shortcuts(elm).add("CTRL+ALT+SHIFT+X",function(){console.log("test!")});
    function shortcuts(elm) {

        var registry = datax.data(elm, "shortcuts");
        if (!registry) {
            registry = {};
            datax.data(elm, "shortcuts", registry);
            var run = function(shortcut, event) {
                var n = event.metaKey || event.ctrlKey;
                if (shortcut.ctrl == n && shortcut.alt == event.altKey && shortcut.shift == event.shiftKey) {
                    if (event.keyCode == shortcut.keyCode || event.charCode && event.charCode == shortcut.charCode) {
                        event.preventDefault();
                        if ("keydown" == event.type) {
                            shortcut.fn(event);
                        }
                        return true;
                    }
                }
            };
            on(elm, "keyup keypress keydown", function(event) {
                if (!(/INPUT|TEXTAREA/.test(event.target.nodeName))) {
                    for (var key in registry) {
                        run(registry[key], event);
                    }
                }
            });

        }

        return {
            add: function(pattern, fn) {
                var shortcutKeys;
                if (pattern.indexOf(",") > -1) {
                    shortcutKeys = pattern.toLowerCase().split(",");
                } else {
                    shortcutKeys = pattern.toLowerCase().split(" ");
                }
                shortcutKeys.forEach(function(shortcutKey) {
                    var setting = {
                        fn: fn,
                        alt: false,
                        ctrl: false,
                        shift: false
                    };
                    shortcutKey.split("+").forEach(function(key) {
                        switch (key) {
                            case "alt":
                            case "ctrl":
                            case "shift":
                                setting[key] = true;
                                break;
                            default:
                                setting.charCode = key.charCodeAt(0);
                                setting.keyCode = keyCodeLookup[key] || key.toUpperCase().charCodeAt(0);
                        }
                    });
                    var regKey = (setting.ctrl ? "ctrl" : "") + "," + (setting.alt ? "alt" : "") + "," + (setting.shift ? "shift" : "") + "," + setting.keyCode;
                    registry[regKey] = setting;
                })
            }

        };

    }

    if (browser.support.transition) {
        specialEvents.transitionEnd = {
//          handle: function (e) {
//            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
//          },
          bindType: browser.support.transition.end,
          delegateType: browser.support.transition.end
        }        
    }

    function isNativeEvent(events) {
        if (langx.isString(events)) {
            return !!NativeEvents[events];
        } else if (langx.isArray(events)) {
            for (var i=0; i<events.length; i++) {
                if (NativeEvents[events]) {
                    return false;
                }
            }
            return events.length > 0;
        }
    }


    function eventer() {
        return eventer;
    }

    langx.mixin(eventer, {
        NativeEvents : NativeEvents,
        
        clear,
        
        create: createEvent,

        keys: keyCodeLookup,

        isNativeEvent,

        off: off,

        on: on,

        one: one,

        proxy: createProxy,

        ready: ready,

        shortcuts: shortcuts,

        special: specialEvents,

        stop: stop,

        trigger: trigger

    });

    each(NativeEvents,function(name){
        eventer[name] = function(elm,selector,data,callback) {
            if (arguments.length>1) {
                return this.on(elm,name,selector,data,callback);
            } else {
                if (name == "focus") {
                    if (elm.focus) {
                        elm.focus();
                    }
                } else if (name == "blur") {
                    if (elm.blur) {
                        elm.blur();
                    }
                } else if (name == "click") {
                    if (elm.click) {
                        elm.click();
                    }
                } else {
                    this.trigger(elm,name);
                }

                return this;
            }
        };
    });

    return skylark.attach("domx.eventer",eventer);
});
define('skylark-domx-eventer/main',[
    "skylark-langx/langx",
    "./eventer",
    "skylark-domx-velm",
    "skylark-domx-query"        
],function(langx,eventer,velm,$){

    var delegateMethodNames = [
        "off",
        "on",
        "one",
        "trigger"
    ];

    langx.each(eventer.NativeEvents,function(name){
        delegateMethodNames.push(name);
    });

    // from ./eventer
    velm.delegate(delegateMethodNames, eventer);

    langx.each(delegateMethodNames,function(i,name){
        $.fn[name] = $.wraps.wrapper_every_act(eventer[name],eventer);
    });


    /*
    $.fn.on = $.wraps.wrapper_every_act(eventer.on, eventer);

    $.fn.off = $.wraps.wrapper_every_act(eventer.off, eventer);

    $.fn.trigger = $.wraps.wrapper_every_act(eventer.trigger, eventer);

    ('focusin focusout focus blur load resize scroll unload click dblclick ' +
        'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
        'change select keydown keypress keyup error transitionEnd').split(' ').forEach(function(event) {
        $.fn[event] = $.wraps.wrapper_every_act(eventer[event],eventer);
    });

    $.fn.one = function(event, selector, data, callback) {
        if (!langx.isString(selector) && !langx.isFunction(callback)) {
            callback = data;
            data = selector;
            selector = null;
        }

        if (langx.isFunction(data)) {
            callback = data;
            data = null;
        }

        return this.on(event, selector, data, callback, 1)
    }; 
    */

    $.ready = eventer.ready;

    return eventer;
});
define('skylark-domx-eventer', ['skylark-domx-eventer/main'], function (main) { return main; });

define('skylark-domx/eventer',[
    "skylark-domx-eventer"
], function( eventer) {
 
    return eventer;
});
define('skylark-domx/finder',[
    "skylark-domx-finder"
], function( finder) {

    return finder;
});
define('skylark-domx-fx/fx',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {

    function fx() {
        return fx;
    }

    langx.mixin(fx, {
        off: false,
        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        }
    });

    return skylark.attach("domx.fx", fx);
});
define('skylark-domx-geom/geom',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-styler"
], function(skylark, langx, noder, styler) {
    var rootNodeRE = /^(?:body|html)$/i,
        px = langx.toPixel,
        offsetParent = noder.offsetParent,
        cachedScrollbarWidth;

    function scrollbarWidth() {
        if (cachedScrollbarWidth !== undefined) {
            return cachedScrollbarWidth;
        }
        var w1, w2,
            div = noder.createFragment("<div style=" +
                "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
                "<div style='height:300px;width:auto;'></div></div>")[0],
            innerDiv = div.childNodes[0];

        noder.append(document.body, div);

        w1 = innerDiv.offsetWidth;

        styler.css(div, "overflow", "scroll");

        w2 = innerDiv.offsetWidth;

        if (w1 === w2) {
            w2 = div[0].clientWidth;
        }

        noder.remove(div);

        return (cachedScrollbarWidth = w1 - w2);
    }

    
    /*
     * Get the widths of each border of the specified element.
     * @param {HTMLElement} elm
     */
    function borderExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }        var s = getComputedStyle(elm);
        return {
            left: px(s.borderLeftWidth, elm),
            top: px(s.borderTopWidth, elm),
            right: px(s.borderRightWidth, elm),
            bottom: px(s.borderBottomWidth, elm)
        }
    }

    //viewport coordinate
    /*
     * Get or set the viewport position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingPosition(elm, coords) {
        if (coords === undefined) {
            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top,
                left: coords.left - parentOffset.left - mex.left - pbex.left
            });
            return this;
        }
    }

    /*
     * Get or set the viewport rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingRect(elm, coords) {
        if (coords === undefined) {
            if (elm == window || elm == document.documentElement || elm == document.body){
                return {
                    top : 0,
                    left : 0,
                    bottom : window.innerHeight,
                    right : window.innerWidth,
                    height : window.innerHeight,
                    width : window.innerWidth
                };
            } else if (elm.getBoundingClientRect) {
                return elm.getBoundingClientRect();
            }
        } else {
            boundingPosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the height of the specified element client box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function clientHeight(elm, value) {
        if (value == undefined) {
            return clientSize(elm).height;
        } else {
            return clientSize(elm, {
                height: value
            });
        }
    }

    /*
     * Get or set the size of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientSize(elm, dimension) {
        if (dimension == undefined) {
            return {
                width: elm.clientWidth,
                height: elm.clientHeight
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width - pex.left - pex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height - pex.top - pex.bottom;
                }
            } else {
                var bex = borderExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width + bex.left + bex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height + bex.top + bex.bottom;
                }

            }
            styler.css(elm, props);
            return this;
        }
        return {
            width: elm.clientWidth,
            height: elm.clientHeight
        };
    }

    /*
     * Get or set the width of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientWidth(elm, value) {
        if (value == undefined) {
            return clientSize(elm).width;
        } else {
            clientSize(elm, {
                width: value
            });
            return this;
        }
    }

    /*
     * Get the rect of the specified element content box.
     * @param {HTMLElement} elm
     */
    function contentRect(elm) {
        var cs = clientSize(elm),
            pex = paddingExtents(elm);


        //// On Opera, offsetLeft includes the parent's border
        //if(has("opera")){
        //    pe.l += be.l;
        //    pe.t += be.t;
        //}
        return {
            left: pex.left,
            top: pex.top,
            width: cs.width - pex.left - pex.right,
            height: cs.height - pex.top - pex.bottom
        };
    }

    /*
     * Get the document size.
     * @param {HTMLDocument} doc
     */
    function getDocumentSize(doc) {
        var documentElement = doc.documentElement,
            body = doc.body,
            max = Math.max,
            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),
            clientWidth = max(documentElement.clientWidth, body.clientWidth),
            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),
            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),
            clientHeight = max(documentElement.clientHeight, body.clientHeight),
            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);

        return {
            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
        };
    }

    /*
     * Get the document size.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function height(elm, value) {
        if (value == undefined) {
            return size(elm).height;
        } else {
            size(elm, {
                height: value
            });
            return this;
        }
    }

    /*
     * Get the widths of each margin of the specified element.
     * @param {HTMLElement} elm
     */
    function marginExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.marginLeft),
            top: px(s.marginTop),
            right: px(s.marginRight),
            bottom: px(s.marginBottom),
        }
    }


    function marginRect(elm) {
        var obj = relativeRect(elm),
            me = marginExtents(elm);

        return {
            left: obj.left,
            top: obj.top,
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }


    function marginSize(elm) {
        var obj = size(elm),
            me = marginExtents(elm);

        return {
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }

    /*
     * Get the widths of each padding of the specified element.
     * @param {HTMLElement} elm
     */
    function paddingExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.paddingLeft),
            top: px(s.paddingTop),
            right: px(s.paddingRight),
            bottom: px(s.paddingBottom),
        }
    }

    /*
     * Get or set the document position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    //coordinate to the document
    function pagePosition(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect(),
                w = elm.ownerDocument.defaultView;
            return {
                left: obj.left + w.pageXOffset,
                top: obj.top + w.pageYOffset
            }
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = pagePosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top,
                left: coords.left - parentOffset.left - mex.left - pbex.left
            });
            return this;
        }
    }

    /*
     * Get or set the document rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function pageRect(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect(),
                w = elm.ownerDocument.defaultView;
            return {
                left: obj.left + w.pageXOffset,
                top: obj.top + w.pageYOffset,
                width: Math.round(obj.width),
                height: Math.round(obj.height)
            }
        } else {
            pagePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the position of the specified element border box , relative to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    // coordinate relative to it's parent
    function relativePosition(elm, coords) {
        if (coords == undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingPosition(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top - mex.top,
                left: offset.left - parentOffset.left - pbex.left - mex.left
            }
        } else {
            var props = {
                top: coords.top,
                left: coords.left
            }

            if (styler.css(elm, "position") == "static") {
                props['position'] = "relative";
            }
            styler.css(elm, props);
            return this;
        }
    }

    /*
     * Get or set the rect of the specified element border box , relatived to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function relativeRect(elm, coords) {
        if (coords === undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingRect(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top, // - mex.top,
                left: offset.left - parentOffset.left - pbex.left, // - mex.left,
                width: offset.width,
                height: offset.height
            }
        } else {
            relativePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }
    /*
     * Scroll the specified element into view.
     * @param {HTMLElement} elm
     * @param {} align
     */
    function scrollIntoView(elm, align) {
        function getOffset(elm, rootElm) {
            var x, y, parent = elm;

            x = y = 0;
            while (parent && parent != rootElm && parent.nodeType) {
                x += parent.offsetLeft || 0;
                y += parent.offsetTop || 0;
                parent = parent.offsetParent;
            }

            return { x: x, y: y };
        }

        var parentElm = elm.parentNode;
        var x, y, width, height, parentWidth, parentHeight;
        var pos = getOffset(elm, parentElm);

        x = pos.x;
        y = pos.y;
        width = elm.offsetWidth;
        height = elm.offsetHeight;
        parentWidth = parentElm.clientWidth;
        parentHeight = parentElm.clientHeight;

        if (align == "end") {
            x -= parentWidth - width;
            y -= parentHeight - height;
        } else if (align == "center") {
            x -= (parentWidth / 2) - (width / 2);
            y -= (parentHeight / 2) - (height / 2);
        }

        parentElm.scrollLeft = x;
        parentElm.scrollTop = y;

        return this;
    }
    /*
     * Get or set the current horizontal position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollLeft(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        }
        var hasScrollLeft = "scrollLeft" in elm;
        if (value === undefined) {
            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset
        } else {
            if (hasScrollLeft) {
                elm.scrollLeft = value;
            } else {
                elm.scrollTo(value, elm.scrollY);
            }
            return this;
        }
    }
    /*
     * Get or the current vertical position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollTop(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        }
        var hasScrollTop = "scrollTop" in elm;

        if (value === undefined) {
            return hasScrollTop ? elm.scrollTop : elm.pageYOffset
        } else {
            if (hasScrollTop) {
                elm.scrollTop = value;
            } else {
                elm.scrollTo(elm.scrollX, value);
            }
            return this;
        }
    }

    function scrollBy(elm, x, y) {
        elm.scrollLeft += x;
        elm.scrollTop += y;
    }


    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject}dimension
     */
    function size(elm, dimension) {
        if (dimension == undefined) {
            if (langx.isWindow(elm)) {
                return {
                    width: elm.innerWidth,
                    height: elm.innerHeight
                }

            } else if (langx.isDocument(elm)) {
                return getDocumentSize(document);
            } else {
                return {
                    width: elm.offsetWidth,
                    height: elm.offsetHeight
                }
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm),
                    bex = borderExtents(elm);

                if (props.width !== undefined && props.width !== "" && props.width !== null) {
                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;
                }

                if (props.height !== undefined && props.height !== "" && props.height !== null) {
                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;
                }
            }
            styler.css(elm, props);
            return this;
        }
    }
    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function width(elm, value) {
        if (value == undefined) {
            return size(elm).width;
        } else {
            size(elm, {
                width: value
            });
            return this;
        }
    }

    function testAxis(elm) {
       
        var top = elm.offsetTop;
        var left = elm.offsetLeft;
        var width = elm.offsetWidth;
        var height = elm.offsetHeight;

        while(elm.offsetParent) {
            elm = elm.offsetParent;
            top += elm.offsetTop;
            left += elm.offsetLeft;
        }

        var result = {x: 0, y: 0};

        //Over the top of the window
        if(top < window.pageYOffset) {
            result.y = top - window.pageYOffset;
        }
        //Bellow the window
        else if((top + height) > (window.pageYOffset + window.innerHeight))
        {
            result.y = (top + height) - (window.pageYOffset + window.innerHeight);
        }

        //Left to the window
        if(left < window.pageXOffset) {
            result.x = left - window.pageXOffset;
        }
        //Right to the window
        else if((left + width) > (window.pageXOffset + window.innerWidth))
        {
            result.x = (left + width) - (window.pageXOffset + window.innerWidth);
        }

        return result;
    };    

    function geom() {
        return geom;
    }

    langx.mixin(geom, {
        borderExtents: borderExtents,
        //viewport coordinate
        boundingPosition: boundingPosition,

        boundingRect: boundingRect,

        clientHeight: clientHeight,

        clientSize: clientSize,

        clientWidth: clientWidth,

        contentRect: contentRect,

        getDocumentSize: getDocumentSize,

        height: height,

        marginExtents: marginExtents,

        marginRect: marginRect,

        marginSize: marginSize,

        offsetParent: offsetParent,

        paddingExtents: paddingExtents,

        //coordinate to the document
        pagePosition: pagePosition,

        pageRect: pageRect,

        // coordinate relative to it's parent
        relativePosition: relativePosition,

        relativeRect: relativeRect,

        scrollbarWidth: scrollbarWidth,

        scrollIntoView: scrollIntoView,

        scrollLeft: scrollLeft,

        scrollTop: scrollTop,

        scrollBy,
            
        size: size,

        testAxis,

        width: width
    });

    ( function() {
        var max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/;

        function getOffsets( offsets, width, height ) {
            return [
                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
            ];
        }

        function parseCss( element, property ) {
            return parseInt( styler.css( element, property ), 10 ) || 0;
        }

        function getDimensions( raw ) {
            if ( raw.nodeType === 9 ) {
                return {
                    size: size(raw),
                    offset: { top: 0, left: 0 }
                };
            }
            if ( noder.isWindow( raw ) ) {
                return {
                    size: size(raw),
                    offset: { 
                        top: scrollTop(raw), 
                        left: scrollLeft(raw) 
                    }
                };
            }
            if ( raw.preventDefault ) {
                return {
                    size : {
                        width: 0,
                        height: 0
                    },
                    offset: { 
                        top: raw.pageY, 
                        left: raw.pageX 
                    }
                };
            }
            return {
                size: size(raw),
                offset: pagePosition(raw)
            };
        }

        function getScrollInfo( within ) {
            var overflowX = within.isWindow || within.isDocument ? "" :
                    styler.css(within.element,"overflow-x" ),
                overflowY = within.isWindow || within.isDocument ? "" :
                    styler.css(within.element,"overflow-y" ),
                hasOverflowX = overflowX === "scroll" ||
                    ( overflowX === "auto" && within.width < scrollWidth(within.element) ),
                hasOverflowY = overflowY === "scroll" ||
                    ( overflowY === "auto" && within.height < scrollHeight(within.element));
            return {
                width: hasOverflowY ? scrollbarWidth() : 0,
                height: hasOverflowX ? scrollbarWidth() : 0
            };
        }

        function getWithinInfo( element ) {
            var withinElement = element || window,
                isWindow = noder.isWindow( withinElement),
                isDocument = !!withinElement && withinElement.nodeType === 9,
                hasOffset = !isWindow && !isDocument,
                msize = marginSize(withinElement);
            return {
                element: withinElement,
                isWindow: isWindow,
                isDocument: isDocument,
                offset: hasOffset ? pagePosition(element) : { left: 0, top: 0 },
                scrollLeft: scrollLeft(withinElement),
                scrollTop: scrollTop(withinElement),
                width: msize.width,
                height: msize.height
            };
        }

        function posit(elm,options ) {
            // Make a copy, we don't want to modify arguments
            options = langx.extend( {}, options );

            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                target = options.of,
                within = getWithinInfo( options.within ),
                scrollInfo = getScrollInfo( within ),
                collision = ( options.collision || "flip" ).split( " " ),
                offsets = {};

            dimensions = getDimensions( target );
            if ( target.preventDefault ) {

                // Force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.size.width;
            targetHeight = dimensions.size.height;
            targetOffset = dimensions.offset;

            // Clone to reuse original targetOffset later
            basePosition = langx.extend( {}, targetOffset );

            // Force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            langx.each( [ "my", "at" ], function() {
                var pos = ( options[ this ] || "" ).split( " " ),
                    horizontalOffset,
                    verticalOffset;

                if ( pos.length === 1 ) {
                    pos = rhorizontal.test( pos[ 0 ] ) ?
                        pos.concat( [ "center" ] ) :
                        rvertical.test( pos[ 0 ] ) ?
                            [ "center" ].concat( pos ) :
                            [ "center", "center" ];
                }
                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

                // Calculate offsets
                horizontalOffset = roffset.exec( pos[ 0 ] );
                verticalOffset = roffset.exec( pos[ 1 ] );
                offsets[ this ] = [
                    horizontalOffset ? horizontalOffset[ 0 ] : 0,
                    verticalOffset ? verticalOffset[ 0 ] : 0
                ];

                // Reduce to just the positions without the offsets
                options[ this ] = [
                    rposition.exec( pos[ 0 ] )[ 0 ],
                    rposition.exec( pos[ 1 ] )[ 0 ]
                ];
            } );

            // Normalize collision option
            if ( collision.length === 1 ) {
                collision[ 1 ] = collision[ 0 ];
            }

            if ( options.at[ 0 ] === "right" ) {
                basePosition.left += targetWidth;
            } else if ( options.at[ 0 ] === "center" ) {
                basePosition.left += targetWidth / 2;
            }

            if ( options.at[ 1 ] === "bottom" ) {
                basePosition.top += targetHeight;
            } else if ( options.at[ 1 ] === "center" ) {
                basePosition.top += targetHeight / 2;
            }

            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
            basePosition.left += atOffset[ 0 ];
            basePosition.top += atOffset[ 1 ];

            return ( function(elem) {
                var collisionPosition, using,
                    msize = marginSize(elem),
                    elemWidth = msize.width,
                    elemHeight = msize.height,
                    marginLeft = parseCss( elem, "marginLeft" ),
                    marginTop = parseCss( elem, "marginTop" ),
                    collisionWidth = elemWidth + marginLeft + parseCss( elem, "marginRight" ) +
                        scrollInfo.width,
                    collisionHeight = elemHeight + marginTop + parseCss( elem, "marginBottom" ) +
                        scrollInfo.height,
                    position = langx.extend( {}, basePosition ),
                    myOffset = getOffsets( offsets.my, msize.width, msize.height);

                if ( options.my[ 0 ] === "right" ) {
                    position.left -= elemWidth;
                } else if ( options.my[ 0 ] === "center" ) {
                    position.left -= elemWidth / 2;
                }

                if ( options.my[ 1 ] === "bottom" ) {
                    position.top -= elemHeight;
                } else if ( options.my[ 1 ] === "center" ) {
                    position.top -= elemHeight / 2;
                }

                position.left += myOffset[ 0 ];
                position.top += myOffset[ 1 ];

                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };

                langx.each( [ "left", "top" ], function( i, dir ) {
                    if ( positions[ collision[ i ] ] ) {
                        positions[ collision[ i ] ][ dir ]( position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        } );
                    }
                } );

                if ( options.using ) {

                    // Adds feedback as second argument to using callback, if present
                    using = function( props ) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                            feedback.horizontal = "center";
                        }
                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                            feedback.vertical = "middle";
                        }
                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call( this, props, feedback );
                    };
                }

                pagePosition(elem, langx.extend( position, { using: using } ));
            })(elm);
        }

        var positions = {
            fit: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                        newOverRight;

                    // Element is wider than within
                    if ( data.collisionWidth > outerWidth ) {

                        // Element is initially over the left side of within
                        if ( overLeft > 0 && overRight <= 0 ) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                                withinOffset;
                            position.left += overLeft - newOverRight;

                        // Element is initially over right side of within
                        } else if ( overRight > 0 && overLeft <= 0 ) {
                            position.left = withinOffset;

                        // Element is initially over both left and right sides of within
                        } else {
                            if ( overLeft > overRight ) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }

                    // Too far left -> align with left edge
                    } else if ( overLeft > 0 ) {
                        position.left += overLeft;

                    // Too far right -> align with right edge
                    } else if ( overRight > 0 ) {
                        position.left -= overRight;

                    // Adjust based on position and margin
                    } else {
                        position.left = max( position.left - collisionPosLeft, position.left );
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                        newOverBottom;

                    // Element is taller than within
                    if ( data.collisionHeight > outerHeight ) {

                        // Element is initially over the top of within
                        if ( overTop > 0 && overBottom <= 0 ) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                                withinOffset;
                            position.top += overTop - newOverBottom;

                        // Element is initially over bottom of within
                        } else if ( overBottom > 0 && overTop <= 0 ) {
                            position.top = withinOffset;

                        // Element is initially over both top and bottom of within
                        } else {
                            if ( overTop > overBottom ) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }

                    // Too far up -> align with top
                    } else if ( overTop > 0 ) {
                        position.top += overTop;

                    // Too far down -> align with bottom edge
                    } else if ( overBottom > 0 ) {
                        position.top -= overBottom;

                    // Adjust based on position and margin
                    } else {
                        position.top = max( position.top - collisionPosTop, position.top );
                    }
                }
            },
            flip: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                        myOffset = data.my[ 0 ] === "left" ?
                            -data.elemWidth :
                            data.my[ 0 ] === "right" ?
                                data.elemWidth :
                                0,
                        atOffset = data.at[ 0 ] === "left" ?
                            data.targetWidth :
                            data.at[ 0 ] === "right" ?
                                -data.targetWidth :
                                0,
                        offset = -2 * data.offset[ 0 ],
                        newOverRight,
                        newOverLeft;

                    if ( overLeft < 0 ) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
                            outerWidth - withinOffset;
                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if ( overRight > 0 ) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
                            atOffset + offset - offsetLeft;
                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                        top = data.my[ 1 ] === "top",
                        myOffset = top ?
                            -data.elemHeight :
                            data.my[ 1 ] === "bottom" ?
                                data.elemHeight :
                                0,
                        atOffset = data.at[ 1 ] === "top" ?
                            data.targetHeight :
                            data.at[ 1 ] === "bottom" ?
                                -data.targetHeight :
                                0,
                        offset = -2 * data.offset[ 1 ],
                        newOverTop,
                        newOverBottom;
                    if ( overTop < 0 ) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
                            outerHeight - withinOffset;
                        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if ( overBottom > 0 ) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
                            offset - offsetTop;
                        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    positions.flip.left.apply( this, arguments );
                    positions.fit.left.apply( this, arguments );
                },
                top: function() {
                    positions.flip.top.apply( this, arguments );
                    positions.fit.top.apply( this, arguments );
                }
            }
        };

        geom.posit = posit;
    })();

    return skylark.attach("domx.geom", geom);
});
define('skylark-domx-geom/main',[
    "skylark-langx/langx",
    "./geom",
    "skylark-domx-velm",
    "skylark-domx-query"        
],function(langx,geom,velm,$){
   // from ./geom
    velm.delegate([
        "borderExtents",
        "boundingPosition",
        "boundingRect",
        "clientHeight",
        "clientSize",
        "clientWidth",
        "contentRect",
        "height",
        "marginExtents",
        "marginRect",
        "marginSize",
        "offsetParent",
        "paddingExtents",
        "pagePosition",
        "pageRect",
        "relativePosition",
        "relativeRect",
        "scrollIntoView",
        "scrollLeft",
        "scrollTop",
        "size",
        "width"
    ], geom);

    $.fn.offset = $.wraps.wrapper_value(geom.pagePosition, geom, geom.pagePosition);

    $.fn.scrollTop = $.wraps.wrapper_value(geom.scrollTop, geom);

    $.fn.scrollLeft = $.wraps.wrapper_value(geom.scrollLeft, geom);

    $.fn.position =  function(options) {
        if (!this.length) {
            return this;
        }

        if (options) {
            if (options.of && options.of.length) {
                options = langx.clone(options);
                options.of = options.of[0];
            }
            return this.each( function() {
                geom.posit(this,options);
            });
        } else {
            var elem = this[0];

            return geom.relativePosition(elem);

        }             
    };

    $.fn.offsetParent = $.wraps.wrapper_map(geom.offsetParent, geom);


    $.fn.size = $.wraps.wrapper_value(geom.size, geom);

    $.fn.width = $.wraps.wrapper_value(geom.width, geom, geom.width);

    $.fn.height = $.wraps.wrapper_value(geom.height, geom, geom.height);

    $.fn.clientSize = $.wraps.wrapper_value(geom.clientSize, geom.clientSize);
    
    ['width', 'height'].forEach(function(dimension) {
        var offset, Dimension = dimension.replace(/./, function(m) {
            return m[0].toUpperCase()
        });

        $.fn['outer' + Dimension] = function(margin, value) {
            if (arguments.length) {
                if (typeof margin !== 'boolean') {
                    value = margin;
                    margin = false;
                }
            } else {
                margin = false;
                value = undefined;
            }

            if (value === undefined) {
                var el = this[0];
                if (!el) {
                    return undefined;
                }
                var cb = geom.size(el);
                if (margin) {
                    var me = geom.marginExtents(el);
                    cb.width = cb.width + me.left + me.right;
                    cb.height = cb.height + me.top + me.bottom;
                }
                return dimension === "width" ? cb.width : cb.height;
            } else {
                return this.each(function(idx, el) {
                    var mb = {};
                    var me = geom.marginExtents(el);
                    if (dimension === "width") {
                        mb.width = value;
                        if (margin) {
                            mb.width = mb.width - me.left - me.right
                        }
                    } else {
                        mb.height = value;
                        if (margin) {
                            mb.height = mb.height - me.top - me.bottom;
                        }
                    }
                    geom.size(el, mb);
                })

            }
        };
    })

    $.fn.innerWidth = $.wraps.wrapper_value(geom.clientWidth, geom, geom.clientWidth);

    $.fn.innerHeight = $.wraps.wrapper_value(geom.clientHeight, geom, geom.clientHeight);

    return geom;
});
define('skylark-domx-geom', ['skylark-domx-geom/main'], function (main) { return main; });

define('skylark-domx-fx/animate',[
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "./fx"
], function(langx, browser, noder, geom, styler, eventer,fx) {

    var animationName,
        animationDuration,
        animationTiming,
        animationDelay,
        transitionProperty,
        transitionDuration,
        transitionTiming,
        transitionDelay,

        animationEnd = browser.normalizeCssEvent('AnimationEnd'),
        transitionEnd = browser.normalizeCssEvent('TransitionEnd'),

        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,
        transform = browser.css3PropPrefix + "transform",
        cssReset = {};


    cssReset[animationName = browser.normalizeCssProperty("animation-name")] =
        cssReset[animationDuration = browser.normalizeCssProperty("animation-duration")] =
        cssReset[animationDelay = browser.normalizeCssProperty("animation-delay")] =
        cssReset[animationTiming = browser.normalizeCssProperty("animation-timing-function")] = "";

    cssReset[transitionProperty = browser.normalizeCssProperty("transition-property")] =
        cssReset[transitionDuration = browser.normalizeCssProperty("transition-duration")] =
        cssReset[transitionDelay = browser.normalizeCssProperty("transition-delay")] =
        cssReset[transitionTiming = browser.normalizeCssProperty("transition-timing-function")] = "";

    /*   
     * Perform a custom animation of a set of CSS properties.
     * @param {Object} elm  
     * @param {Number or String} properties
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function animate(elm, properties, duration, ease, callback, delay) {
        var key,
            cssValues = {},
            cssProperties = [],
            transforms = "",
            that = this,
            endEvent,
            wrappedCallback,
            fired = false,
            hasScrollTop = false,
            resetClipAuto = false;

        if (langx.isPlainObject(duration)) {
            ease = duration.easing;
            callback = duration.complete;
            delay = duration.delay;
            duration = duration.duration;
        }

        if (langx.isString(duration)) {
            duration = fx.speeds[duration];
        }
        if (duration === undefined) {
            duration = fx.speeds.normal;
        }
        duration = duration / 1000;
        if (fx.off) {
            duration = 0;
        }

        if (langx.isFunction(ease)) {
            callback = ease;
            eace = "swing";
        } else {
            ease = ease || "swing";
        }

        if (delay) {
            delay = delay / 1000;
        } else {
            delay = 0;
        }

        if (langx.isString(properties)) {
            // keyframe animation
            cssValues[animationName] = properties;
            cssValues[animationDuration] = duration + "s";
            cssValues[animationTiming] = ease;
            endEvent = animationEnd;
        } else {
            // CSS transitions
            for (key in properties) {
                var v = properties[key];
                if (supportedTransforms.test(key)) {
                    transforms += key + "(" + v + ") ";
                } else {
                    if (key === "scrollTop") {
                        hasScrollTop = true;
                    }
                    if (key == "clip" && langx.isPlainObject(v)) {
                        cssValues[key] = "rect(" + v.top+"px,"+ v.right +"px,"+ v.bottom +"px,"+ v.left+"px)";
                        if (styler.css(elm,"clip") == "auto") {
                            var size = geom.size(elm);
                            styler.css(elm,"clip","rect("+"0px,"+ size.width +"px,"+ size.height +"px,"+"0px)");  
                            resetClipAuto = true;
                        }

                    } else {
                        cssValues[key] = v;
                    }
                    cssProperties.push(langx.dasherize(key));
                }
            }
            endEvent = transitionEnd;
        }

        if (transforms) {
            cssValues[transform] = transforms;
            cssProperties.push(transform);
        }

        if (duration > 0 && langx.isPlainObject(properties)) {
            cssValues[transitionProperty] = cssProperties.join(", ");
            cssValues[transitionDuration] = duration + "s";
            cssValues[transitionDelay] = delay + "s";
            cssValues[transitionTiming] = ease;
        }

        wrappedCallback = function(event) {
            fired = true;
            if (event) {
                if (event.target !== event.currentTarget) {
                    return // makes sure the event didn't bubble from "below"
                }
                eventer.off(event.target, endEvent, wrappedCallback)
            } else {
                eventer.off(elm, animationEnd, wrappedCallback) // triggered by setTimeout
            }
            styler.css(elm, cssReset);
            if (resetClipAuto) {
 //               styler.css(elm,"clip","auto");
            }
            callback && callback.call(this);
        };

        if (duration > 0) {
            eventer.on(elm, endEvent, wrappedCallback);
            // transitionEnd is not always firing on older Android phones
            // so make sure it gets fired
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, ((duration + delay) * 1000) + 25)();
        }

        // trigger page reflow so new elements can animate
        elm.clientLeft;

        styler.css(elm, cssValues);

        if (duration <= 0) {
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, 0)();
        }

        if (hasScrollTop) {
            scrollToTop(elm, properties["scrollTop"], duration, callback);
        }

        return this;
    }

    return fx.animate = animate;

});
define('skylark-domx-fx/bounce',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./fx",
    "./animate"
],function(langx,geom,styler,fx,animate) {

    function bounce(elm, options, done ) {
        var upAnim, downAnim, refValue,
            // Defaults:
            mode = options.mode,
            hide = mode === "hide",
            show = mode === "show",
            direction = options.direction || "up",
            start,
            distance = options.distance,
            times = options.times || 5,

            // Number of internal animations
            anims = times * 2 + ( show || hide ? 1 : 0 ),
            speed = options.duration / anims,
            easing = options.easing,

            // Utility:
            ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
            motion = ( direction === "up" || direction === "left" ),
            i = 0;

        //createPlaceholder(elm);

        var Deferred = langx.Deferred;
        var funcs = [];

        refValue = styler.css(elm,ref );

        // Default distance for the BIGGEST bounce is the outer Distance / 3
        if ( !distance ) {
            var msize = geom.size(elm);
            distance = (ref === "top" ? msize.height : msize.width) / 3;
        }

        start = geom.relativePosition(elm)[ref];

        if ( show ) {
            downAnim = { opacity: 1 };
            downAnim[ ref ] = refValue;

            // If we are showing, force opacity 0 and set the initial position
            // then do the "first" animation
            styler.css(elm, "opacity", 0 );
            styler.css(elm, ref, start + (motion ? -distance * 2 : distance * 2 ));

            funcs.push(doAnimate(elm,downAnim, speed, easing));
        }

        // Start at the smallest distance if we are hiding
        if ( hide ) {
            distance = distance / Math.pow( 2, times - 1 );
        }

        downAnim = {};
        downAnim[ ref ] = refValue;


        function doAnimate(elm,properties, duration, easing) {
            return function() {
                var d = new Deferred();

                animate(elm,properties, duration, easing ,function(){
                    d.resolve();
                });
                return d.promise;

            }
        }

        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
        for ( ; i < times; i++ ) {
            upAnim = {};
            upAnim[ ref ] = start + ( motion ? -distance : distance) ;

            funcs.push(doAnimate(elm,upAnim, speed, easing));

            funcs.push(doAnimate(elm,downAnim, speed, easing));

            distance = hide ? distance * 2 : distance / 2;
        }

        // Last Bounce when Hiding
        if ( hide ) {
            upAnim = { opacity: 0 };
            upAnim[ ref ] = start + ( motion ? -1 * distance : distance) ;

            funcs.push(doAnimate(elm,upAnim, speed, easing ));
        }

        funcs.push(done);
        funcs.reduce(function(prev, curr, index, array) {
            return prev.then(curr);
        }, Deferred.resolve());

        return this;
    } 

    return fx.bounce = bounce;
});
define('skylark-domx-fx/emulateTransitionEnd',[
    "skylark-langx/langx",
    "skylark-domx-eventer",
    "./fx"
],function(langx,eventer,fx) {
    
    function emulateTransitionEnd(elm,duration) {
        var called = false;
        eventer.one(elm,'transitionEnd', function () { 
            called = true;
        })
        var callback = function () { 
            if (!called) {
                eventer.trigger(elm,browser.support.transition.end) 
            }
        };
        setTimeout(callback, duration);
        
        return this;
    } 



    return fx.emulateTransitionEnd = emulateTransitionEnd;
});
define('skylark-domx-fx/show',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./fx",
    "./animate"
],function(langx,styler,fx,animate) {
    /*   
     * Display an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function show(elm, speed, callback) {
        styler.show(elm);
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            styler.css(elm, "opacity", 0)
            animate(elm, { opacity: 1, scale: "1,1" }, speed, callback);
        }
        return this;
    }

    return fx.show = show;
});
define('skylark-domx-fx/hide',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./fx",
    "./animate"
],function(langx,styler,fx,animate) {
    /*   
     * Hide an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function hide(elm, speed, callback) {
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            animate(elm, { opacity: 0, scale: "0,0" }, speed, function() {
                styler.hide(elm);
                if (callback) {
                    callback.call(elm);
                }
            });
        } else {
            styler.hide(elm);
        }
        return this;
    }

    return fx.hide = hide;
});
define('skylark-domx-fx/explode',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "skylark-domx-geom",
    "skylark-domx-noder",
    "skylark-domx-query",
    "./fx",
    "./animate",
    "./show",
    "./hide"
],function(langx,styler,geom,noder,$,fx,animate,show,hide) {

    function explode( elm,options, done ) {

		// Show and then visibility:hidden the element before calculating offset
		styler.show(elm);
		styler.css(elm, "visibility", "hidden" );

		var i, j, left, top, mx, my,
			rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
			cells = rows,
			mode = options.mode,
			show = mode === "show",
			offset = geom.pagePosition(elm),

			// Width and height of a piece
			size = geom.marginSize(elm),
			width = Math.ceil( size.width / cells ),
			height = Math.ceil( size.height / rows ),
			pieces = [];

		// Children animate complete:
		function childComplete() {
			pieces.push( this );
			if ( pieces.length === rows * cells ) {
				animComplete();
			}
		}

		// Clone the element for each row and cell.
		for ( var i = 0; i < rows; i++ ) { // ===>
			top = offset.top + i * height;
			my = i - ( rows - 1 ) / 2;

			for ( j = 0; j < cells; j++ ) { // |||
				left = offset.left + j * width;
				mx = j - ( cells - 1 ) / 2;

				// Create a clone of the now hidden main element that will be absolute positioned
				// within a wrapper div off the -left and -top equal to size of our pieces
				$(elm)
					.clone()
					.appendTo( "body" )
					.wrap( "<div></div>" )
					.css( {
						position: "absolute",
						visibility: "visible",
						left: -j * width,
						top: -i * height
					} )

					// Select the wrapper - make it overflow: hidden and absolute positioned based on
					// where the original was located +left and +top equal to the size of pieces
					.parent()
						.addClass( options.explodeClass || "ui-effects-explode" )
						.css( {
							position: "absolute",
							overflow: "hidden",
							width: width,
							height: height,
							left: left + ( show ? mx * width : 0 ),
							top: top + ( show ? my * height : 0 ),
							opacity: show ? 0 : 1
						} )
						.animate( {
							left: left + ( show ? 0 : mx * width ),
							top: top + ( show ? 0 : my * height ),
							opacity: show ? 1 : 0
						}, options.duration || 500, options.easing, childComplete );
			}
		}

		function animComplete() {
			styler.css(elm, {
				visibility: "visible"
			} );
			$( pieces ).remove();
			done();
		}

		return this;
	}


	return fx.explode = explode;
});

define('skylark-domx-fx/fade',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./fx",
    "./animate"
],function(langx,styler,fx,animate) {
    /*   
     * Adjust the opacity of an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Number or String} opacity
     * @param {String} easing
     * @param {Function} callback
     */
    function fade(elm, opacity,options, callback) {
        if (langx.isFunction(options)) {
            callback = options;
            options = {};
        }
        options = options || {};
        
        animate(elm, { opacity: opacity }, options.duration, options.easing, callback);
        return this;
    }


    return fx.fade = fade;
});
define('skylark-domx-fx/fadeIn',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./fx",
    "./fade"
],function(langx,styler,fx,fadeTo) {
    /*   
     * Display an element by fading them to opaque.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeIn(elm, options, callback) {
        var target = styler.css(elm, "opacity");
        if (target > 0) {
            styler.css(elm, "opacity", 0);
        } else {
            target = 1;
        }
        styler.show(elm);

        fadeTo(elm,  target,options, callback);

        return this;
    }


    return fx.fadeIn = fadeIn;
});
define('skylark-domx-fx/fadeOut',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./fx",
    "./fade"
],function(langx,styler,fx,fadeTo) {
    /*   
     * Hide an element by fading them to transparent.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeOut(elm, options, callback) {

        function complete() {
            styler.css(elm,"opacity",opacity);
            styler.hide(elm);
            if (callback) {
                callback.call(elm);
            }
        }

        fadeTo(elm, 0,options,callback);

        return this;
    }

    return fx.fadeOut = fadeOut;
});
define('skylark-domx-fx/fadeToggle',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./fx",
    "./fadeIn",
    "./fadeOut"
],function(langx,styler,fx,fadeIn,fadeOut) {

    /*   
     * Display or hide an element by animating its opacity.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} ceasing
     * @param {Function} callback
     */
    function fadeToggle(elm, speed, easing, callback) {
        if (styler.isInvisible(elm)) {
            fadeIn(elm, speed, easing, callback);
        } else {
            fadeOut(elm, speed, easing, callback);
        }
        return this;
    }


    return fx.fadeToggle = fadeToggle;
});
define('skylark-domx-fx/pulsate',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./fx",
    "./animate"
],function(langx,geom,styler,fx,animate) {

	function pulsate(elm, options, done ) {
		var 
			mode = options.mode,
			show = mode === "show" || !mode,
			hide = mode === "hide",
			showhide = show || hide,

			// Showing or hiding leaves off the "last" animation
			anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
			duration = options.duration / anims,
			animateTo = 0,
			i = 1;

		if ( show || styler.isInvisible(elm) ) {
			styler.css(elm, "opacity", 0 );
			styler.show(elm);
			animateTo = 1;
		}

		// Anims - 1 opacity "toggles"

		var Deferred = langx.Deferred;
		var funcs = [];

		function doAnimate(elm,properties, duration, ease) {
			return function() {
				var d = new Deferred();

				animate( elm,properties, duration, ease ,function(){
					d.resolve();
				});
				return d.promise;

			}
		}


		for ( ; i < anims; i++ ) {
			funcs.push(doAnimate(elm,{ opacity: animateTo }, duration, options.easing ));
			animateTo = 1 - animateTo;
		}

	    funcs.push(doAnimate(elm,{ opacity: animateTo }, duration, options.easing ));

		funcs.push(done);
		funcs.reduce(function(prev, curr, index, array) {
	  		return prev.then(curr);
		}, Deferred.resolve());

		return this;

	}

	return fx.pulsate = pulsate;

});

define('skylark-domx-fx/shake',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "./fx",
    "./animate"
],function(langx,geom,styler,fx,animate) {
	function shake(elm, options, done ) {

		var i = 1,
			direction = options.direction || "left",
			distance = options.distance || 20,
			times = options.times || 3,
			anims = times * 2 + 1,
			speed = Math.round( options.duration / anims ),
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			positiveMotion = ( direction === "up" || direction === "left" ),
			animation0 = {},
			animation = {},
			animation1 = {},
			animation2 = {};

		var Deferred = langx.Deferred;
			start = geom.relativePosition(elm)[ref],
			funcs = [];

		function doAnimate(elm,properties, duration, ease) {
			return function() {
				var d = new Deferred();

				animate(elm, properties, duration, ease ,function(){
					d.resolve();
				});
				return d.promise;
			}
		}

		// Animation
		animation0[ ref ] = start;
		animation[ ref ] = start + ( positiveMotion ? -1 : 1 ) * distance;
		animation1[ ref ] = animation[ ref ] + ( positiveMotion ? 1 : -1 ) * distance * 2;
		animation2[ ref ] = animation1[ ref ] + ( positiveMotion ? -1 : 1 ) * distance * 2;

		// Animate
	    funcs.push(doAnimate(elm,animation, speed, options.easing ));

		// Shakes
		for ( ; i < times; i++ ) {
		    funcs.push(doAnimate(elm,animation1, speed, options.easing ));
		    funcs.push(doAnimate(elm,animation2, speed, options.easing ));
		}

	    funcs.push(doAnimate(elm,animation0, speed /2 , options.easing ));

		funcs.push(done);
		funcs.reduce(function(prev, curr, index, array) {
	  		return prev.then(curr);
		}, Deferred.resolve());

		return this;
	}

	return fx.shake = shake;

});

define('skylark-domx-fx/slide',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./fx",
    "./animate"
],function(langx,styler,fx,animate) {

    function slide(elm,options,callback ) {
    	if (langx.isFunction(options)) {
    		callback = options;
    		options = {};
    	}
    	options = options || {};
		var direction = options.direction || "down",
			isHide = ( direction === "up" || direction === "left" ),
			isVert = ( direction === "up" || direction === "down" ),
			duration = options.duration || fx.speeds.normal;


        // get the element position to restore it then
        var position = styler.css(elm, 'position');

        if (isHide) {
            // active the function only if the element is visible
        	if (styler.isInvisible(elm)) {
        		return this;
        	}
        } else {
	        // show element if it is hidden
	        styler.show(elm);        	
	        // place it so it displays as usually but hidden
	        styler.css(elm, {
	            position: 'absolute',
	            visibility: 'hidden'
	        });
        }



        if (isVert) { // up--down
	        // get naturally height, margin, padding
	        var marginTop = styler.css(elm, 'margin-top');
	        var marginBottom = styler.css(elm, 'margin-bottom');
	        var paddingTop = styler.css(elm, 'padding-top');
	        var paddingBottom = styler.css(elm, 'padding-bottom');
	        var height = styler.css(elm, 'height');

	        if (isHide) {  	// slideup
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                height: height,
	                marginTop: marginTop,
	                marginBottom: marginBottom,
	                paddingTop: paddingTop,
	                paddingBottom: paddingBottom
	            });

	            // animate element height, margin and padding to zero
	            animate(elm, {
	                height: 0,
	                marginTop: 0,
	                marginBottom: 0,
	                paddingTop: 0,
	                paddingBottom: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        height: height,
	                        marginTop: marginTop,
	                        marginBottom: marginBottom,
	                        paddingTop: paddingTop,
	                        paddingBottom: paddingBottom
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slidedown
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            height: 0,
		            marginTop: 0,
		            marginBottom: 0,
		            paddingTop: 0,
		            paddingBottom: 0
		        });

		        // animate to gotten height, margin and padding
		        animate(elm, {
		            height: height,
		            marginTop: marginTop,
		            marginBottom: marginBottom,
		            paddingTop: paddingTop,
		            paddingBottom: paddingBottom
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }

        } else { // left--right
	        // get naturally height, margin, padding
	        var marginLeft = styler.css(elm, 'margin-left');
	        var marginRight = styler.css(elm, 'margin-right');
	        var paddingLeft = styler.css(elm, 'padding-left');
	        var paddingRight = styler.css(elm, 'padding-right');
	        var width = styler.css(elm, 'width');

	        if (isHide) {  	// slideleft
	            // set initial css for animation
	            styler.css(elm, {
	                visibility: 'visible',
	                overflow: 'hidden',
	                width: width,
	                marginLeft: marginLeft,
	                marginRight: marginRight,
	                paddingLeft: paddingLeft,
	                paddingRight: paddingRight
	            });

	            // animate element height, margin and padding to zero
	            animate(elm, {
	                width: 0,
	                marginLeft: 0,
	                marginRight: 0,
	                paddingLeft: 0,
	                paddingRight: 0
	            }, {
	                // callback : restore the element position, height, margin and padding to original values
	                duration: duration,
	                queue: false,
	                complete: function() {
	                    styler.hide(elm);
	                    styler.css(elm, {
	                        visibility: 'visible',
	                        overflow: 'hidden',
	                        width: width,
	                        marginLeft: marginLeft,
	                        marginRight: marginRight,
	                        paddingLeft: paddingLeft,
	                        paddingRight: paddingRight
	                    });
	                    if (callback) {
	                        callback.apply(elm);
	                    }
	                }
	            });
	        } else {     	// slideright
		        // set initial css for animation
		        styler.css(elm, {
		            position: position,
		            visibility: 'visible',
		            overflow: 'hidden',
		            width: 0,
		            marginLeft: 0,
		            marginRight: 0,
		            paddingLeft: 0,
		            paddingRight: 0
		        });

		        // animate to gotten width, margin and padding
		        animate(elm, {
		            width: width,
		            marginLeft: marginLeft,
		            marginRight: marginRight,
		            paddingLeft: paddingLeft,
		            paddingRight: paddingRight
		        }, {
		            duration: duration,
		            complete: function() {
		                if (callback) {
		                    callback.apply(elm);
		                }
		            }
		        });

	        }       	
        }

        return this;
    }

    return fx.slide = slide;

});

define('skylark-domx-fx/slideDown',[
    "./fx",
    "./slide"
],function(fx,slide) {
    /*   
     * Display an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideDown(elm, duration, callback) {
        return slide(elm,{
            direction : "down",
            duration : duration
        },callback);
    }

    return fx.slideDown = slideDown;
});
define('skylark-domx-fx/slideUp',[
    "./fx",
    "./slide"
],function(fx,slide) {
    /*   
     * Hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideUp(elm, duration, callback) {
        return slide(elm,{
            direction : "up",
            duration : duration
        },callback);
    }



    return fx.slideUp = slideUp;
});
define('skylark-domx-fx/slideToggle',[
    "skylark-langx/langx",
    "skylark-domx-geom",
    "./fx",
    "./slideDown",
    "./slideUp"
],function(langx,geom,fx,slideDown,slideUp) {

    /*   
     * Display or hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideToggle(elm, duration, callback) {

        // if the element is hidden, slideDown !
        if (geom.height(elm) == 0) {
            slideDown(elm, duration, callback);
        }
        // if the element is visible, slideUp !
        else {
            slideUp(elm, duration, callback);
        }
        return this;
    }

    return fx.slideToggle = slideToggle;
});
define('skylark-domx-fx/throb',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "skylark-domx-noder",
    "./fx",
    "./animate"
],function(langx,styler,noder,fx,animate) {

    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};
        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "class": params.className || "throbber"
            }),
            //_overlay = overlay(throbber, {
            //    "class": 'overlay fade'
            //}),
            throb = noder.createElement("div", {
                "class": params.throb && params.throb.className || "throb"
            }),
            textNode = noder.createTextNode(text || ""),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };
        if (params.style) {
            styler.css(throbber,params.style);
        }
        throb.appendChild(textNode);
        throbber.appendChild(throb);
        elm.appendChild(throbber);
        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            remove: remove,
            update: update
        };
    }

    return fx.throb = throb;
});
define('skylark-domx-fx/toggle',[
    "skylark-langx/langx",
    "skylark-domx-styler",
    "./fx",
    "./show",
    "./hide"
],function(langx,styler,fx,show,hide) {
    /*   
     * Display or hide an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Function} callbacke
     */
    function toggle(elm, speed, callback) {
        if (styler.isInvisible(elm)) {
            show(elm, speed, callback);
        } else {
            hide(elm, speed, callback);
        }
        return this;
    }

    return fx.toggle = toggle;
});
define('skylark-domx-fx/main',[
	"./fx",
	"skylark-domx-velm",
	"skylark-domx-query",
    "./animate",
    "./bounce",
    "./emulateTransitionEnd",
    "./explode",
    "./fadeIn",
    "./fadeOut",
    "./fade",
    "./fadeToggle",
    "./hide",
    "./pulsate",
    "./shake",
    "./show",
    "./slide",
    "./slideDown",
    "./slideToggle",
    "./slideUp",
    "./throb",
    "./toggle"
],function(fx,velm,$){
    // from ./fx
    velm.delegate([
        "animate",
        "emulateTransitionEnd",
        "fadeIn",
        "fadeOut",
        "fade",
        "fadeToggle",
        "hide",
        "scrollToTop",
        "slideDown",
        "slideToggle",
        "slideUp",
        "show",
        "toggle"
    ], fx);

    $.fn.hide =  $.wraps.wrapper_every_act(fx.hide, fx);

    $.fn.animate = $.wraps.wrapper_every_act(fx.animate, fx);
    $.fn.emulateTransitionEnd = $.wraps.wrapper_every_act(fx.emulateTransitionEnd, fx);

    $.fn.show = $.wraps.wrapper_every_act(fx.show, fx);
    $.fn.hide = $.wraps.wrapper_every_act(fx.hide, fx);
    $.fn.toogle = $.wraps.wrapper_every_act(fx.toogle, fx);
    $.fn.fadeTo = $.wraps.wrapper_every_act(fx.fadeTo, fx);
    $.fn.fadeIn = $.wraps.wrapper_every_act(fx.fadeIn, fx);
    $.fn.fadeOut = $.wraps.wrapper_every_act(fx.fadeOut, fx);
    $.fn.fadeToggle = $.wraps.wrapper_every_act(fx.fadeToggle, fx);

    $.fn.slideDown = $.wraps.wrapper_every_act(fx.slideDown, fx);
    $.fn.slideToggle = $.wraps.wrapper_every_act(fx.slideToggle, fx);
    $.fn.slideUp = $.wraps.wrapper_every_act(fx.slideUp, fx);

	return fx;
});
define('skylark-domx-fx', ['skylark-domx-fx/main'], function (main) { return main; });

define('skylark-domx/fx',[
    "skylark-domx-fx"
], function( fx) {
    return fx;
});
define('skylark-domx/geom',[
    "skylark-domx-geom"
], function( geom) {

    return geom;
});
define('skylark-domx/noder',[
    "skylark-domx-noder"
], function( noder) {

    return noder;
});
define('skylark-domx-plugins/plugins',[
    "skylark-langx-ns",
    "skylark-langx-types",
    "skylark-langx-objects",
    "skylark-langx-funcs",
    "skylark-langx-events/Emitter",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-fx",
    "skylark-domx-query",
    "skylark-domx-velm"
], function(
    skylark,
    types,
    objects,
    funcs,
    Emitter, 
    noder, 
    datax, 
    eventer, 
    finder, 
    geom, 
    styler, 
    fx, 
    $, 
    elmx
) {
    "use strict";

    var slice = Array.prototype.slice,
        concat = Array.prototype.concat,
        pluginKlasses = {},
        shortcuts = {};

    /*
     * Create or get or destory a plugin instance assocated with the element.
     */
    function instantiate(elm,pluginName,options) {
        var pair = pluginName.split(":"),
            instanceDataName = pair[1];
        pluginName = pair[0];

        if (!instanceDataName) {
            instanceDataName = pluginName;
        }

        var pluginInstance = datax.data( elm, instanceDataName );

        if (options === "instance") {
            return pluginInstance;
        } else if (options === "destroy") {
            if (!pluginInstance) {
                throw new Error ("The plugin instance is not existed");
            }
            pluginInstance.destroy();
            //datax.removeData( elm, pluginName);
            pluginInstance = undefined;
        } else {
            if (!pluginInstance) {
                if (options !== undefined && typeof options !== "object") {
                    throw new Error ("The options must be a plain object");
                }
                var pluginKlass = pluginKlasses[pluginName]; 
                pluginInstance = new pluginKlass(elm,options);
                datax.data( elm, instanceDataName,pluginInstance );
            } else if (options) {
                pluginInstance.reset(options);
            }
        }

        return pluginInstance;
    }


    function shortcutter(pluginName,extfn) {
       /*
        * Create or get or destory a plugin instance assocated with the element,
        * and also you can execute the plugin method directory;
        */
        return function (elm,options) {
            var  plugin = instantiate(elm, pluginName,"instance");
            if ( options === "instance" ) {
              return plugin || null;
            }

            if (!plugin) {
                plugin = instantiate(elm, pluginName,typeof options == 'object' && options || {});
                if (typeof options != "string") {
                  return this;
                }
            } 
            if (options) {
                var args = slice.call(arguments,1); //2
                if (extfn) {
                    return extfn.apply(plugin,args);
                } else {
                    if (typeof options == 'string') {
                        var methodName = options;

                        if ( !plugin ) {
                            throw new Error( "cannot call methods on " + pluginName +
                                " prior to initialization; " +
                                "attempted to call method '" + methodName + "'" );
                        }

                        if ( !types.isFunction( plugin[ methodName ] ) || methodName.charAt( 0 ) === "_" ) {
                            throw new Error( "no such method '" + methodName + "' for " + pluginName +
                                " plugin instance" );
                        }

                        args = slice.call(args,1); //remove method name

                        var ret = plugin[methodName].apply(plugin,args);
                        if (ret == plugin) {
                          ret = undefined;
                        }

                        return ret;
                    }                
                }                
            }

        }

    }

    /*
     * Register a plugin type
     */
    function register( pluginKlass,shortcutName,instanceDataName,extfn) {
        var pluginName = pluginKlass.prototype.pluginName;
        
        pluginKlasses[pluginName] = pluginKlass;

        if (shortcutName) {
            if (instanceDataName && types.isFunction(instanceDataName)) {
                extfn = instanceDataName;
                instanceDataName = null;
            } 
            if (instanceDataName) {
                pluginName = pluginName + ":" + instanceDataName;
            }

            var shortcut = shortcuts[shortcutName] = shortcutter(pluginName,extfn);
                
            $.fn[shortcutName] = function(options) {
                var returnValue = this;

                if ( !this.length && options === "instance" ) {
                  returnValue = undefined;
                } else {
                  var args = slice.call(arguments);
                  this.each(function () {
                    var args2 = slice.call(args);
                    args2.unshift(this);
                    var  ret  = shortcut.apply(undefined,args2);
                    if (ret !== undefined) {
                        returnValue = ret;
                    }
                  });
                }

                return returnValue;
            };

            elmx.partial(shortcutName,function(options) {
                var  ret  = shortcut(this._elm,options);
                if (ret === undefined) {
                    ret = this;
                }
                return ret;
            });

        }
    }

 
    var Plugin =   Emitter.inherit({
        klassName: "Plugin",

        _construct : function(elm,options) {
           this._elm = elm;
           this._initOptions(options);
        },

        _initOptions : function(options) {
          var ctor = this.constructor,
              cache = ctor.cache = ctor.cache || {},
              defaults = cache.defaults;
          if (!defaults) {
            var  ctors = [];
            do {
              ctors.unshift(ctor);
              if (ctor === Plugin) {
                break;
              }
              ctor = ctor.superclass;
            } while (ctor);

            defaults = cache.defaults = {};
            for (var i=0;i<ctors.length;i++) {
              ctor = ctors[i];
              if (ctor.prototype.hasOwnProperty("options")) {
                objects.mixin(defaults,ctor.prototype.options,true);
              }
              if (ctor.hasOwnProperty("options")) {
                objects.mixin(defaults,ctor.options,true);
              }
            }
          }
          Object.defineProperty(this,"options",{
            value :objects.mixin({},defaults,options,true)
          });

          //return this.options = langx.mixin({},defaults,options);
          return this.options;
        },


        destroy: function() {

            this._destroy();

            // remove all event lisener
            this.unlistenTo();
            // remove data 
            datax.removeData(this._elm,this.pluginName );
        },

        _destroy: funcs.noop,

        _delay: function( handler, delay ) {
            function handlerProxy() {
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }
            var instance = this;
            return setTimeout( handlerProxy, delay || 0 );
        },

        elmx : function(elm) {
            elm = elm || this._elm;
            return elmx(elm);

        },

        $ : function(elm) {
            elm = elm || this._elm;
            return $(elm);
        },

        option: function( key, value ) {
            var options = key;
            var parts;
            var curOption;
            var i;

            if ( arguments.length === 0 ) {

                // Don't return a reference to the internal hash
                return objects.mixin( {}, this.options );
            }

            if ( typeof key === "string" ) {

                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split( "." );
                key = parts.shift();
                if ( parts.length ) {
                    curOption = options[ key ] = objects.mixin( {}, this.options[ key ] );
                    for ( i = 0; i < parts.length - 1; i++ ) {
                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                        curOption = curOption[ parts[ i ] ];
                    }
                    key = parts.pop();
                    if ( arguments.length === 1 ) {
                        return curOption[ key ] === undefined ? null : curOption[ key ];
                    }
                    curOption[ key ] = value;
                } else {
                    if ( arguments.length === 1 ) {
                        return this.options[ key ] === undefined ? null : this.options[ key ];
                    }
                    options[ key ] = value;
                }
            }

            this._setOptions( options );

            return this;
        },

        _setOptions: function( options ) {
            var key;

            for ( key in options ) {
                this._setOption( key, options[ key ] );
            }

            return this;
        },

        _setOption: function( key, value ) {

            this.options[ key ] = value;

            return this;
        },

        getUID : function (prefix) {
            prefix = prefix || "plugin";
            do prefix += ~~(Math.random() * 1000000)
            while (document.getElementById(prefix))
            return prefix;
        },

        elm : function() {
            return this._elm;
        }

    });

    Plugin.instantiate = function(elm,options) {
        return instantiate(elm,this.prototype.pluginName,options);
    };
    
    $.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue ;

        this.each(function(){
            returnValue = instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };

    elmx.partial("plugin",function(name,options) {
        var args = slice.call( arguments, 1 );
        return instantiate.apply(this,[this._elm,name].concat(args));
    }); 


    function plugins() {
        return plugins;
    }
     
    objects.mixin(plugins, {
        instantiate,
        Plugin,
        register,
        shortcuts
    });

    return  skylark.attach("domx.plugins",plugins);
});
define('skylark-domx-plugins/main',[
	"./plugins"
],function(plugins){
	return plugins;
});
define('skylark-domx-plugins', ['skylark-domx-plugins/main'], function (main) { return main; });

define('skylark-domx/plugins',[
    "skylark-domx-plugins"
], function( plugins) {
    "use strict";
    return plugins;
});
define('skylark-domx/styler',[
    "skylark-domx-styler"
], function( styler) {

    return styler;
});
define('skylark-domx/query',[
    "skylark-domx-query",
    "./data",
    "./eventer",
    "./fx",
    "./geom",
    "./styler"
], function( query) {

    return query;

});
define('skylark-domx-scripter/scripter',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder"
], function(skylark, langx, noder, finder) {

    var head = document.getElementsByTagName('head')[0],
        scriptsByUrl = {},
        scriptElementsById = {},
        count = 0;

    var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );

    function scripter() {
        return scripter;
    }


    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };

    function evaluate(code,node, doc ) {
        doc = doc || document;

        var i, val,
            script = doc.createElement("script");

        script.text = code;
        if ( node ) {
            for ( i in preservedScriptAttributes ) {

                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[ i ] || node.getAttribute && node.getAttribute( i );
                if ( val ) {
                    script.setAttribute( i, val );
                }
            }
        }
        doc.head.appendChild( script ).parentNode.removeChild( script );

        return this;
    }

    langx.mixin(scripter, {
        /*
         * Load a script from a url into the document.
         * @param {} url
         * @param {} loadedCallback
         * @param {} errorCallback
         */
        loadJavaScript: function(url, loadedCallback, errorCallback) {
            var script = scriptsByUrl[url];
            if (!script) {
                script = scriptsByUrl[url] = {
                    state: 0, //0:unload,1:loaded,-1:loaderror
                    loadedCallbacks: [],
                    errorCallbacks: []
                }
            }

            script.loadedCallbacks.push(loadedCallback);
            script.errorCallbacks.push(errorCallback);

            if (script.state === 1) {
                script.node.onload();
            } else if (script.state === -1) {
                script.node.onerror();
            } else {
                var node = script.node = document.createElement("script"),
                    id = script.id = (count++);

                node.type = "text/javascript";
                node.async = false;
                node.defer = false;
                startTime = new Date().getTime();
                head.appendChild(node);

                node.onload = function() {
                        script.state = 1;

                        var callbacks = script.loadedCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    },
                    node.onerror = function() {
                        script.state = -1;
                        var callbacks = script.errorCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    };
                node.src = url;

                scriptElementsById[id] = node;
            }
            return script.id;
        },
        /*
         * Remove the specified script from the document.
         * @param {Number} id
         */
        deleteJavaScript: function(id) {
            var node = scriptElementsById[id];
            if (node) {
                var url = node.src;
                noder.remove(node);
                delete scriptElementsById[id];
                delete scriptsByUrl[url];
            }
        },

        evaluate : evaluate,

        html : function(node,value) {

            var result = noder.html(node,value);

            if (value !== undefined) {
                var scripts = node.querySelectorAll('script');

                for (var i =0; i<scripts.length; i++) {
                    var node1 = scripts[i];
                    if (rscriptType.test( node1.type || "" ) ) {
                      evaluate(node1.textContent,node1);
                    }
                }       
                return this;         
            } else {
                return result;
            }



        }
    });

    return skylark.attach("domx.scripter", scripter);
});
define('skylark-domx-scripter/main',[
	"./scripter",
	"skylark-domx-query"
],function(scripter,$){

    $.fn.html = $.wraps.wrapper_value(scripter.html, scripter, scripter.html);

	return scripter;
});
define('skylark-domx-scripter', ['skylark-domx-scripter/main'], function (main) { return main; });

define('skylark-domx/scripter',[
    "skylark-domx-scripter"
], function( scripter) {

    return scripter;
});
define('skylark-domx-transforms/transforms',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-data",
    "skylark-domx-styler"
], function(skylark,langx,browser,datax,styler) {
  var css3Transform = browser.normalizeCssProperty("transform");

  function getMatrix(radian, x, y) {
    var Cos = Math.cos(radian), Sin = Math.sin(radian);
    return {
      M11: Cos * x, 
      M12: -Sin * y,
      M21: Sin * x, 
      M22: Cos * y
    };
  }

  function getZoom(scale, zoom) {
      return scale > 0 && scale > -zoom ? zoom :
        scale < 0 && scale < zoom ? -zoom : 0;
  }

  function change(el,d) {
      var matrix = getMatrix(d.radian, d.y, d.x);
      styler.css(el,css3Transform, "matrix("
        + matrix.M11.toFixed(16) + "," + matrix.M21.toFixed(16) + ","
        + matrix.M12.toFixed(16) + "," + matrix.M22.toFixed(16) + ", 0, 0)"
      );      
  }

  function transformData(el,d) {
    if (d) {
      datax.data(el,"transform",d);
    } else {
      d = datax.data(el,"transform") || {};
      d.radian = d.radian || 0;
      d.x = d.x || 1;
      d.y = d.y || 1;
      d.zoom = d.zoom || 1;
      return d;     
    }
  }

  var calcs = {
    //Vertical flip
    vertical : function (d) {
        d.radian = Math.PI - d.radian; 
        d.y *= -1;
    },

   //Horizontal flip
    horizontal : function (d) {
        d.radian = Math.PI - d.radian; 
        d.x *= -1;
    },

    //Rotate according to angle
    rotate : function (d,degress) {
        d.radian = degress * Math.PI / 180;; 
    },

    //Turn left 90 degrees
    left : function (d) {
        d.radian -= Math.PI / 2; 
    },

    //Turn right 90 degrees
    right : function (d) {
        d.radian += Math.PI / 2; 
    },
 
    //zoom
    scale: function (d,zoom) {
        var hZoom = getZoom(d.y, zoom), vZoom = getZoom(d.x, zoom);
        if (hZoom && vZoom) {
          d.y += hZoom; 
          d.x += vZoom;
        }
    }, 

    //zoom in
    zoomin: function (d) { 
      calcs.scale(d,0.1); 
    },
    
    //zoom out
    zoomout: function (d) { 
      calcs.scale(d,-0.1); 
    }

  };
  
  
  function _createApiMethod(calcFunc) {
    return function() {
      var args = langx.makeArray(arguments),
        el = args.shift(),
          d = transformData(el);
        args.unshift(d);
        calcFunc.apply(this,args)
        change(el,d);
        transformData(el,d);
    }
  }
  

  function matrix(el) {
    var appliedTransforms = '';
    do {
      var transform = styler.css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (el = el.parentElement);

    if (window.DOMMatrix) {
      return new DOMMatrix(appliedTransforms);
    } else if (window.WebKitCSSMatrix) {
      return new WebKitCSSMatrix(appliedTransforms);
    } else if (window.CSSMatrix) {
      return new CSSMatrix(appliedTransforms);
    }
  }
   
  function transforms() {
    return transforms;
  }

  ["vertical","horizontal","rotate","left","right","scale","zoom","zoomin","zoomout"].forEach(function(name){
    transforms[name] = _createApiMethod(calcs[name]);
  });

  langx.mixin(transforms, {
    reset : function(el) {
      var d = {
        x : 1,
        y : 1,
        radian : 0,
      }
      change(el,d);
      transformData(el,d);
    },
    matrix
  });


  return skylark.attach("domx.transforms", transforms);
});

define('skylark-domx-transforms/main',[
	"./transforms"
],function(transforms){
	return transforms;
});
define('skylark-domx-transforms', ['skylark-domx-transforms/main'], function (main) { return main; });

define('skylark-domx/transforms',[
    "skylark-domx-transforms"
], function(transforms) {
  return transforms;
});

define('skylark-domx/velm',[
    "skylark-domx-velm",
    "./data",
    "./eventer",
    "./fx",
    "./geom",
    "./styler"
], function( velm) {
     return velm;
});
define('skylark-domx/main',[
    "./browser",
    "./css",
    "./data",
    "./eventer",
    "./finder",
    "./fx",
    "./geom",
    "./noder",
    "./plugins",
    "./query",
    "./scripter",
    "./styler",
    "./transforms",
    "./velm"
], function(browser,css,data,eventer,finder,fx,geom,noder,plugins,query,scripter,styler,transforms,velm) {
    return {
        browser,
        css,
        data,
        eventer,
        finder,
        geom,
        noder,
        plugins,
        query,
        scripter,
        styler,
        transforms,
        velm
    };
})
;
define('skylark-domx', ['skylark-domx/main'], function (main) { return main; });

define('skylark-langx-logging/logging',[
  "skylark-langx-ns"
],function(skylark){


    return skylark.attach("langx.logging",{

    });
});
define('skylark-langx-logging/levels',[
	"./logging"
],function(logging){
    return logging.levels = {
	    all: 'debug|info|warn|error',
	    off: '',
	    debug: 'debug|info|warn|error',
	    info: 'info|warn|error',
	    warn: 'warn|error',
	    error: 'error',
	    DEFAULT: "info"
    };	
});
define('skylark-langx-logging/Logger',[
    "skylark-langx-objects",
    "skylark-langx-constructs/klass",
    "./logging",
    "./levels"
],function(objects,klass,logging,levels){
    'use strict';

    let history = [];
 
    const LogByTypeFactory = (name) => (type, level, args) => {
        const lvl = levels[level];
        const lvlRegExp = new RegExp(`^(${ lvl })$`);
        if (type !== 'debug') {
            args.unshift(type.toUpperCase() + ':');
        }
        args.unshift(name + ':');
        if (history) {
            history.push([].concat(args));
            const splice = history.length - 1000;
            history.splice(0, splice > 0 ? splice : 0);
        }
        if (!window.console) {
            return;
        }
        let fn = window.console[type];
        if (!fn && type === 'debug') {
            fn = window.console.info || window.console.log;
        }
        if (!fn || !lvl || !lvlRegExp.test(type)) {
            return;
        }
        fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);
    };

    var Logger = klass({
        _level : "info",

        _construct : function(name) {
            this.name = name;

            this._logByType = LogByTypeFactory(name);
        },

        level : function(lvl) {
            if (typeof lvl === 'string') {
                if (!levels.hasOwnProperty(lvl)) {
                    throw new Error(`"${ lvl }" in not a valid log level`);
                }
                this._level = lvl;
            }
            return this._level;
        },

        error : function(...args){ 
            this._logByType('error', this._level, args);
        },

        warn : function(...args){ 
            this._logByType('warn', this._level, args);
        },

        debug : function(...args){ 
            this._logByType('debug', this._level, args);
        },

        info : function(...args){ 
            this._logByType('info', this._level, args);
        },

        history : function() {
            return history ? [].concat(history) : [];
        },

        createLogger : function(subname) {
            return new Logger(this.name ? this.name  + ': ' + subname : subname);   
        }

    });


    objects.mixin(Logger.prototype.history,{
        enable : function() {
           if (history === null) {
                history = [];
            }            
        },
        
        filter : function(fname) {
            return (history || []).filter(historyItem => {
                return new RegExp(`.*${ fname }.*`).test(historyItem[0]);
            });
        },
        clear : function() {
            if (history) {
                history.length = 0;
            }
        },
        disable : function()  {
            if (history !== null) {
                history.length = 0;
                history = null;
            }
        }
    });

    Logger.root = new Logger("");

    return logging.Logger = Logger;

});
define('skylark-langx-logging/main',[
	"./logging",
	"./Logger"
],function(logging,Logger){
	let rootLogger = Logger.root;

	logging.debug = function(...args) {
		rootLogger.debug(...args);
	};

	logging.info = function(...args) {
		rootLogger.debug(...args);
	};

	logging.warn = function(...args) {
		rootLogger.debug(...args);
	};

	logging.error = function(...args) {
		rootLogger.debug(...args);
	};


	return logging;
});
define('skylark-langx-logging', ['skylark-langx-logging/main'], function (main) { return main; });

define('skylark-videojs/utils/log',['skylark-langx-logging'], function (logging) {
    'use strict';
    /*
    const log = new('VIDEOJS');
    log.createLogger = createLogger;
    return log;
    */
    return new logging.Logger('VIDEOJS');
});
define('skylark-langx/main',[
    "./langx"
], function(langx) {
    return langx;
});

define('skylark-langx', ['skylark-langx/main'], function (main) { return main; });

define('skylark-videojs/utils/obj',[
    "skylark-langx"
],function (langx) {
    'use strict';

    /*
    const toString = Object.prototype.toString;
    const keys = function (object) {
        return isObject(object) ? Object.keys(object) : [];
    };
    function each(object, fn) {
        keys(object).forEach(key => fn(object[key], key));
    }
    function reduce(object, fn, initial = 0) {
        return keys(object).reduce((accum, key) => fn(accum, object[key], key), initial);
    }
    function assign(target, ...sources) {
        if (Object.assign) {
            return Object.assign(target, ...sources);
        }
        sources.forEach(source => {
            if (!source) {
                return;
            }
            each(source, (value, key) => {
                target[key] = value;
            });
        });
        return target;
    }
    function isObject(value) {
        return !!value && typeof value === 'object';
    }
    function isPlain(value) {
        return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;
    }

    */
    return {
        each : function(object,fn) {
            return langx.each(object,fn,true/*isForEach*/);
        },
        reduce: langx.reduce,
        assign: langx.mixin,
        isObject: langx.isObject,
        isPlain: langx.isPlainObject
    };
});
define('skylark-videojs/utils/computed-style',[
    'skylark-langx-globals/window',
    'skylark-domx-styler'
], function (window,styler) {
    'use strict';
    function computedStyle(el, prop) {
        if (!el || !prop) {
            return '';
        }
        if (typeof window.getComputedStyle === 'function') {
            const computedStyleValue = window.getComputedStyle(el);
            return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : '';
        }
        return '';
    }
    ///return computedStyle;
    return styler.css;

});
define('skylark-videojs/utils/browser',[
    "skylark-langx-globals/window",
    "skylark-langx-globals/document"
], function (window,document) {
    'use strict';

    function isReal() {
        return document === window.document;
    }

    const USER_AGENT = window.navigator && window.navigator.userAgent || '';
    const webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
    const appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
    const IS_IPOD = /iPod/i.test(USER_AGENT);
    const IOS_VERSION = function () {
        const match = USER_AGENT.match(/OS (\d+)_/i);
        if (match && match[1]) {
            return match[1];
        }
        return null;
    }();
    const IS_ANDROID = /Android/i.test(USER_AGENT);
    const ANDROID_VERSION = function () {
        const match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
        if (!match) {
            return null;
        }
        const major = match[1] && parseFloat(match[1]);
        const minor = match[2] && parseFloat(match[2]);
        if (major && minor) {
            return parseFloat(match[1] + '.' + match[2]);
        } else if (major) {
            return major;
        }
        return null;
    }();
    const IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;
    const IS_FIREFOX = /Firefox/i.test(USER_AGENT);
    const IS_EDGE = /Edg/i.test(USER_AGENT);
    const IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));
    const CHROME_VERSION = function () {
        const match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
        if (match && match[2]) {
            return parseFloat(match[2]);
        }
        return null;
    }();
    const IE_VERSION = function () {
        const result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
        let version = result && parseFloat(result[1]);
        if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
            version = 11;
        }
        return version;
    }();
    const IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
    const IS_WINDOWS = /Windows/i.test(USER_AGENT);
    const TOUCH_ENABLED = Boolean(isReal() && ('ontouchstart' in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch));
    const IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
    const IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
    const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
    const IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
    return {
        IS_IPOD: IS_IPOD,
        IOS_VERSION: IOS_VERSION,
        IS_ANDROID: IS_ANDROID,
        ANDROID_VERSION: ANDROID_VERSION,
        IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,
        IS_FIREFOX: IS_FIREFOX,
        IS_EDGE: IS_EDGE,
        IS_CHROME: IS_CHROME,
        CHROME_VERSION: CHROME_VERSION,
        IE_VERSION: IE_VERSION,
        IS_SAFARI: IS_SAFARI,
        IS_WINDOWS: IS_WINDOWS,
        TOUCH_ENABLED: TOUCH_ENABLED,
        IS_IPAD: IS_IPAD,
        IS_IPHONE: IS_IPHONE,
        IS_IOS: IS_IOS,
        IS_ANY_SAFARI: IS_ANY_SAFARI,

        isReal
    };
});
define('skylark-videojs/utils/dom',[
    "skylark-langx-globals/window",
    "skylark-langx-globals/document",   
    "skylark-domx",
    './log',
    './obj',
    './computed-style',
    './browser'
], function (window,document,domx, log, obj, computedStyle, browser) {
    'use strict';
    function isNonBlankString(str) {
        return typeof str === 'string' && Boolean(str.trim());
    }
    function throwIfWhitespace(str) {
        if (str.indexOf(' ') >= 0) {
            throw new Error('class has illegal whitespace characters');
        }
    }
    function classRegExp(className) {
        return new RegExp('(^|\\s)' + className + '($|\\s)');
    }

    function isEl(value) {
        return obj.isObject(value) && value.nodeType === 1;
    }
    function isInFrame() {
        try {
            return window.parent !== window.self;
        } catch (x) {
            return true;
        }
    }
    function createQuerier(method) {
        return function (selector, context) {
            if (!isNonBlankString(selector)) {
                return document[method](null);
            }
            if (isNonBlankString(context)) {
                context = document.querySelector(context);
            }
            const ctx = isEl(context) ? context : document;
            return ctx[method] && ctx[method](selector);
        };
    }
    function createEl(tagName = 'div', properties = {}, attributes = {}, content) {
        const el = document.createElement(tagName);
        Object.getOwnPropertyNames(properties).forEach(function (propName) {
            const val = properties[propName];
            if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {
                log.warn('Setting attributes in the second argument of createEl()\n' + 'has been deprecated. Use the third argument instead.\n' + `createEl(type, properties, attributes). Attempting to set ${ propName } to ${ val }.`);
                el.setAttribute(propName, val);
            } else if (propName === 'textContent') {
                textContent(el, val);
            } else if (el[propName] !== val || propName === 'tabIndex') {
                el[propName] = val;
            }
        });
        Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
            el.setAttribute(attrName, attributes[attrName]);
        });
        if (content) {
            appendContent(el, content);
        }
        return el;
    }
    function textContent(el, text) {
        if (typeof el.textContent === 'undefined') {
            el.innerText = text;
        } else {
            el.textContent = text;
        }
        return el;
    }
    function prependTo(child, parent) {
        if (parent.firstChild) {
            parent.insertBefore(child, parent.firstChild);
        } else {
            parent.appendChild(child);
        }
    }
    function hasClass(element, classToCheck) {
        throwIfWhitespace(classToCheck);
        if (element.classList) {
            return element.classList.contains(classToCheck);
        }
        return classRegExp(classToCheck).test(element.className);
    }
    function addClass(element, classToAdd) {
        if (element.classList) {
            element.classList.add(classToAdd);
        } else if (!hasClass(element, classToAdd)) {
            element.className = (element.className + ' ' + classToAdd).trim();
        }
        return element;
    }
    function removeClass(element, classToRemove) {
        if (element.classList) {
            element.classList.remove(classToRemove);
        } else {
            throwIfWhitespace(classToRemove);
            element.className = element.className.split(/\s+/).filter(function (c) {
                return c !== classToRemove;
            }).join(' ');
        }
        return element;
    }
    function toggleClass(element, classToToggle, predicate) {
        const has = hasClass(element, classToToggle);
        if (typeof predicate === 'function') {
            predicate = predicate(element, classToToggle);
        }
        if (typeof predicate !== 'boolean') {
            predicate = !has;
        }
        if (predicate === has) {
            return;
        }
        if (predicate) {
            addClass(element, classToToggle);
        } else {
            removeClass(element, classToToggle);
        }
        return element;
    }
    function setAttributes(el, attributes) {
        Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
            const attrValue = attributes[attrName];
            if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
                el.removeAttribute(attrName);
            } else {
                el.setAttribute(attrName, attrValue === true ? '' : attrValue);
            }
        });
    }
    function getAttributes(tag) {
        const obj = {};
        const knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';
        if (tag && tag.attributes && tag.attributes.length > 0) {
            const attrs = tag.attributes;
            for (let i = attrs.length - 1; i >= 0; i--) {
                const attrName = attrs[i].name;
                let attrVal = attrs[i].value;
                if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
                    attrVal = attrVal !== null ? true : false;
                }
                obj[attrName] = attrVal;
            }
        }
        return obj;
    }
    function getAttribute(el, attribute) {
        return el.getAttribute(attribute);
    }
    function setAttribute(el, attribute, value) {
        el.setAttribute(attribute, value);
    }
    function removeAttribute(el, attribute) {
        el.removeAttribute(attribute);
    }
    function blockTextSelection() {
        document.body.focus();
        document.onselectstart = function () {
            return false;
        };
    }
    function unblockTextSelection() {
        document.onselectstart = function () {
            return true;
        };
    }
    function getBoundingClientRect(el) {
        if (el && el.getBoundingClientRect && el.parentNode) {
            const rect = el.getBoundingClientRect();
            const result = {};
            [
                'bottom',
                'height',
                'left',
                'right',
                'top',
                'width'
            ].forEach(k => {
                if (rect[k] !== undefined) {
                    result[k] = rect[k];
                }
            });
            if (!result.height) {
                result.height = parseFloat(computedStyle(el, 'height'));
            }
            if (!result.width) {
                result.width = parseFloat(computedStyle(el, 'width'));
            }
            return result;
        }
    }
    function findPosition(el) {
        if (!el || el && !el.offsetParent) {
            return {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            };
        }
        const width = el.offsetWidth;
        const height = el.offsetHeight;
        let left = 0;
        let top = 0;
        ///while (el.offsetParent && el !== document[fs.fullscreenElement]) {
        while (el.offsetParent && !domx.noder.isFullscreen(el)) {
            left += el.offsetLeft;
            top += el.offsetTop;
            el = el.offsetParent;
        }
        return {
            left,
            top,
            width,
            height
        };
    }
    function getPointerPosition(el, event) {
        const translated = {
            x: 0,
            y: 0
        };
        if (browser.IS_IOS) {
            let item = el;
            while (item && item.nodeName.toLowerCase() !== 'html') {
                const transform = computedStyle(item, 'transform');
                if (/^matrix/.test(transform)) {
                    const values = transform.slice(7, -1).split(/,\s/).map(Number);
                    translated.x += values[4];
                    translated.y += values[5];
                } else if (/^matrix3d/.test(transform)) {
                    const values = transform.slice(9, -1).split(/,\s/).map(Number);
                    translated.x += values[12];
                    translated.y += values[13];
                }
                item = item.parentNode;
            }
        }
        const position = {};
        const boxTarget = findPosition(event.target);
        const box = findPosition(el);
        const boxW = box.width;
        const boxH = box.height;
        let offsetY = event.offsetY - (box.top - boxTarget.top);
        let offsetX = event.offsetX - (box.left - boxTarget.left);
        if (event.changedTouches) {
            offsetX = event.changedTouches[0].pageX - box.left;
            offsetY = event.changedTouches[0].pageY + box.top;
            if (browser.IS_IOS) {
                offsetX -= translated.x;
                offsetY -= translated.y;
            }
        }
        position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
        position.x = Math.max(0, Math.min(1, offsetX / boxW));
        return position;
    }
    function isTextNode(value) {
        return obj.isObject(value) && value.nodeType === 3;
    }
    function emptyEl(el) {
        while (el.firstChild) {
            el.removeChild(el.firstChild);
        }
        return el;
    }
    function normalizeContent(content) {
        if (typeof content === 'function') {
            content = content();
        }
        return (Array.isArray(content) ? content : [content]).map(value => {
            if (typeof value === 'function') {
                value = value();
            }
            if (isEl(value) || isTextNode(value)) {
                return value;
            }
            if (typeof value === 'string' && /\S/.test(value)) {
                return document.createTextNode(value);
            }
        }).filter(value => value);
    }
    function appendContent(el, content) {
        normalizeContent(content).forEach(node => el.appendChild(node));
        return el;
    }
    function insertContent(el, content) {
        return appendContent(emptyEl(el), content);
    }
    function isSingleLeftClick(event) {
        if (event.button === undefined && event.buttons === undefined) {
            return true;
        }
        if (event.button === 0 && event.buttons === undefined) {
            return true;
        }
        if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {
            return true;
        }
        if (event.button !== 0 || event.buttons !== 1) {
            return false;
        }
        return true;
    }
    const $ = createQuerier('querySelector');
    const $$ = createQuerier('querySelectorAll');
    return {
        isReal: browser.isReal,
        isEl: domx.noder.isElement,// isEl,
        isInFrame: domx.noder.isInFrame, //isInFrame,
        createEl:  function (tagName = 'div', properties = {}, attributes = {}, content) { //createEl,
            var el  = domx.noder.createElement(tagName,properties,attributes);
            if (content) {
                domx.noder.append(el,content)
            }
            return el;
        }, 
        textContent: domx.data.text, //textContent,
        prependTo: function (child, parent) { //prependTo,
            domx.noder.prepend(parent,child);
        },
        hasClass: domx.styler.hasClass, //hasClass,
        addClass: domx.styler.addClass,  //addClass,
        removeClass: domx.styler.removeClass, //removeClass,
        toggleClass: domx.styler.toogleClass, //toggleClass,
        setAttributes: domx.data.attr, // setAttributes,
        getAttributes: getAttributes,
        getAttribute: domx.data.attr, //getAttribute,
        setAttribute: domx.data.attr, //setAttribute,
        removeAttribute: domx.data.removeAttr, //removeAttribute,
        blockTextSelection: blockTextSelection,
        unblockTextSelection: unblockTextSelection,
        getBoundingClientRect: getBoundingClientRect,
        findPosition: domx.geom.pageRect, //findPosition,
        getPointerPosition: getPointerPosition,
        isTextNode: domx.noder.isTextNode,// isTextNode,
        emptyEl: domx.noder.empty, //emptyEl,
        normalizeContent: normalizeContent,
        appendContent: domx.noder.append,//appendContent,
        insertContent: function(el,content) { //insertContent,
            domx.noder.empty(el);
            domx.noder.append(el,content);
            return el;
        },
        isSingleLeftClick: isSingleLeftClick,
        $: function(selector,context) {
            context = context || document;
            return domx.finder.find(context,selector);
        },
        $$: function(selector,context) {
            context = context || document;
            return domx.finder.findAll(context,selector);
        }
    };
});
define('skylark-videojs/setup',[
    'skylark-langx-globals/document',
    './utils/dom'
], function (document,Dom) {
    'use strict';
    let _windowLoaded = false;
    let videojs;
    const autoSetup = function () {
        if (!Dom.isReal() || videojs.options.autoSetup === false) {
            return;
        }
        const vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
        const audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
        const divs = Array.prototype.slice.call(document.getElementsByTagName('video-js'));
        const mediaEls = vids.concat(audios, divs);
        if (mediaEls && mediaEls.length > 0) {
            for (let i = 0, e = mediaEls.length; i < e; i++) {
                const mediaEl = mediaEls[i];
                if (mediaEl && mediaEl.getAttribute) {
                    if (mediaEl.player === undefined) {
                        const options = mediaEl.getAttribute('data-setup');
                        if (options !== null) {
                            videojs(mediaEl);
                        }
                    }
                } else {
                    autoSetupTimeout(1);
                    break;
                }
            }
        } else if (!_windowLoaded) {
            autoSetupTimeout(1);
        }
    };
    function autoSetupTimeout(wait, vjs) {
        if (vjs) {
            videojs = vjs;
        }
        window.setTimeout(autoSetup, wait);
    }
    function setWindowLoaded() {
        _windowLoaded = true;
        window.removeEventListener('load', setWindowLoaded);
    }
    if (Dom.isReal()) {
        if (document.readyState === 'complete') {
            setWindowLoaded();
        } else {
            window.addEventListener('load', setWindowLoaded);
        }
    }
    const hasLoaded = function () {
        return _windowLoaded;
    };
    return {
        autoSetup,
        autoSetupTimeout,
        hasLoaded
    };
});
define('skylark-videojs/utils/stylesheet',[
    'skylark-langx-globals/document'
], function (document) {
    'use strict';
    const createStyleElement = function (className) {
        const style = document.createElement('style');
        style.className = className;
        return style;
    };
    const setTextContent = function (el, content) {
        if (el.styleSheet) {
            el.styleSheet.cssText = content;
        } else {
            el.textContent = content;
        }
    };
    return {
        createStyleElement: createStyleElement,
        setTextContent: setTextContent
    };
});
define('skylark-domx-files/files',[
    "skylark-langx/skylark"
], function(skylark) {

    function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(','),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: mime });
    }


    var files = function() {
        return files;
    };

    return skylark.attach("domx.files", files);
});
define('skylark-io-diskfs/diskfs',[
    "skylark-langx/skylark"
], function(skylark) {

    function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(','),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: mime });
    }


    var diskfs = function() {
        return diskfs;
    };

    return skylark.attach("storages.diskfs", diskfs);
});
 define('skylark-io-diskfs/webentry',[
    "skylark-langx/arrays",
    "skylark-langx/Deferred",
    "./diskfs"
],function(arrays,Deferred, diskfs){
    var concat = Array.prototype.concat;
    var webentry = (function() {
        function one(entry, path) {
            var d = new Deferred(),
                onError = function(e) {
                    d.reject(e);
                };

            path = path || '';
            if (entry.isFile) {
                entry.file(function(file) {
                    file.relativePath = path;
                    d.resolve(file);
                }, onError);
            } else if (entry.isDirectory) {
                var dirReader = entry.createReader();
                dirReader.readEntries(function(entries) {
                    all(
                        entries,
                        path + entry.name + '/'
                    ).then(function(files) {
                        d.resolve(files);
                    }).catch(onError);
                }, onError);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                d.resolve([]);
            }
            return d.promise;
        }

        function all(entries, path) {
            return Deferred.all(
                arrays.map(entries, function(entry) {
                    return one(entry, path);
                })
            ).then(function() {
                return concat.apply([], arguments);
            });
        }

        return {
            one: one,
            all: all
        };
    })();

    return diskfs.webentry = webentry;
});
  define('skylark-domx-files/dropzone',[
    "skylark-langx/arrays",
    "skylark-langx/Deferred",
    "skylark-domx-styler",
    "skylark-domx-eventer",
    "skylark-domx-velm",
    "skylark-domx-query",   
    "skylark-io-diskfs/webentry",   
    "./files"
],function(arrays,Deferred, styler, eventer, velm, $, webentry, files){  /*
     * Make the specified element to could accept HTML5 file drag and drop.
     * @param {HTMLElement} elm
     * @param {PlainObject} params
     */
    function dropzone(elm, params) {
        params = params || {};
        var hoverClass = params.hoverClass || "dropzone",
            droppedCallback = params.dropped;

        var enterdCount = 0;
        eventer.on(elm, "dragenter", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                eventer.stop(e);
                enterdCount++;
                styler.addClass(elm, hoverClass)
            }
        });

        eventer.on(elm, "dragover", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                eventer.stop(e);
            }
        });

        eventer.on(elm, "dragleave", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                enterdCount--
                if (enterdCount == 0) {
                    styler.removeClass(elm, hoverClass);
                }
            }
        });

        eventer.on(elm, "drop", function(e) {
            if (e.dataTransfer && e.dataTransfer.types.indexOf("Files") > -1) {
                styler.removeClass(elm, hoverClass)
                eventer.stop(e);
                if (droppedCallback) {
                    var items = e.dataTransfer.items;
                    if (items && items.length && (items[0].webkitGetAsEntry ||
                            items[0].getAsEntry)) {
                        webentry.all(
                            arrays.map(items, function(item) {
                                if (item.webkitGetAsEntry) {
                                    return item.webkitGetAsEntry();
                                }
                                return item.getAsEntry();
                            })
                        ).then(droppedCallback);
                    } else {
                        droppedCallback(e.dataTransfer.files);
                    }
                }
            }
        });

        return this;
    }
    files.dropzone = dropzone;

    velm.delegate([
        "dropzone"
    ],files);


    $.fn.dropzone = $.wraps.wrapper_every_act(files.dropzone, files);

    return dropzone;
});
define('skylark-domx-files/pastezone',[
    "skylark-langx/objects",
    "skylark-domx-eventer",
    "skylark-domx-velm",
    "skylark-domx-query",   
    "./files"
],function(objects, eventer,velm,$, files){
    function pastezone(elm, params) {
        params = params || {};
        var hoverClass = params.hoverClass || "pastezone",
            pastedCallback = params.pasted;

        eventer.on(elm, "paste", function(e) {
            var items = e.originalEvent && e.originalEvent.clipboardData &&
                e.originalEvent.clipboardData.items,
                files = [];
            if (items && items.length) {
                objects.each(items, function(index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        files.push(file);
                    }
                });
            }
            if (pastedCallback && files.length) {
                pastedCallback(files);
            }
        });

        return this;
    }

    files.pastezone = pastezone;

    velm.delegate([
        "pastezone"
    ],files);

    $.fn.pastezone = $.wraps.wrapper_every_act(files.pastezone, files);

    return pastezone;

});

define('skylark-io-diskfs/select',[
    "./diskfs"
],function(diskfs){
    var fileInput,
        fileInputForm,
        fileSelected,
        maxFileSize = 1 / 0;

    function select(params) {
        params = params || {};
        var directory = params.directory || false,
            multiple = params.multiple || false,
            accept = params.accept || "", //'image/gif,image/jpeg,image/jpg,image/png,image/svg'
            title = params.title || "",
            fileSelected = params.picked;
        if (!fileInput) {
            var input = fileInput = document.createElement("input");

            input.type = "file";
            input.style.position = "fixed";
            input.style.left = 0;
            input.style.top = 0;
            input.style.opacity = .001;
            document.body.appendChild(input);

        }

        function selectFiles(pickedFiles) {
            for (var i = pickedFiles.length; i--;) {
                if (pickedFiles[i].size > maxFileSize) {
                    pickedFiles.splice(i, 1);
                }
            }
            fileSelected(pickedFiles);
        }

        fileInput.onchange = function(e) {
            var entries = e.target.webkitEntries || e.target.entries;

            if (entries && entries.length) {
                webentry.all(entries).then(function(files) {
                    selectFiles(files);
                });
            } else {
                selectFiles(Array.prototype.slice.call(e.target.files));
            }
            // reset to "", so selecting the same file next time still trigger the change handler
            fileInput.value = "";     
            fileInput.onchange = null;
        };
        
        fileInput.multiple = multiple;
        fileInput.accept = accept;
        fileInput.title = title;

        fileInput.webkitdirectory = directory;
        fileInput.click();
    }

    return diskfs.select = select;
});


define('skylark-domx-files/picker',[
    "skylark-langx/objects",
    "skylark-domx-eventer",
    "skylark-domx-velm",
    "skylark-domx-query",   
    "skylark-io-diskfs/select",
    "./files"
],function(objects, eventer, velm, $, select, files){
    /*
     * Make the specified element to pop-up the file selection dialog box when clicked , and read the contents the files selected from client file system by user.
     * @param {HTMLElement} elm
     * @param {PlainObject} params
     */
    function picker(elm, params) {
        eventer.on(elm, "click", function(e) {
            e.preventDefault();
            select(params);
        });
        return this;
    }

    files.picker = picker;

    velm.delegate([
        "picker"
    ],files);

    $.fn.picker = $.wraps.wrapper_every_act(files.picker, files);

    return picker;

});



define('skylark-langx-emitter/main',[
	"./Emitter",
	"./Evented"
],function(Emitter){
	return Emitter;
});
define('skylark-langx-emitter', ['skylark-langx-emitter/main'], function (main) { return main; });

define('skylark-domx-files/SingleUploader',[
	"skylark-langx-emitter",
	"skylark-langx-async/Deferred",
    "skylark-domx-velm",
    "skylark-domx-plugins",
	"./files",
	"./dropzone",
	"./pastezone",
	"./picker"
],function(
	Emitter, 
	Deferred, 
	elmx,
	plugins,
	files
) {
	//import ZipLoader from 'zip-loader';

	/**
	 * Watches an element for file drops, parses to create a filemap hierarchy,
	 * and emits the result.
	 */
	class SingleUploader extends plugins.Plugin {
		get klassName() {
	    	return "SingleUploader";
    	} 

    	get pluginName(){
      		return "lark.singleuploader";
    	} 

		get options () {
      		return {
	            selectors : {
	              picker   : ".file-picker",
	              dropzone : ".file-dropzone",
	              pastezone: ".file-pastezone",

	              startUploads: '.start-uploads',
	              cancelUploads: '.cancel-uploads',
	            }
	     	}
		}


	  /**
	   * @param  {Element} elm
	   * @param  [options] 
	   */
	  constructor (elm, options) {
	  	super(elm,options);

        this._velm = elmx(this._elm);

	  	this._initFileHandlers();

	}

    _initFileHandlers () {
        var self = this;

        var selectors = this.options.selectors,
        	dzSelector = selectors.dropzone,
        	pzSelector = selectors.pastezone,
        	pkSelector = selectors.picker;

        if (dzSelector) {
			this._velm.$(dzSelector).dropzone({
                dropped : function (files) {
                    self._addFile(files[0]);
                }
			});
        }


        if (pzSelector) {
            this._velm.$(pzSelector).pastezone({
                pasted : function (files) {
                    self._addFile(files[0]);
                }
            });                
        }

        if (pkSelector) {
            this._velm.$(pkSelector).picker({
                multiple: true,
                picked : function (files) {
                    self._addFile(files[0]);
                }
            });                
        }
    }

     _addFile(file) {
        this.emit('added', file);	  
     }


	  /**
	   * Destroys the instance.
	   */
	  destroy () {
	  }


	}

	return files.SingleUploader = SingleUploader;

});

 
define('skylark-net-http/Xhr',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-funcs",
  "skylark-langx-async/Deferred",
  "skylark-langx-emitter/Evented",
  "./http"
],function(skylark,types,objects,arrays,funcs,Deferred,Evented,http){

    var each = objects.each,
        mixin = objects.mixin,
        noop = funcs.noop,
        isArray = types.isArray,
        isFunction = types.isFunction,
        isPlainObject = types.isPlainObject,
        type = types.type;
 
     var getAbsoluteUrl = (function() {
        var a;

        return function(url) {
            if (!a) a = document.createElement('a');
            a.href = url;

            return a.href;
        };
    })();
   
    var Xhr = (function(){
        var jsonpID = 0,
            key,
            name,
            rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            scriptTypeRE = /^(?:text|application)\/javascript/i,
            xmlTypeRE = /^(?:text|application)\/xml/i,
            jsonType = 'application/json',
            htmlType = 'text/html',
            blankRE = /^\s*$/;

        var XhrDefaultOptions = {
            async: true,

            // Default type of request
            type: 'GET',
            // Callback that is executed before request
            beforeSend: noop,
            // Callback that is executed if the request succeeds
            success: noop,
            // Callback that is executed the the server drops error
            error: noop,
            // Callback that is executed on request complete (both: error and success)
            complete: noop,
            // The context for the callbacks
            context: null,
            // Whether to trigger "global" Ajax events
            global: true,

            // MIME types mapping
            // IIS returns Javascript as "application/x-javascript"
            accepts: {
                script: 'text/javascript, application/javascript, application/x-javascript',
                json: 'application/json',
                xml: 'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain'
            },
            // Whether the request is to another domain
            crossDomain: false,
            // Default timeout
            timeout: 0,
            // Whether data should be serialized to string
            processData: false,
            // Whether the browser should be allowed to cache GET responses
            cache: true,

            traditional : false,
            
            xhrFields : {
                withCredentials : false
            }
        };

        function mimeToDataType(mime) {
            if (mime) {
                mime = mime.split(';', 2)[0];
            }
            if (mime) {
                if (mime == htmlType) {
                    return "html";
                } else if (mime == jsonType) {
                    return "json";
                } else if (scriptTypeRE.test(mime)) {
                    return "script";
                } else if (xmlTypeRE.test(mime)) {
                    return "xml";
                }
            }
            return "text";
        }

        function appendQuery(url, query) {
            if (query == '') return url
            return (url + '&' + query).replace(/[&?]{1,2}/, '?')
        }

        // serialize payload and append it to the URL for GET requests
        function serializeData(options) {
            options.data = options.data || options.query;
            if (options.processData && options.data && type(options.data) != "string") {
                options.data = param(options.data, options.traditional);
            }
            if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) {
                if (type(options.data) != "string") {
                    options.data = param(options.data, options.traditional);
                }
                options.url = appendQuery(options.url, options.data);
                options.data = undefined;
            }
        }
        
        function serialize(params, obj, traditional, scope) {
            var t, array = isArray(obj),
                hash = isPlainObject(obj)
            each(obj, function(key, value) {
                t =type(value);
                if (scope) key = traditional ? scope :
                    scope + '[' + (hash || t == 'object' || t == 'array' ? key : '') + ']'
                // handle data in serializeArray() format
                if (!scope && array) params.add(value.name, value.value)
                // recurse into nested objects
                else if (t == "array" || (!traditional && t == "object"))
                    serialize(params, value, traditional, key)
                else params.add(key, value)
            })
        }

        var param = function(obj, traditional) {
            var params = []
            params.add = function(key, value) {
                if (isFunction(value)) {
                  value = value();
                }
                if (value == null) {
                  value = "";
                }
                this.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
            serialize(params, obj, traditional)
            return params.join('&').replace(/%20/g, '+')
        };

        var Xhr = Evented.inherit({
            klassName : "Xhr",

            _request  : function(args) {
                var _ = this._,
                    self = this,
                    options = mixin({},XhrDefaultOptions,_.options,args),
                    xhr = _.xhr = new XMLHttpRequest();

                serializeData(options)

                if (options.beforeSend) {
                    options.beforeSend.call(this, xhr, options);
                }                

                var dataType = options.dataType || options.handleAs,
                    mime = options.mimeType || options.accepts[dataType],
                    headers = options.headers,
                    xhrFields = options.xhrFields,
                    isFormData = options.data && options.data instanceof FormData,
                    basicAuthorizationToken = options.basicAuthorizationToken,
                    type = options.type,
                    url = options.url,
                    async = options.async,
                    user = options.user , 
                    password = options.password,
                    deferred = new Deferred(),
                    contentType = options.contentType || (isFormData ? false : 'application/x-www-form-urlencoded');

                if (xhrFields) {
                    for (name in xhrFields) {
                        xhr[name] = xhrFields[name];
                    }
                }

                if (mime && mime.indexOf(',') > -1) {
                    mime = mime.split(',', 2)[0];
                }
                if (mime && xhr.overrideMimeType) {
                    xhr.overrideMimeType(mime);
                }

                if (dataType == "blob" || dataType == "arraybuffer") {
                    xhr.responseType = dataType;
                }

                var finish = function() {
                    xhr.onloadend = noop;
                    xhr.onabort = noop;
                    xhr.onprogress = noop;
                    xhr.ontimeout = noop;
                    xhr = null;
                }
                var onloadend = function() {
                    var result, error = false
                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && getAbsoluteUrl(url).startsWith('file:'))) {
                        dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader('content-type'));

                        //result = xhr.responseText;
                        try {
                            if (dataType == 'script') {
                                eval(xhr.responseText);
                            } else if (dataType == 'xml') {
                                result = xhr.responseXML;
                            } else if (dataType == 'json') {
                                result = blankRE.test(xhr.responseText) ? null : JSON.parse(xhr.responseText);
                            } else if (dataType == "blob") {
                                result = xhr.response; // new Blob([xhr.response]);
                            } else if (dataType == "arraybuffer") {
                                result = xhr.reponse;
                            } else if (dataType == "text") {
                                result = xhr.responseText;
                            }
                        } catch (e) { 
                            error = e;
                        }

                        if (error) {
                            deferred.reject(error,xhr.status,xhr);
                        } else {
                            deferred.resolve(result,xhr.status,xhr);
                        }
                    } else {
                        deferred.reject(new Error(xhr.statusText),xhr.status,xhr);
                    }
                    finish();
                };
                
                var onabort = function() {
                    if (deferred) {
                        deferred.reject(new Error("abort"),xhr.status,xhr);
                    }
                    finish();                 
                }
 
                var ontimeout = function() {
                    if (deferred) {
                        deferred.reject(new Error("timeout"),xhr.status,xhr);
                    }
                    finish();                 
                }

                var onprogress = function(evt) {
                    if (deferred) {
                        deferred.notify(evt,xhr.status,xhr);
                    }
                }

                xhr.onloadend = onloadend;
                xhr.onabort = onabort;
                xhr.ontimeout = ontimeout;
                xhr.onprogress = onprogress;

                xhr.open(type, url, async, user, password);
               
                if (headers) {
                    for ( var key in headers) {
                        var value = headers[key];
 
                        if(key.toLowerCase() === 'content-type'){
                            contentType = value;
                        } else {
                           xhr.setRequestHeader(key, value);
                        }
                    }
                }   

                if  (contentType && contentType !== false){
                    xhr.setRequestHeader('Content-Type', contentType);
                }

                if(!headers || !('X-Requested-With' in headers)){
                    //xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); // del for s02
                }


                //If basicAuthorizationToken is defined set its value into "Authorization" header
                if (basicAuthorizationToken) {
                    xhr.setRequestHeader("Authorization", basicAuthorizationToken);
                }

                xhr.send(options.data ? options.data : null);

                return deferred.promise;

            },

            "abort": function() {
                var _ = this._,
                    xhr = _.xhr;

                if (xhr) {
                    xhr.abort();
                }    
            },


            "request": function(args) {
                return this._request(args);
            },

            get : function(args) {
                args = args || {};
                args.type = "GET";
                return this._request(args);
            },

            post : function(args) {
                args = args || {};
                args.type = "POST";
                return this._request(args);
            },

            patch : function(args) {
                args = args || {};
                args.type = "PATCH";
                return this._request(args);
            },

            put : function(args) {
                args = args || {};
                args.type = "PUT";
                return this._request(args);
            },

            del : function(args) {
                args = args || {};
                args.type = "DELETE";
                return this._request(args);
            },

            "init": function(options) {
                this._ = {
                    options : options || {}
                };
            }
        });

        ["request","get","post","put","del","patch"].forEach(function(name){
            Xhr[name] = function(url,args) {
                var xhr = new Xhr({"url" : url});
                return xhr[name](args);
            };
        });

        Xhr.defaultOptions = XhrDefaultOptions;
        Xhr.param = param;

        return Xhr;
    })();

    return http.Xhr = Xhr;  
});
define('skylark-net-http/Upload',[
    "skylark-langx-types",
    "skylark-langx-objects",
    "skylark-langx-arrays",
    "skylark-langx-async/Deferred",
    "skylark-langx-emitter/Evented",    
    "./Xhr",
    "./http"
],function(types, objects, arrays, Deferred, Evented,Xhr, http){

    var blobSlice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;


    /*
     *Class for uploading files using xhr.
     */
    var Upload = Evented.inherit({
        klassName : "Upload",

        _construct : function(options) {
            this._options = objects.mixin({
                debug: false,
                url: '/upload',
                headers : {

                },
                // maximum number of concurrent uploads
                maxConnections: 999,
                // To upload large files in smaller chunks, set the following option
                // to a preferred maximum chunk size. If set to 0, null or undefined,
                // or the browser does not support the required Blob API, files will
                // be uploaded as a whole.
                maxChunkSize: undefined,

                onProgress: function(id, fileName, loaded, total){
                },
                onComplete: function(id, fileName,result,status,xhr){
                },
                onCancel: function(id, fileName){
                },
                onFailure : function(id,fileName,e) {                    
                }
            },options);

            this._queue = [];
            // params for files in queue
            this._params = [];

            this._files = [];
            this._xhrs = [];

            // current loaded size in bytes for each file
            this._loaded = [];

        },

        /**
         * Adds file to the queue
         * Returns id to use with upload, cancel
         **/
        add: function(file){
            return this._files.push(file) - 1;
        },

        /**
         * Sends the file identified by id and additional query params to the server.
         */
        send: function(id, params){
            if (!this._files[id]) {
                // Already sended or canceled
                return ;
            }
            if (this._queue.indexOf(id)>-1) {
                // Already in the queue
                return;
            }
            var len = this._queue.push(id);

            var copy = objects.clone(params);

            this._params[id] = copy;

            // if too many active uploads, wait...
            if (len <= this._options.maxConnections){
                this._send(id, this._params[id]);
            }     
        },

        /**
         * Sends all files  and additional query params to the server.
         */
        sendAll: function(params){
           for( var id = 0; id <this._files.length; id++) {
                this.send(id,params);
            }
        },

        /**
         * Cancels file upload by id
         */
        cancel: function(id){
            this._cancel(id);
            this._dequeue(id);
        },

        /**
         * Cancells all uploads
         */
        cancelAll: function(){
            for (var i=0; i<this._queue.length; i++){
                this._cancel(this._queue[i]);
            }
            this._queue = [];
        },

        getName: function(id){
            var file = this._files[id];
            return file.fileName != null ? file.fileName : file.name;
        },

        getSize: function(id){
            var file = this._files[id];
            return file.fileSize != null ? file.fileSize : file.size;
        },

        /**
         * Returns uploaded bytes for file identified by id
         */
        getLoaded: function(id){
            return this._loaded[id] || 0;
        },


        /**
         * Sends the file identified by id and additional query params to the server
         * @param {Object} params name-value string pairs
         */
        _send: function(id, params){
            var options = this._options,
                name = this.getName(id),
                size = this.getSize(id),
                chunkSize = options.maxChunkSize || 0,
                curUploadingSize,
                curLoadedSize = 0,
                file = this._files[id],
                args = {
                    headers : objects.clone(options.headers)                    
                };

            this._loaded[id] = this._loaded[id] || 0;

            var xhr = this._xhrs[id] = new Xhr({
                url : options.url
            });

            if (chunkSize)  {

                args.data = blobSlice.call(
                    file,
                    this._loaded[id],
                    this._loaded[id] + chunkSize,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                curUploadingSize = args.data.size;
                // Expose the chunk bytes position range:
                args.headers["content-range"] = 'bytes ' + this._loaded[id] + '-' +
                    (this._loaded[id] + curUploadingSize - 1) + '/' + size;
                args.headers["Content-Type"] = "application/octet-stream";
            }  else {
                curUploadingSize = size;
                var formParamName =  params.formParamName,
                    formData = params.formData;

                if (formParamName) {
                    if (!formData) {
                        formData = new FormData();
                    }
                    formData.append(formParamName,file);
                    args.data = formData;
    
                } else {
                    args.headers["Content-Type"] = file.type || "application/octet-stream";
                    args.data = file;
                }
            }


            var self = this;
            xhr.post(
                args
            ).progress(function(e){
                if (e.lengthComputable){
                    curLoadedSize = curLoadedSize + e.loaded;
                    self._loaded[id] = self._loaded[id] + e.loaded;
                    self._options.onProgress(id, name, self._loaded[id], size);
                }
            }).then(function(result,status,xhr){
                if (!self._files[id]) {
                    // the request was aborted/cancelled
                    return;
                }

                if (curLoadedSize < curUploadingSize) {
                    // Create a progress event if no final progress event
                    // with loaded equaling total has been triggered
                    // for this chunk:
                    self._loaded[id] = self._loaded[id] + curUploadingSize - curLoadedSize;
                    self._options.onProgress(id, name, self._loaded[id], size);                    
                }

                if (self._loaded[id] <size) {
                    // File upload not yet complete,
                    // continue with the next chunk:
                    self._send(id,params);
                } else {
                    self._options.onComplete(id,name,result,status,xhr);

                    self._files[id] = null;
                    self._xhrs[id] = null;
                    self._dequeue(id);
                }


            }).catch(function(e){
                self._options.onFailure(id,name,e);

                self._files[id] = null;
                self._xhrs[id] = null;
                self._dequeue(id);
            });
        },

        _cancel: function(id){
            this._options.onCancel(id, this.getName(id));

            this._files[id] = null;

            if (this._xhrs[id]){
                this._xhrs[id].abort();
                this._xhrs[id] = null;
            }
        },

        /**
         * Returns id of files being uploaded or
         * waiting for their turn
         */
        getQueue: function(){
            return this._queue;
        },


        /**
         * Removes element from queue, starts upload of next
         */
        _dequeue: function(id){
            var i = arrays.inArray(id,this._queue);
            this._queue.splice(i, 1);

            var max = this._options.maxConnections;

            if (this._queue.length >= max && i < max){
                var nextId = this._queue[max-1];
                this._send(nextId, this._params[nextId]);
            }
        }
    });


  Upload.send = function(file, options) {
    var uploader = new Upload(options);
    var id = uploader.add(file);
    return uploader.send(id,options);
  };

  Upload.sendAll = function(files,options) {
      var uploader = new Upload(options);
      for (var i = 0, len = files.length; i < len; i++) {
        this.add(file[i]);
      }
      return uploader.send(options);
  };

    return http.Upload = Upload;    
});
define('skylark-domx-files/MultiUploader',[
  "skylark-langx/skylark",
  "skylark-langx/langx",
  "skylark-domx-query",
  "skylark-domx-velm",
  "skylark-net-http/Upload",
  "skylark-domx-plugins",
  "./files"
]  ,function(skylark,langx,$, elmx,FileUpload, plugins,files){

    var fileListTemplate = '<div class="lark-multiuploader">' + 
        '    <h3 class="popover-title">Upload files</h3>' + 
        '    <div class="popover-content container-fluid" class="file-list file-dropzone file-pastezone">' + 
        '        <div class="no-data"><em>Add files.</em></div>' + 
        '    </div>' + 
        '    <footer>' + 
        '        <button class="btn btn-warning pull-right btn-sm" id="cancel-uploads-button"><i class="icon-cancel"></i>Cancel uploads</button>' + 
        '        <span class="btn btn-success fileinput-button btn-sm" id="fileinput-button">' + 
        '            <i class="icon-plus"></i>' + 
        '            <span>Add files...</span>' + 
        '            <input id="fileupload" type="file" name="files[]" multiple="multiple">' + 
        '        </span>' + 
        '        <button class="btn btn-primary btn-sm" id="start-uploads-button"><i class="icon-start"></i>Start uploads</button>' + 
        '    </footer>' + 
        '</div>',
        fileItemTemplate = '<div class="file-item row">' +
        '   <div class="col-md-6"><span class="name"></span></div>' + 
        '   <div class="col-md-3">' +
        '    <span class="size"></span>' +
        '    <div class="progress hidden">' +
        '        <div class="progress-label"></div>' +
        '        <div class="bar"></div>' +
        '    </div>' +
        '    <span class="message hidden"></span>' +
        '   </div>' +
        '   <div class="col-md-3">' +
        '    <button class="btn btn-warning btn-xs cancel"><i class="icon-remove"></i>Cancel</button>' +
        '    <button class="btn btn-xs clear hidden">Clear</button>' +
        '   </div>' +
        '</div>';

    var MultiUploader =  plugins.Plugin.inherit({
        klassName : "Uploader",
        pluginName : "lark.multiuploader",

        options: {
            uploadUrl: '/upload',

        	params: {
                formParamName : "file"
            },

    	    maxConnections: 3,
        	// validation
        	allowedExtensions: [],
        	sizeLimit: 0,
        	minSizeLimit: 0,

            autoUpload: false,
            selectors : {
              fileList : ".file-list",
              fileItem : ".file-item",
              nodata : ".file-list .no-data",

              picker   : ".file-picker",
              dropzone : ".file-dropzone",
              pastezone: ".file-pastezone",

              startUploads: '.start-uploads',
              cancelUploads: '.cancel-uploads',
            },

            template : fileListTemplate,

            dataType: 'json',

            fileItem : {
            	selectors : {
                    name : ".name",
                    size : ".size",
                    cancel: ".cancel",
                    clear : ".clear",
                    progress : ".progress",
                    message : ".message"                   
            	},

            	template : fileItemTemplate
            }
        },


        _construct : function(elm,options) {
            var self = this;


            // Render current files
            /*
            this.files.forEach(function (file) {
                self.renderFile(file);
            });
            */

            //this._refresh({files:true});
        

            //this._files.on('all', function(){
            //  self._refresh({files:true});
            //});


           this.overrided(elm,options);


           this._velm = elmx(this._elm);
        


            this._initEventHandler();
            this._initFileHandlers();
            this._initUpoadHandler();
            this._updateFileList();
        },

        _initFileHandlers : function() {
            var self = this;

            var selectors = this.options.selectors,
            	dzSelector = selectors.dropzone,
            	pzSelector = selectors.pastezone,
            	pkSelector = selectors.picker;

            if (dzSelector) {
				this._velm.$(dzSelector).dropzone({
	                dropped : function (files) {
                        self._addFiles(files);
	                }
				});
            }


            if (pzSelector) {
                this._velm.$(pzSelector).pastezone({
                    pasted : function (files) {
                        self._addFiles(files);
                    }
                });                
            }

            if (pkSelector) {
                this._velm.$(pkSelector).picker({
                    multiple: true,
                    picked : function (files) {
                        self._addFiles(files);
                    }
                });                
            }
        },

        _initUpoadHandler: function(){
            var self = this,
                handlerClass;

            this._handler = new FileUpload({
                url: this.options.uploadUrl,
                maxConnections: this.options.maxConnections,
                onProgress: function(id, fileName, loaded, total){
                    self._onProgress(id, fileName, loaded, total);
                },
                onComplete: function(id, fileName, result){
                    self._onComplete(id, fileName, result);
                },
                onCancel: function(id, fileName){
                    self._onCancel(id, fileName);
                },
                onFailure: function(id,fileName,e){
                    self._onFailure(id,fileName,e);
                }
            });
        },
        
         /**
         * delegate click event for cancel link
         **/
        _initEventHandler: function(){
            var self = this,
               selectors = this.options.selectors,
               itemSelectors = this.options.fileItem.selectors, 
               list = this._listElement;

            // Add cancel handler
            this._velm.$(selectors.fileList).on("click",itemSelectors.cancel,function(e){
                var $fileItem = $(this).closest(selectors.fileItem),
                    fileId = $fileItem.data("fileId");
                self._handler.cancel(fileId);
                $fileItem.remove();
                self._updateFileList();
            });

            // Add clear handler
            this._velm.$(selectors.fileList).on("click",itemSelectors.clear,function(e){
                var $fileItem = $(this).closest(selectors.fileItem),
                    fileId = $fileItem.data("fileId");
                $fileItem.remove();
                self._updateFileList();
            });

            // Add cancel all handler
            this._velm.$(selectors.cancelUploads).click(function(){
                var $files = self._velm.$(selectors.fileList).find(selectors.fileItem);           
                $files.forEach(function(fileItem){
                    var $fileItem = $(fileItem),
                        fileId = $fileItem.data("fileId");
                    self._handler.cancel(fileId);
                    $fileItem.remove();
                });
                self._updateFileList();

            });

            // Add start uploads handler
            this._velm.$(selectors.startUploads).click(function(){
                var $files = self._velm.$(selectors.fileList).find(selectors.fileItem);           
                $files.forEach(function(fileItem){
                    var $fileItem = $(fileItem),
                        fileId = $fileItem.data("fileId");
                    if (!$fileItem.data("status")) {
                        // The file has not yet been sent
                        self._handler.send(fileId,self.options.params);
                    }
                });

            });
            

        },       

        _onProgress: function(id, fileName, loaded, total){          
            var $item = this._getItemByFileId(id);

            var percent = parseInt(loaded / total * 100, 10);
            var progressHTML = this._formatSize(loaded)+' of '+ this._formatSize(total);

            $item.data("status","running");
            $item.find('.progress')
                .find('.bar')
                .css('width', percent+'%')
                .parent()
                .find('.progress-label')
                .html(progressHTML);
            this._updateFile($item);

        },

        _onComplete: function(id, fileName, result){
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","done");
            $item.find('.message').html('<i class="icon-success"></i> ' + (this.doneMsg || 'Uploaded'));
            this._updateFile($item);
        },

        _onFailure : function(id,fileName,e) {
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","error");
            $item.find('.message').html('<i class="icon-error"></i> ');;
            this._updateFile($item)

        },

        _onCancel: function(id, fileName){
            this._filesInProgress--;
            var $item = this._getItemByFileId(id);
            $item.data("status","cancel");
            this._updateFile($item)
        },

        _addToList: function(id, fileName){
            var self = this;


            var fileName = this._handler.getName(id),
                fileSize = this._handler.getSize(id);

            var item = $(this.options.fileItem.template);
            item.data("fileId",id);

            item.find(this.options.fileItem.selectors.name).html(this._formatFileName(fileName));
            item.find(this.options.fileItem.selectors.size).html(this._formatSize(fileSize));

            this._velm.$(this.options.selectors.fileList).append(item);

            this._updateFileList();
        },
    
        _updateFileList : function ()  {
            var selectors = this.options.selectors,
                itemSelectors = this.options.fileItem.selectors,
                files = this._velm.$(selectors.fileList).find(selectors.fileItem);

            var with_files_elements = this._velm.$(selectors.cancelUploads + ',' + selectors.startUploads);
            var without_files_elements = this._velm.$(selectors.nodata);
            if (files.length > 0) {
                with_files_elements.removeClass('hidden');
                without_files_elements.addClass('hidden');
            } else {
                with_files_elements.addClass('hidden');
                without_files_elements.removeClass('hidden');
            }
        },
        
        _updateFile: function ($item) {
            var selectors = this.options.fileItem.selectors,
                when_pending = $item.find(selectors.size + "," + selectors.cancel),
                when_running = $item.find(selectors.progress + "," + selectors.cancel),
                when_done = $item.find(selectors.message + "," + selectors.clear);

            var status = $item.data("status");    
            if (status == "pending") {
                when_running.add(when_done).addClass('hidden');
                when_pending.removeClass('hidden');
            } else if (status == "running") {
                when_pending.add(when_done).addClass('hidden');
                when_running.removeClass('hidden');
            } else if (status == "done" || status == "error") {
                when_pending.add(when_running).addClass('hidden');
                when_done.removeClass('hidden');
            }
        },

        _getItemByFileId: function(id){
            var selectors = this.options.selectors,
                files = this._velm.$(selectors.fileList).find(selectors.fileItem),
                item;

            // there can't be txt nodes in dynamically created list
            // and we can  use nextSibling

            for (var i = 0; i<files.length;i++){
                var item2 = files[i];
                if ($(item2).data("fileId") == id) {
                    item = item2;
                    break;
                }
            }
            if (item) {
                return $(item);
            }
        },


            
        _addFiles: function(files){
            for (var i=0; i<files.length; i++){
                if ( !this._validateFile(files[i])){
                    return;
                }
            }

            for (var i=0; i<files.length; i++){
                this._addFile(files[i]);
            }
        },

        _addFile: function(file){
            var id = this._handler.add(file);

            this._filesInProgress++;
            this._addToList(id);

            //this._handler.upload(id, this.options.params);
        },

        _validateFile: function(file){
            var name, size;

            if (file.value){
                // it is a file input
                // get input value and remove path to normalize
                name = file.value.replace(/.*(\/|\\)/, "");
            } else {
                // fix missing properties in Safari
                name = file.fileName != null ? file.fileName : file.name;
                size = file.fileSize != null ? file.fileSize : file.size;
            }

            if (! this._isAllowedExtension(name)){
                this._error('typeError', name);
                return false;

            } else if (size === 0){
                this._error('emptyError', name);
                return false;

            } else if (size && this.options.sizeLimit && size > this.options.sizeLimit){
                this._error('sizeError', name);
                return false;

            } else if (size && size < this.options.minSizeLimit){
                this._error('minSizeError', name);
                return false;
            }

            return true;
        },

        _error: function(code, fileName){
            var message = this.options.messages[code];
            function r(name, replacement){ message = message.replace(name, replacement); }

            r('{file}', this._formatFileName(fileName));
            r('{extensions}', this.options.allowedExtensions.join(', '));
            r('{sizeLimit}', this._formatSize(this.options.sizeLimit));
            r('{minSizeLimit}', this._formatSize(this.options.minSizeLimit));

            this.options.showMessage(message);
        },

        _formatFileName: function(name){
            if (name.length > 33){
                name = name.slice(0, 19) + '...' + name.slice(-13);
            }
            return name;
        },

        _isAllowedExtension: function(fileName){
            var ext = (-1 !== fileName.indexOf('.')) ? fileName.replace(/.*[.]/, '').toLowerCase() : '';
            var allowed = this.options.allowedExtensions;

            if (!allowed.length){return true;}

            for (var i=0; i<allowed.length; i++){
                if (allowed[i].toLowerCase() == ext){ return true;}
            }

            return false;
        },

        _formatSize: function(bytes){
            var i = -1;
            do {
                bytes = bytes / 1024;
                i++;
            } while (bytes > 99);

            return Math.max(bytes, 0.1).toFixed(1) + ['KB', 'MB', 'GB', 'TB', 'PB', 'EB'][i];
        }

    });

   plugins.register(MultiUploader);



	return files.MultiUploader = MultiUploader;
});
define('skylark-domx-files/main',[
	"./files",
	"./dropzone",
	"./pastezone",
	"./picker",
	"./SingleUploader",
	"./MultiUploader"
],function(files){
	return files;
});
define('skylark-domx-files', ['skylark-domx-files/main'], function (main) { return main; });

define('skylark-data-collection/collections',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("data.collections",{});
});
define('skylark-data-collection/Collection',[
    "skylark-langx/Evented",
    "./collections"
], function(Evented, collections) {

    var Collection = collections.Collection = Evented.inherit({

        "klassName": "Collection",

        _clear: function() {
            throw new Error('Unimplemented API');
        },

        "clear": function() {
            //desc: "Removes all items from the Collection",
            //result: {
            //    type: Collection,
            //    desc: "this instance for chain call"
            //},
            //params: [],
            this._clear();
            this.trigger("changed:clear");
            return this;
        },

        /*
         *@method count
         *@return {Number}
         */
        count : /*Number*/function () {
            var c = 0,
                it = this.iterator();
            while(!it.hasNext()){
                c++;
            }
            return c;
        },

        "forEach": function( /*Function*/ func, /*Object?*/ thisArg) {
            //desc: "Executes a provided callback function once per collection item.",
            //result: {
            //    type: Number,
            //    desc: "the number of items"
            //},
            //params: [{
            //    name: "func",
            //    type: Function,
            //    desc: "Function to execute for each element."
            //}, {
            //    name: "thisArg",
            //    type: Object,
            //    desc: "Value to use as this when executing callback."
            //}],
            var it = this.iterator();
            while(it.hasNext()){
                var item = it.next();
                func.call(thisArg || item,item);
            }
            return this;

        },

        "iterator" : function() {
            throw new Error('Unimplemented API');
        },

        "toArray": function() {
            //desc: "Returns an array containing all of the items in this collection in proper sequence (from first to last item).",
            //result: {
            //    type: Array,
            //    desc: "an array containing all of the elements in this collection in proper sequence"
            //},
            //params: [],
            var items = [],
                it = this.iterator();
            while(!it.hasNext()){
                items.push(it.next());
            }
            return items;
        }
    });

    return Collection;
});


define('skylark-data-collection/Map',[
    "./collections",
    "./Collection"
], function( collections, Collection) {

    var Map = collections.Map = Collection.inherit({

        "klassName": "Map",

        _getInnerItems : function() {
            return this._items;
        },

        _clear : function() {
            this._items = [];
        },

        _findKeyByRegExp: function(regExp, callback) {
            var items = this._getInnerItems();
            return items.filter(function(key) {
                if (key.match(regExp)) {
                    if (callback) callback(key);
                    return true;
                } else {
                    return false;
                }
            });
        },

        "get":  function(strKey, silent) {
            //desc: "Returns the item at the specified key in the Hashtable.",
            //result: {
            //    type: Object,
            //    desc: "The item at the specified key."
            //},
            //params: [{
            //    name: "strKey",
            //    type: String,
            //    desc: "The key of the item to return."
            //}, {
            //    name: "silent",
            //    type: Boolean,
            //    desc: "the silent flag.",
            //    optional: true
            //}],
            if (typeof(strKey) != "string") {
                throw "hash key is not string!";
            }
            /*
            if (!silent && !this.contains(strKey)) {
                throw "hash key is not  existed";
            }
            */
            var items = this._getInnerItems();
            return items[strKey];
        },

        "iterator" : function() {
            var i =0;
            return {
                hasNext : function() {
                    return i < this._items.length;
                },
                next : function() {
                    var key =  this._items[i++];
                    return [this._items[key],key];
                }
            }
        },

        "set": function( /*String*/ strKey, /*Object*/ value) {
            //desc: "Replaces the item at the specified key in the Hashtable with the specified item.",
            //result: {
            //    type: Map,
            //    desc: "this instance for chain call."
            //},
            //params: [{
            //    name: "strKey",
            //    type: String,
            //    desc: "key of the item to replace."
            //}, {
            //    name: "value",
            //    type: Object,
            //    desc: "item to be stored at the specified position."
            //}],
            if (typeof(strKey) != "string") {
                throw "hash key is not string!";
            }

            /*
            if (!this.contains(strKey)) {
                throw "hash key is not existed";
            }
            */

            var items = this._getInnerItems();
            if (items.indexOf(strKey) == -1) {
                items.push(strKey);
            }
            var oldValue = items[strKey];
            if (oldValue !== value) {
                items[strKey] = value;
                var updated = {};
                updated[strKey] = {
                    name : strKey,
                    value : value,
                    oldValue : oldValue
                };
                this.trigger("changed" ,{ //TODO: "changed:"+ strKey
                    data : updated
                });
            }
            return this;
        },


        "remove": function( /*String*/ strKey) {
            //desc: "Removes the first occurrence of a specific item from the Hashtable",
            //result: {
            //    type: Map,
            //    desc: "this instance for chain call."
            //},
            //params: [{
            //    name: "strKey",
            //    type: String,
            //    desc: "The key for The item to remove from the Hashtable."
            //}],
            if (typeof(strKey) != "string") {
                throw "hash key is not string!";
            }
            var items = this._getInnerItems();
            var idx = items.indexOf(strKey);
            if (idx >= 0) {
                delete items[strKey];
                delete items[idx];
            }
        },

        findByRegExp: function( /*String*/ regExp, callback) {
            //desc: "find regExp items",
            //result: {
            //    type: Map,
            //    desc: "this instance for chain call."
            //},
            //params: [{
            //    name: "regExp",
            //    type: String,
            //    desc: "The key for The item to remove from the Hashtable."
            //}, {
            //    name: "callback",
            //    type: Function,
            //    desc: "the callback method"
            //}],
            var items = [],
                self = this;
            this._findKeyByRegExp(regExp, function(key) {
                var item = self.get(key);
                if (callback) callback(item);
                items.push(item);
            });
            return items;
        },

        removeByRegExp: function( /*String*/ regExp) {
            //desc: "Removes regExp items",
            //result: {
            //    type: Map,
            //    desc: "this instance for chain call."
            //},
            //params: [{
            //    name: "regExp",
            //    type: String,
            //    desc: "The key for The item to remove from the Hashtable."
            //}],
            var self = this;
            this._findKeyByRegExp(regExp, function(key) {
                self.remove(key);
            });
        },

        "toPlain": function() {
            //desc: "Returns a plain object containing all of the items in this Hashable.",
            //result: {
            //    type: Object,
            //    desc: "a plain object containing all of the items in this Hashtable."
            //},
            //params: [],
            var items = this._getInnerItems(); 

            for (var i = 0; i < items.length; i++) {
                var key = items[i];
                plain[key] = items[key];
            }
            return plain;
        },

        "toString": function( /*String?*/ delim) {
            //desc: "implementation of toString, follows [].toString().",
            //result: {
            //    type: String,
            //   desc: "The string."
            //},
            //params: [{
            //    name: "delim",
            //    type: String,
            //    desc: "The delim ",
            //    optional: true
            //}],
            var items = this._getInnerItems();

            return items.join((delim || ","));
        },

        "init": function( /*Object*/ data) {
            var items = this._items = [];
            for (var name in data) {
                items.push(name);
                items[name]= data[name];
            }
        }
       
    });
    return Map;
});


define('skylark-data-collection/HashMap',[
    "./collections",
	"./Map"
],function(collections,_Map) {

	var HashMap = collections.HashMap = _Map.inherit({
	});

	return HashMap;
});
define('skylark-widgets-base/base',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("widgets.base",{
		"actions":{},
		"dnd" : {},
		"locales" : {},
		"mixins" : {},
		"panels" : {},
		"skins" : {}
	});
});
define('skylark-widgets-base/skins/SkinManager',[
],function(){	
	"use strict";

	function SkinManager(){}

	var list = [],
		skins = [];

	//Add skin to list
	function register(skin, name) {
		list.push(name);
		skins[name] = skin;
	}

	//Get a skin instance
	function get(name) {
		if (!name) {
			name = list[0];
		}

		return skins[name];
	};

	function getList() {
		return list.slice();
	}

	return {
		register,
		get,
		getList
	};
});
define('skylark-widgets-base/Widget',[
  "skylark-langx-ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-events",
  "skylark-langx-numerics/Vector2",
  "skylark-domx-browser",
  "skylark-domx-data",
  "skylark-domx-eventer",
  "skylark-domx-noder",
  "skylark-domx-files",
  "skylark-domx-geom",
  "skylark-domx-velm",
  "skylark-domx-query",
  "skylark-domx-fx",
  "skylark-domx-plugins",
  "skylark-data-collection/HashMap",
  "./base",
  "./skins/SkinManager"
],function(skylark,types,objects,events,Vector2,browser,datax,eventer,noder,files,geom,elmx,$,fx, plugins,HashMap,base,SkinManager){

     const NativeEvents = {
            "drag": 2, // DragEvent
            "dragend": 2, // DragEvent
            "dragenter": 2, // DragEvent
            "dragexit": 2, // DragEvent
            "dragleave": 2, // DragEvent
            "dragover": 2, // DragEvent
            "dragstart": 2, // DragEvent
            "drop": 2, // DragEvent

            "abort": 3, // Event
            "change": 3, // Event
            "error": 3, // Event
            "selectionchange": 3, // Event
            "submit": 3, // Event
            "reset": 3, // Event
            'fullscreenchange':3,
            'fullscreenerror':3,

/*
            'disablepictureinpicturechanged':3,
            'ended':3,
            'enterpictureinpicture':3,
            'durationchange':3,
            'leavepictureinpicture':3,
            'loadstart' : 3,
            'loadedmetadata':3,
            'pause' : 3,
            'play':3,
            'posterchange':3,
            'ratechange':3,
            'seeking' : 3,
            'sourceset':3,
            'suspend':3,
            'textdata':3,
            'texttrackchange':3,
            'timeupdate':3,
            'volumechange':3,
            'waiting' : 3,
*/


            "focus": 4, // FocusEvent
            "blur": 4, // FocusEvent
            "focusin": 4, // FocusEvent
            "focusout": 4, // FocusEvent

            "keydown": 5, // KeyboardEvent
            "keypress": 5, // KeyboardEvent
            "keyup": 5, // KeyboardEvent

            "message": 6, // MessageEvent

            "click": 7, // MouseEvent
            "contextmenu": 7, // MouseEvent
            "dblclick": 7, // MouseEvent
            "mousedown": 7, // MouseEvent
            "mouseup": 7, // MouseEvent
            "mousemove": 7, // MouseEvent
            "mouseover": 7, // MouseEvent
            "mouseout": 7, // MouseEvent
            "mouseenter": 7, // MouseEvent
            "mouseleave": 7, // MouseEvent


            "progress" : 11, //ProgressEvent

            "textInput": 12, // TextEvent

            "tap": 13,
            "touchstart": 13, // TouchEvent
            "touchmove": 13, // TouchEvent
            "touchend": 13, // TouchEvent

            "load": 14, // UIEvent
            "resize": 14, // UIEvent
            "select": 14, // UIEvent
            "scroll": 14, // UIEvent
            "unload": 14, // UIEvent,

            "wheel": 15, // WheelEvent

    };
 
  const Plugin = plugins.Plugin;

  var Widget = Plugin.inherit({
    klassName: "Widget",

    _construct : function(parent,elm,options) {
        if (parent && !(parent instanceof Widget || parent.element)) {
           options = elm;
           elm = parent;
           parent = null;
        }
        if (types.isHtmlNode(elm)) {
          options = this._parse(elm,options);
        } else {
          options = elm;
          elm = null;
        }
        if (types.isString(options)) {
          options = {
            tagName : options
          };
        }
        this.overrided(elm,options);

        if (!elm) {
          this._velm = this._create();
          this._elm = this._velm.elm();
        } else {
          this._velm = this.elmx(this._elm);
        }
        
        Object.defineProperty(this,"state",{
          value :this.options.state || new HashMap()
        });

        /** 
         * True if the element is visible.
         *
         * @attribute visible
         * @type {Boolean}
         */
        this.visible = true;
        

        //this.element.style.position = "absolute";
        //this.element.style.overflow = "hidden";

        /**
         * Size of this component in px.
         *
         * @attribute size
         * @type {Vector2}
         */
        this.size = new Vector2(0, 0);
        
        /**
         * Location of this component relatively to its parent in px.
         *
         * @attribute location
         * @type {Vector2}
         */
        this.location = new Vector2(0, 0);

        /**
         * Locationing mode, indicates how to anchor the component.
         *
         * @attribute mode
         * @type {Number}
         */
        this._mode = Widget.TOP_LEFT;


        if (parent) {
          this.setParent(parent);
        }
        
        
        //this.state = this.options.state || new Map();
        this._init();

        var addonCategoryOptions = this.options.addons;
        if (addonCategoryOptions) {
          var widgetCtor = this.constructor,
              addons = widgetCtor.addons;
          for (var categoryName in addonCategoryOptions) {
              for (var i =0;i < addonCategoryOptions[categoryName].length; i++ ) {
                var addonOption = addonCategoryOptions[categoryName][i];
                if (types.isString(addonOption)) {
                  var addonName = addonOption,
                      addonSetting = addons[categoryName][addonName],
                      addonCtor = addonSetting.ctor ? addonSetting.ctor : addonSetting;

                  this.addon(addonCtor,addonSetting.options);

                }

              }
          }
        }

        //if (this._elm.parentElement) {
        //  // The widget is already in document
        //  this._startup();
        //}
    },

    /**
     * Parses widget options from attached element.
     * This is a callback method called by constructor when attached element is specified.
     * @method _parse
     * @return {Object} options.
     */
    _parse : function(elm,options) {
      var optionsAttr = datax.data(elm,"options");
      if (optionsAttr) {
         //var options1 = JSON.parse("{" + optionsAttr + "}");
         var options1 = eval("({" + optionsAttr + "})");
         options = objects.mixin(options1,options); 
      }
      return options || {};
    },

    /**
     * Create html element for this widget.
     * This is a callback method called by constructor when attached element is not specified.
     * @method _create
     */
    _create : function() {
        var template = this.options.template;
        if (template) {
          return this.elmx(template);
        } else {
          var tagName = this.options.tagName;
          if (tagName) {
            return this.elmx(noder.createElement(tagName,{
              style : {
                position : "absolute",
                overflow : "hidden"
              }
            }))
          } else {
            throw new Error("The template or tagName is not existed in options!");
          }
        }
    },


    /**
     * Init widget.
     * This is a callback method called by constructor.
     * @method _init
     */
    _init : function() {
      var self = this;
      if (this.widgetClass) {
        this._velm.addClass(this.widgetClass);
      }
      this.state.on("changed",function(e,args) {
        self._refresh(args.data);
      });
    },


    /**
     * Startup widget.
     * This is a callback method called when widget element is added into dom.
     * @method _post
     */
    _startup : function() {

    },


    isNativeEvent : function(events) {
        if (types.isString(events)) {
            return !!NativeEvents[events];
        } else if (types.isArray(events)) {
            for (var i=0; i<events.length; i++) {
                if (NativeEvents[events[i]]) {
                    return true;
                }
            }
            return false;
        }            

    },   

    on : function(events, selector, data, callback, ctx, /*used internally*/ one) {
        if (this.el_ && this.isNativeEvent(events)) {
            eventer.on(this.el_,events,selector,data,callback,ctx,one);
        } else {
            Plugin.prototype.on.call(this,events, selector, data, callback, ctx,  one);
        }
    },   

    off : function(events, callback) {
        if (this.el_ && this.isNativeEvent(events)) {
            eventer.off(this.el_,events,callback);
        } else {
            Plugin.prototype.off.call(this,events,callback);
        }
    },

    listenTo : function(obj, event, callback, /*used internally*/ one) {
        if (types.isString(obj) || types.isArray(obj)) {
            one = callback;
            callback = event;
            event = obj;
            if (this.el_ && this.isNativeEvent(event)) {
                eventer.on(this.el_,event,callback,this,one);
            } else {
                this.on(event,callback,this,one);
            }
        } else {
            if (obj.nodeType) {
                eventer.on(obj,event,callback,this,one)
            } else {
                Plugin.prototype.listenTo.call(this,obj,event,callback,one)
            }                
        }
    },

    unlistenTo : function(obj, event, callback) {
        if (types.isString(obj) || types.isArray(obj)) {
            callback = event;
            event = obj;
            if (this.el_ && this.isNativeEvent(event)) {
                eventer.off(this.el_,event,callback);
            } else {
                this.off(event,callback);                   
            }
        } else {
            if (obj.nodeType) {
                eventer.off(obj,event,callback)
            } else {
                Plugin.prototype.unlistenTo.call(this,obj,event,callback)
            }
        }
    },

    /**
     * Update the location of this widget.
     * 
     * @method updateLocation
     */
    updateLocation : function(mode) {
      if(mode !== undefined) {
        this._mode = mode;
      }

      if(this._mode === Widget.TOP_LEFT || this._mode === Widget.TOP_RIGHT) {
        this._elm.style.top = this.location.y + "px";
      } else {
        this._elm.style.bottom = this.location.y + "px";
      }

      if(this._mode === Widget.TOP_LEFT || this._mode === Widget.BOTTOM_LEFT) {
        this._elm.style.left = this.location.x + "px";
      } else {
        this._elm.style.right = this.location.x + "px";
      }
    },

    /**
     * Update the size of this widget.
     * 
     * @method updateSize
     */
    updateSize : function(){
      this._elm.style.width = this.size.x + "px";
      this._elm.style.height = this.size.y + "px";
    },


    /**
     * Update visibility of this element.
     *
     * @method setVisibility
     */
    setVisibility : function(visible)   {
      this.visible = visible;
      this.updateVisibility();
    },


    /**
     * Update the visibility of this widget.
     *
     * @method updateVisibility
     */
    updateVisibility : function() {
      this._elm.style.display = this.visible ? "block" : "none";
    },


    /**
     * Refresh widget.
     * This is a callback method called when widget state is changed.
     * @method _refresh
     */
    _refresh : function(updates) {
      /*
      var _ = this._,
          model = _.model,
          dom = _.dom,
          props = {

          };
      updates = updates || {};
      for (var attrName in updates){
          var v = updates[attrName].value;
          if (v && v.toCss) {
              v.toCss(props);
              updates[attrName].processed = true;
          }

      };

      this.css(props);

      if (updates["disabled"]) {
          var v = updates["disabled"].value;
          dom.aria('disabled', v);
          self.classes.toggle('disabled', v);
      }
      */
    },                

    mapping : {
      "events" : {
  //       'mousedown .title':  'edit',
  //       'click .button':     'save',
  //       'click .open':       function(e) { ... }            
      },

      "attributs" : {

      },

      "properties" : {

      },

      "styles" : {

      }
    },

    addon : function(ctor,setting) {
      var categoryName = ctor.categoryName,
          addonName = ctor.addonName;

      this._addons = this.addons || {};
      var category = this._addons[categoryName] = this._addons[categoryName] || {};
      category[addonName] = new ctor(this,setting);
      return this;
    },

    addons : function(categoryName,settings) {
      this._addons = this.addons || {};
      var category = this._addons[categoryName] = this._addons[categoryName] || {};

      if (settings == undefined) {
        return objects.clone(category || null);
      } else {
        objects.mixin(category,settings);
      }
    },


    /**
     * Returns a html element representing the widget.
     *
     * @method render
     * @return {HtmlElement} HTML element representing the widget.
     */
    render: function() {
      return this._elm;
    },



    /**
     * Returns a parent widget  enclosing this widgets, or null if not exist.
     *
     * @method getEnclosing
     * @return {Widget} The enclosing parent widget, or null if not exist.
     */
    getEnclosing : function(selector) {
      return null;
    },

    /**
     * Returns a widget collection with all enclosed child widgets.
     *
     * @method getEnclosed
     * @return {List} Collection with all enclosed child widgets..
     */
    getEnclosed : function() {
      var self = this;
          children = new ArrayList();
      return children;
    },


    getSkin : function() {
      return SkinManager.get();
    },

    /**
     * Sets the visible state to true.
     *
     * @method show
     * @return {Widget} Current widget instance.
     */

    show : function() {
      this._velm.show();
    },

    /**
     * Sets the visible state to false.
     *
     * @method hide
     * @return {Widget} Current widget instance.
     */
    hide : function() {
      this._velm.hide();
    },

    /**
     * Focuses the current widget.
     *
     * @method focus
     * @return {Widget} Current widget instance.
     */
    focus :function() {
      try {
        this._velm.focus();
      } catch (ex) {
        // Ignore IE error
      }

      return this;
    },

    /**
     * Blurs the current widget.
     *
     * @method blur
     * @return {Widget} Current widget instance.
     */
    blur : function() {
      this._velm.blur();

      return this;
    },

    enable: function () {
      this.state.set('disabled',false);
      return this;
    },

    disable: function () {
      this.state.set('disabled',true);
      return this;
    },


    /** 
     * Add a CSS class to the base DOM element of this widget element.
     * 
     * @method addClass
     * @param {String} name Name of the class to be added.
     */
    addClass : function(name){
      this._velm.addClass(name);
      return this;
    },

    /** 
     * Determine whether this widget element is assigned the given class.
     * 
     * @method hasClass
     * @param {String} name Name of the class t.
     */
    hasClass : function(name){
      return this._velm.hasClass(name);
    },

    offset : function() {
        return this._velm.pagePosition();
    },

    outerWidth : function() {
        return this._velm.marginSize().width;
    },

    outerHeight : function() {
        return this._velm.marginSize().height;
    },

    /** 
     * Remove a CSS class from the base DOM element of this idget element.
     * 
     * @method removeClass
     * @param {String} name Name of the class to be removed.
     */
    removeClass: function(name) {
      this._velm.removeClass(name);
      return this;
    },

    /** 
     * Remove a CSS class from the base DOM element of this idget element.
     * 
     * @method removeClass
     * @param {String} name Name of the class to be removed.
     */
    toggleClass: function(name) {
      this._velm.toggleClass(name);
      return this;
    },

    /**
     * Sets the specified aria property.
     *
     * @method aria
     * @param {String} name Name of the aria property to set.
     * @param {String} value Value of the aria property.
     * @return {Widget} Current widget instance.
     */
    aria : function(name, value) {
      const self = this, elm = self.getEl(self.ariaTarget);

      if (typeof value === 'undefined') {
        return self._aria[name];
      }

      self._aria[name] = value;

      if (self.state.get('rendered')) {
        elm.setAttribute(name === 'role' ? name : 'aria-' + name, value);
      }

      return self;
    },

    attr: function (name,value) {
        var velm = this._velm,
            ret = velm.attr(name,value);
        return ret == velm ? this : ret;
    },

    getAttr : function(name) {
      return this._velm.attr(name);
    },

    setAttr : function(name,value) {
      this._velm.attr(name,value);
      return this;
    },

    removeAttr : function(name) {
      this._velm.removeAttr(name);
      return this;
    },


    /**
     * Calculate the location of the container to make it centered.
     *
     * Calculated relatively to its parent size.
     * 
     * @method center
     */
    center : function() {
      this.location.set((this.parent.size.x - this.size.x) / 2, (this.parent.size.y - this.size.y) / 2);
    },

    css: function (name, value) {
        var velm = this._velm,
            ret = velm.css(name, value);
        return ret == velm ? this : ret;
    },

    getStyle : function(name) {
      return this._velm.css(name);
    },

    setStyle : function(name,value) {
      this._velm.css(name,value);
      return this;
    },

    data: function (name, value) {
        var velm = this._velm,
            ret = velm.data(name,value);
        return ret == velm ? this : ret;
    },


    getData : function(name) {
      return this._velm.data(name);
    },

    setData : function(name,value) {
      this._velm.data(name,value);
      return this;
    },


    parent : {
      get : function() {
        return this.getParent();
      },
      set : function(v) {
        this.setParent(v);
      }
    },

    getParent : function() {
      return this._parent;
    },

    setParent : function(parent) {
      var oldParent = this._parent;
      this._parent = parent;
      if (parent) {
        this.mount(parent._elm || parent.element);
        if (parent._setupChild) {
          parent._setupChild(this);
        }
      } else if (oldParent) {
        this.unmount();
      }
      return this;
    },


    prop: function (name,value) {
        var velm = this._velm,
            ret = velm.prop(name,value);
        return ret == velm ? this : ret;
    },

    getProp : function(name) {
      return this._velm.prop(name);
    },

    setProp : function(name,value) {
      this._velm.prop(name,value);
      return this;
    },

    throb: function(params) {
      if (this.options.throbber) {
        params = objects.defaults(params,this.options.throbber);
      }
      return noder.throb(this._elm,params);
    },

    /*
    emit : function(type,params) {
      var e = events.createEvent(type,{
        data : params
      });
      return events.Emitter.prototype.emit.call(this,e,params);
    },
    */

    /**
     * Update component appearance.
     * 
     * Should be called after changing size or location.
     *
     * Uses the updateVisibility and if the element is visible calls the updateSize and updateLocation (in this order) methods to update the interface.
     * 
     * @method update
     */
    update : function() {
      this.updateVisibility();

      if(this.visible) {
        this.updateSize();
        this.updateLocation();
      }
    },


    /**
     *  mount the current widget element to dom document.
     *
     * @method mount
     * @return {Widget} This Widget.
     */
    mount : function(target,position){
        var toElm = target.element || target,
            elm = this._elm;
        if (!position || position=="child") {
            noder.append(toElm,elm);
        } else  if (position == "before") {
            noder.before(toElm,elm);
        } else if (position == "after") {
            noder.after(toElm,elm);
        } else if (position == "prepend") {
            noder.prepend(toElm,elm);         
        }
        this._startup();
    },

    /**
     *  unmount the current widget element from dom document.
     *
     * @method html
     * @return {HtmlElement} HTML element representing the widget.
     */
    unmount : function() {
      this._velm.remove();
    },

    preventDragEvents : function() {
      this.element.ondrop = Widget.preventDefault;
      this.element.ondragover = Widget.preventDefault;
    },


    element : {
      get : function() {
        return this._elm;
      },

      set : function(v) {
        this._elm = v;
      }
    },

    position : {
      get : function() {
        return this.location;
      },

      set : function(v) {
        this.location = v;
      }
    },

    /**
     * Set alt text, that is displayed when the mouse is over the element. Returns the element created that is attached to the document body.
     *
     * @method setAltText
     * @param {String} altText Alt text.
     */
    setAltText : function(altText)   {
      var element = document.createElement("div");
      element.style.position = "absolute";
      element.style.display = "none";
      element.style.alignItems = "center";
      element.style.zIndex = "10000";
      element.style.border = "3px solid";
      element.style.borderRadius = "5px";
      element.style.color = Editor.theme.textColor;
      element.style.backgroundColor = Editor.theme.barColor;
      element.style.borderColor = Editor.theme.barColor;
      element.style.height = "fit-content";
      document.body.appendChild(element);

      //Text
      var text = document.createTextNode(altText);
      element.appendChild(text);

      //Destroy
      var destroyFunction = this.destroy;
      this.destroy = function()
      { 
        destroyFunction.call(this);

        if(document.body.contains(element))
        {
          document.body.removeChild(element);
        }
      };
      
      this._elm.style.pointerEvents = "auto"; 

      //Mouse mouse move event
      this._elm.onmousemove = function(event) {
        element.style.display = "flex";
        element.style.left = (event.clientX + 8) + "px";
        element.style.top = (event.clientY - 20) + "px";
      };

      //Mouse out event
      this._elm.onmouseout = function()  {
        element.style.display = "none";
      };

      return element;
    },

    /**
     * Set method to be called on component click.
     * 
     * @method setOnClick
     * @param {Function} callback Function called when the component is clicked.
     */
    setOnClick : function(callback)  {
      this._elm.onclick = callback;
    },

    /**
     * Remove all DOM children from the element.
     * 
     * @method removeAllChildren
     */
    removeAllChildren : function()   {
      while(this._elm.firstChild) {
        this._elm.removeChild(this._elm.firstChild);
      }
    },

    /**
     * Set positioning mode.
     * 
     * @method setMode
     * @param {Number} setMode
     */
    setMode : function(mode) {
      this._mode = mode;
      this._elm.style.bottom = null;
      this._elm.style.right = null;
      this._elm.style.left = null;
    },


    /**
     * Called to destroy a component.
     *
     * Destroy the element and removes it from its DOM parent.
     * 
     * @method destroy
     */
    destroy : function()
    {
      if(this._parent)
      {
        if(this._parent.element)
        {
          if(this._parent.element.contains(this.element))
          {
            this._parent.element.removeChild(this.element);
            this._parent = null;
          }
        }
        else
        {
          console.warn("nunuStudio: Parent is not a Element.", this);
          if(this._parent.contains(this.element))
          {
            this._parent.removeChild(this.element);
            this._parent = null;
          }
        }
      }
    }

  });

  Widget.prototype.updateInterface = Widget.prototype.update;
  Widget.prototype.updatePosition = Widget.prototype.updateLocation;
  Widget.prototype.attachTo = Widget.prototype.setParent;
  Widget.prototype._attachTo = Widget.prototype.mount;
  Widget.prototype.detach = Widget.prototype.unmount;

  /**
   * Top-left locationing.
   *
   * @static
   * @attribute TOP_LEFT
   * @type {Number}
   */
  Widget.TOP_LEFT = 0;

  /**
   * Top-right locationing.
   *
   * @static
   * @attribute TOP_RIGHT
   * @type {Number}
   */
  Widget.TOP_RIGHT = 1;

  /**
   * Bottom-left locationing.
   *
   * @static
   * @attribute BOTTOM_LEFT
   * @type {Number}
   */
  Widget.BOTTOM_LEFT = 2;

  /**
   * Bottom-right locationing.
   *
   * @static
   * @attribute BOTTOM_RIGHT
   * @type {Number}
   */
  Widget.BOTTOM_RIGHT = 3;

  Widget.inherit = function(meta) {
    var ctor = plugins.Plugin.inherit.apply(this,arguments);

    function addStatePropMethod(name) {
        ctor.prototype[name] = function(value) {
          if (value !== undefined) {
            this.state.set(name,value);
            return this;
          } else {
            return this.state.get(name);
          }
        };
    }
    if (meta.state) {
      for (var name in meta.state) {
          addStatePropMethod(name);
      }
    }

    if (meta.pluginName) {
      plugins.register(ctor,meta.pluginName);
    }
    return ctor;
  };

  Widget.register = function(ctor,widgetName) {
    var meta = ctor.prototype,
        pluginName = widgetName || meta.pluginName;

    function addStatePropMethod(name) {
        ctor.prototype[name] = function(value) {
          if (value !== undefined) {
            this.state.set(name,value);
            return this;
          } else {
            return this.state.get(name);
          }
        };
    }
    if (meta.state) {
      for (var name in meta.state) {
          addStatePropMethod(name);
      }
    }

    if (pluginName) {
      plugins.register(ctor,pluginName);
    }
    return ctor;
  };

  Widget.preventDefault = function(event)
  {
    event.preventDefault();
  };

  return base.Widget = Widget;
});

define('skylark-videojs/mixins/stateful',[
    ///'./evented',
    '../utils/obj'
], function (Obj) {
    'use strict';
    const StatefulMixin = {
        state: {},
        setState(stateUpdates) {
            if (typeof stateUpdates === 'function') {
                stateUpdates = stateUpdates();
            }
            let changes;
            Obj.each(stateUpdates, (value, key) => {
                if (this.state[key] !== value) {
                    changes = changes || {};
                    changes[key] = {
                        from: this.state[key],
                        to: value
                    };
                }
                this.state[key] = value;
            });
            //if (changes && evented.isEvented(this)) {
            if (changes && this.trigger) {
                this.trigger({
                    changes,
                    type: 'statechanged'
                });
            }
            return changes;
        }
    };
    function stateful(target, defaultState) {
        Obj.assign(target, StatefulMixin);
        target.state = Obj.assign({}, target.state, defaultState);
        ///if (typeof target.handleStateChanged === 'function' && evented.isEvented(target)) {
        if (typeof target.handleStateChanged === 'function' && target.on) {
            target.on('statechanged', target.handleStateChanged);
        }
        return target;
    }
    return stateful;
});
define('skylark-videojs/utils/guid',[],function () {
    'use strict';
    const _initialGuid = 3;
    let _guid = _initialGuid;
    function newGUID() {
        return _guid++;
    }
    function resetGuidInTestsOnly() {
        _guid = _initialGuid;
    }
    return {
        newGUID: newGUID,
        resetGuidInTestsOnly: resetGuidInTestsOnly
    };
});
define('skylark-videojs/utils/dom-data',[
    './log',
    './guid'
], function (log, Guid) {
    'use strict';
    let FakeWeakMap;
    if (!window.WeakMap) {
        FakeWeakMap = class {
            constructor() {
                this.vdata = 'vdata' + Math.floor(window.performance && window.performance.now() || Date.now());
                this.data = {};
            }
            set(key, value) {
                const access = key[this.vdata] || Guid.newGUID();
                if (!key[this.vdata]) {
                    key[this.vdata] = access;
                }
                this.data[access] = value;
                return this;
            }
            get(key) {
                const access = key[this.vdata];
                if (access) {
                    return this.data[access];
                }
                log('We have no data for this element', key);
                return undefined;
            }
            has(key) {
                const access = key[this.vdata];
                return access in this.data;
            }
            delete(key) {
                const access = key[this.vdata];
                if (access) {
                    delete this.data[access];
                    delete key[this.vdata];
                }
            }
        };
    }
    return window.WeakMap ? new WeakMap() : new FakeWeakMap();
});
define('skylark-videojs/utils/fn',[
    'skylark-langx-funcs',
    './guid'
], function (funcs,GUID) {
    'use strict';
    const UPDATE_REFRESH_INTERVAL = 30;
    const bind = function (context, fn, uid) {
        if (!fn.guid) {
            fn.guid = GUID.newGUID();
        }
        const bound = fn.bind(context);
        bound.guid = uid ? uid + '_' + fn.guid : fn.guid;
        return bound;
    };
    const throttle = function (fn, wait) {
        let last = window.performance.now();
        const throttled = function (...args) {
            const now = window.performance.now();
            if (now - last >= wait) {
                fn(...args);
                last = now;
            }
        };
        return throttled;
    };
    const debounce = function (func, wait, immediate, context = window) {
        let timeout;
        const cancel = () => {
            context.clearTimeout(timeout);
            timeout = null;
        };
        const debounced = function () {
            const self = this;
            const args = arguments;
            let later = function () {
                timeout = null;
                later = null;
                if (!immediate) {
                    func.apply(self, args);
                }
            };
            if (!timeout && immediate) {
                func.apply(self, args);
            }
            context.clearTimeout(timeout);
            timeout = context.setTimeout(later, wait);
        };
        debounced.cancel = cancel;
        return debounced;
    };
    return {
        UPDATE_REFRESH_INTERVAL: UPDATE_REFRESH_INTERVAL,
        bind: bind,
        throttle: funcs.throttle, //throttle,
        debounce: funcs.debounce //debounce
    };
});
define('skylark-videojs/utils/string-cases',[],function () {
    'use strict';
    const toLowerCase = function (string) {
        if (typeof string !== 'string') {
            return string;
        }
        return string.replace(/./, w => w.toLowerCase());
    };
    const toTitleCase = function (string) {
        if (typeof string !== 'string') {
            return string;
        }
        return string.replace(/./, w => w.toUpperCase());
    };
    const titleCaseEquals = function (str1, str2) {
        return toTitleCase(str1) === toTitleCase(str2);
    };
    return {
        toLowerCase: toLowerCase,
        toTitleCase: toTitleCase,
        titleCaseEquals: titleCaseEquals
    };
});
define('skylark-videojs/utils/merge-options',[
    "skylark-langx",
    './obj'
], function (langx,obj) {
    'use strict';
    /*
    function mergeOptions(...sources) {
        const result = {};
        sources.forEach(source => {
            if (!source) {
                return;
            }
            obj.each(source, (value, key) => {
                if (!obj.isPlain(value)) {
                    result[key] = value;
                    return;
                }
                if (!obj.isPlain(result[key])) {
                    result[key] = {};
                }
                result[key] = mergeOptions(result[key], value);
            });
        });
        return result;
    }
    return mergeOptions;
    */
    return function(...sources) {
        var result = {};
        langx.mixin(result,...sources,true);
        return result;
    }
});
define('skylark-videojs/utils/map',[], function () {
    'use strict';
    class MapSham {
        constructor() {
            this.map_ = {};
        }
        has(key) {
            return key in this.map_;
        }
        delete(key) {
            const has = this.has(key);
            delete this.map_[key];
            return has;
        }
        set(key, value) {
            this.map_[key] = value;
            return this;
        }
        forEach(callback, thisArg) {
            for (const key in this.map_) {
                callback.call(thisArg, this.map_[key], key, this);
            }
        }
    }
    return window.Map ? window.Map : MapSham;
});
define('skylark-videojs/utils/set',[], function () {
    'use strict';
    class SetSham {
        constructor() {
            this.set_ = {};
        }
        has(key) {
            return key in this.set_;
        }
        delete(key) {
            const has = this.has(key);
            delete this.set_[key];
            return has;
        }
        add(key) {
            this.set_[key] = 1;
            return this;
        }
        forEach(callback, thisArg) {
            for (const key in this.set_) {
                callback.call(thisArg, key, key, this);
            }
        }
    }
    return window.Set ? window.Set : SetSham;
});
define('skylark-videojs/component',[
    "skylark-langx",
    "skylark-domx-eventer",
    "skylark-widgets-base/Widget",
    ///'./mixins/evented',
    './mixins/stateful',
    './utils/dom',
    './utils/dom-data',
    './utils/fn',
    './utils/guid',
    './utils/string-cases',
    './utils/merge-options',
    './utils/computed-style',
    './utils/map',
    './utils/set'
], function (langx,eventer,Widget, stateful, Dom, DomData, Fn, Guid, stringCases, mergeOptions, computedStyle, Map, Set) {
    'use strict';

    function isNativeEvent(el,events) {
        if (langx.isString(events)) {
            return el["on"+ events] !== undefined;
        } else if (langx.isArray(events)) {
            for (var i=0; i<events.length; i++) {
                if (el["on"+ events[i]] !== undefined) {
                    return true;
                }
            }
            return events.length > 0;
        }
    }


    class Component extends Widget {
        _construct(player, options, ready) {
            if (!player && this.play) {
                this.player_ = player = this;
            } else {
                this.player_ = player;
            }
            this.options_ = mergeOptions({}, this.options_);
            this.options_ = mergeOptions(this.options_, options);
            this.ready_ = ready;

            super._construct(this.options_,ready);

        }

        _create() {
            var options = this.options_ = this.options;

            if (options.el) {
               this.el_ = options.el;
            } else if (options.createEl !== false) {
                this.el_ = this.createEl();
            }

            return this.elmx(this.el_)
        }

        _init() {
            var options = this.options_,
                player = this.player_;

            this.isDisposed_ = false;
            this.parentComponent_ = null;
            this.id_ = options.id || options.el && options.el.id;
            if (!this.id_) {
                const id = player && player.id && player.id() || 'no_player';
                this.id_ = `${ id }_component_${ Guid.newGUID() }`;
            }
            this.name_ = options.name || null;


            if (options.evented !== false) {
                ///evented(this, { eventBusKey: this.el_ ? 'el_' : null });
                this.handleLanguagechange = this.handleLanguagechange.bind(this);
                ///this.listenTo(this.player_, 'languagechange', this.handleLanguagechange);
                this.listenTo(this.player_, 'languagechange', this.handleLanguagechange);
            }


            ///stateful(this, this.constructor.defaultState);
            this.children_ = [];
            this.childIndex_ = {};
            this.childNameIndex_ = {};
            this.setTimeoutIds_ = new Set();
            this.setIntervalIds_ = new Set();
            this.rafIds_ = new Set();
            this.namedRafs_ = new Map();
            this.clearingTimersOnDispose_ = false;
            if (options.initChildren !== false) {
                this.initChildren();
            }
            this.ready(this.ready_);
            if (options.reportTouchActivity !== false) {
                this.enableTouchActivity();
            }

        }

        dispose() {
            if (this.isDisposed_) {
                return;
            }
            if (this.readyQueue_) {
                this.readyQueue_.length = 0;
            }
            this.trigger({
                type: 'dispose',
                bubbles: false
            });
            this.isDisposed_ = true;
            if (this.children_) {
                for (let i = this.children_.length - 1; i >= 0; i--) {
                    if (this.children_[i].dispose) {
                        this.children_[i].dispose();
                    }
                }
            }
            this.children_ = null;
            this.childIndex_ = null;
            this.childNameIndex_ = null;
            this.parentComponent_ = null;
            if (this.el_) {
                if (this.el_.parentNode) {
                    this.el_.parentNode.removeChild(this.el_);
                }
                ///if (DomData.has(this.el_)) {
                ///    DomData.delete(this.el_);
                ///}
                eventer.clear(this.el_);
                this.el_ = null;
            }
            this.player_ = null;
        }
        isDisposed() {
            return Boolean(this.isDisposed_);
        }
        player() {
            return this.player_;
        }
        options(obj) {
            if (!obj) {
                return this.options_;
            }
            this.options_ = mergeOptions(this.options_, obj);
            return this.options_;
        }
        el() {
            return this.el_;
        }
        createEl(tagName, properties, attributes) {
            return Dom.createEl(tagName, properties, attributes);
        }
        localize(string, tokens, defaultValue = string) {
            const code = this.player_.language && this.player_.language();
            const languages = this.player_.languages && this.player_.languages();
            const language = languages && languages[code];
            const primaryCode = code && code.split('-')[0];
            const primaryLang = languages && languages[primaryCode];
            let localizedString = defaultValue;
            if (language && language[string]) {
                localizedString = language[string];
            } else if (primaryLang && primaryLang[string]) {
                localizedString = primaryLang[string];
            }
            if (tokens) {
                localizedString = localizedString.replace(/\{(\d+)\}/g, function (match, index) {
                    const value = tokens[index - 1];
                    let ret = value;
                    if (typeof value === 'undefined') {
                        ret = match;
                    }
                    return ret;
                });
            }
            return localizedString;
        }
        handleLanguagechange() {
        }
        contentEl() {
            return this.contentEl_ || this.el_;
        }
        id() {
            return this.id_;
        }
        name() {
            return this.name_;
        }
        children() {
            return this.children_;
        }
        getChildById(id) {
            return this.childIndex_[id];
        }
        getChild(name) {
            if (!name) {
                return;
            }
            return this.childNameIndex_[name];
        }
        getDescendant(...names) {
            names = names.reduce((acc, n) => acc.concat(n), []);
            let currentChild = this;
            for (let i = 0; i < names.length; i++) {
                currentChild = currentChild.getChild(names[i]);
                if (!currentChild || !currentChild.getChild) {
                    return;
                }
            }
            return currentChild;
        }
        addChild(child, options = {}, index = this.children_.length) {
            let component;
            let componentName;
            if (typeof child === 'string') {
                componentName = stringCases.toTitleCase(child);
                const componentClassName = options.componentClass || componentName;
                options.name = componentName;
                const ComponentClass = Component.getComponent(componentClassName);
                if (!ComponentClass) {
                    throw new Error(`Component ${ componentClassName } does not exist`);
                }
                if (typeof ComponentClass !== 'function') {
                    return null;
                }
                component = new ComponentClass(this.player_ || this, options);
            } else {
                component = child;
            }
            if (component.parentComponent_) {
                component.parentComponent_.removeChild(component);
            }
            this.children_.splice(index, 0, component);
            component.parentComponent_ = this;
            if (typeof component.id === 'function') {
                this.childIndex_[component.id()] = component;
            }
            componentName = componentName || component.name && stringCases.toTitleCase(component.name());
            if (componentName) {
                this.childNameIndex_[componentName] = component;
                this.childNameIndex_[stringCases.toLowerCase(componentName)] = component;
            }
            if (typeof component.el === 'function' && component.el()) {
                let refNode = null;
                if (this.children_[index + 1]) {
                    if (this.children_[index + 1].el_) {
                        refNode = this.children_[index + 1].el_;
                    } else if (Dom.isEl(this.children_[index + 1])) {
                        refNode = this.children_[index + 1];
                    }
                }
                this.contentEl().insertBefore(component.el(), refNode);
            }
            return component;
        }
        removeChild(component) {
            if (typeof component === 'string') {
                component = this.getChild(component);
            }
            if (!component || !this.children_) {
                return;
            }
            let childFound = false;
            for (let i = this.children_.length - 1; i >= 0; i--) {
                if (this.children_[i] === component) {
                    childFound = true;
                    this.children_.splice(i, 1);
                    break;
                }
            }
            if (!childFound) {
                return;
            }
            component.parentComponent_ = null;
            this.childIndex_[component.id()] = null;
            this.childNameIndex_[stringCases.toTitleCase(component.name())] = null;
            this.childNameIndex_[stringCases.toLowerCase(component.name())] = null;
            const compEl = component.el();
            if (compEl && compEl.parentNode === this.contentEl()) {
                this.contentEl().removeChild(component.el());
            }
        }
        initChildren() {
            const children = this.options_.children;
            if (children) {
                const parentOptions = this.options_;
                const handleAdd = child => {
                    const name = child.name;
                    let opts = child.opts;
                    if (parentOptions[name] !== undefined) {
                        opts = parentOptions[name];
                    }
                    if (opts === false) {
                        return;
                    }
                    if (opts === true) {
                        opts = {};
                    }
                    opts.playerOptions = this.options_.playerOptions;
                    const newChild = this.addChild(name, opts);
                    if (newChild) {
                        this[name] = newChild;
                    }
                };
                let workingChildren;
                const Tech = Component.getComponent('Tech');
                if (Array.isArray(children)) {
                    workingChildren = children;
                } else {
                    workingChildren = Object.keys(children);
                }
                workingChildren.concat(Object.keys(this.options_).filter(function (child) {
                    return !workingChildren.some(function (wchild) {
                        if (typeof wchild === 'string') {
                            return child === wchild;
                        }
                        return child === wchild.name;
                    });
                })).map(child => {
                    let name;
                    let opts;
                    if (typeof child === 'string') {
                        name = child;
                        opts = children[name] || this.options_[name] || {};
                    } else {
                        name = child.name;
                        opts = child;
                    }
                    return {
                        name,
                        opts
                    };
                }).filter(child => {
                    const c = Component.getComponent(child.opts.componentClass || stringCases.toTitleCase(child.name));
                    return c && !Tech.isTech(c);
                }).forEach(handleAdd);
            }
        }
        buildCSSClass() {
            return '';
        }
        ready(fn, sync = false) {
            if (!fn) {
                return;
            }
            if (!this.isReady_) {
                this.readyQueue_ = this.readyQueue_ || [];
                this.readyQueue_.push(fn);
                return;
            }
            if (sync) {
                fn.call(this);
            } else {
                this.setTimeout(fn, 1);
            }
        }
        triggerReady() {
            this.isReady_ = true;
            this.setTimeout(function () {
                const readyQueue = this.readyQueue_;
                this.readyQueue_ = [];
                if (readyQueue && readyQueue.length > 0) {
                    readyQueue.forEach(function (fn) {
                        fn.call(this);
                    }, this);
                }
                this.trigger('ready');
            }, 1);
        }
        $(selector, context) {
            return Dom.$(selector, context || this.contentEl());
        }
        $$(selector, context) {
            return Dom.$$(selector, context || this.contentEl());
        }
/*
        hasClass(classToCheck) {
            return Dom.hasClass(this.el_, classToCheck);
        }
        addClass(classToAdd) {
            Dom.addClass(this.el_, classToAdd);
        }
        removeClass(classToRemove) {
            Dom.removeClass(this.el_, classToRemove);
        }
        toggleClass(classToToggle, predicate) {
            Dom.toggleClass(this.el_, classToToggle, predicate);
        }
        show() {
            this.removeClass('vjs-hidden');
        }
        hide() {
            this.addClass('vjs-hidden');
        }
*/  
        lockShowing() {
            this.addClass('vjs-lock-showing');
        }
        unlockShowing() {
            this.removeClass('vjs-lock-showing');
        }
/*
        getAttribute(attribute) {
            return Dom.getAttribute(this.el_, attribute);
        }
        setAttribute(attribute, value) {
            Dom.setAttribute(this.el_, attribute, value);
        }
        removeAttribute(attribute) {
            Dom.removeAttribute(this.el_, attribute);
        }
*/
        width(num, skipListeners) {
            return this.dimension('width', num, skipListeners);
        }
        height(num, skipListeners) {
            return this.dimension('height', num, skipListeners);
        }
        dimensions(width, height) {
            this.width(width, true);
            this.height(height);
        }
        dimension(widthOrHeight, num, skipListeners) {
            if (num !== undefined) {
                if (num === null || num !== num) {
                    num = 0;
                }
                if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
                    this.el_.style[widthOrHeight] = num;
                } else if (num === 'auto') {
                    this.el_.style[widthOrHeight] = '';
                } else {
                    this.el_.style[widthOrHeight] = num + 'px';
                }
                if (!skipListeners) {
                    this.trigger('componentresize');
                }
                return;
            }
            if (!this.el_) {
                return 0;
            }
            const val = this.el_.style[widthOrHeight];
            const pxIndex = val.indexOf('px');
            if (pxIndex !== -1) {
                return parseInt(val.slice(0, pxIndex), 10);
            }
            return parseInt(this.el_['offset' + stringCases.toTitleCase(widthOrHeight)], 10);
        }
        currentDimension(widthOrHeight) {
            let computedWidthOrHeight = 0;
            if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
                throw new Error('currentDimension only accepts width or height value');
            }
            computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
            computedWidthOrHeight = parseFloat(computedWidthOrHeight);
            if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
                const rule = `offset${ stringCases.toTitleCase(widthOrHeight) }`;
                computedWidthOrHeight = this.el_[rule];
            }
            return computedWidthOrHeight;
        }
        currentDimensions() {
            return {
                width: this.currentDimension('width'),
                height: this.currentDimension('height')
            };
        }
        currentWidth() {
            return this.currentDimension('width');
        }
        currentHeight() {
            return this.currentDimension('height');
        }
/*
        focus() {
            this.el_.focus();
        }
        blur() {
            this.el_.blur();
        }
*/
        handleKeyDown(event) {
            if (this.player_) {
                event.stopPropagation();
                this.player_.handleKeyDown(event);
            }
        }
        handleKeyPress(event) {
            this.handleKeyDown(event);
        }
        emitTapEvents() {
            let touchStart = 0;
            let firstTouch = null;
            const tapMovementThreshold = 10;
            const touchTimeThreshold = 200;
            let couldBeTap;
            this.listenTo('touchstart', function (event) {
                if (event.touches.length === 1) {
                    firstTouch = {
                        pageX: event.touches[0].pageX,
                        pageY: event.touches[0].pageY
                    };
                    touchStart = window.performance.now();
                    couldBeTap = true;
                }
            });
            this.listenTo('touchmove', function (event) {
                if (event.touches.length > 1) {
                    couldBeTap = false;
                } else if (firstTouch) {
                    const xdiff = event.touches[0].pageX - firstTouch.pageX;
                    const ydiff = event.touches[0].pageY - firstTouch.pageY;
                    const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                    if (touchDistance > tapMovementThreshold) {
                        couldBeTap = false;
                    }
                }
            });
            const noTap = function () {
                couldBeTap = false;
            };
            this.listenTo('touchleave', noTap);
            this.listenTo('touchcancel', noTap);
            this.listenTo('touchend', function (event) {
                firstTouch = null;
                if (couldBeTap === true) {
                    const touchTime = window.performance.now() - touchStart;
                    if (touchTime < touchTimeThreshold) {
                        event.preventDefault();
                        this.trigger('tap');
                    }
                }
            });
        }
        enableTouchActivity() {
            if (!this.player() || !this.player().reportUserActivity) {
                return;
            }
            const report = Fn.bind(this.player(), this.player().reportUserActivity);
            let touchHolding;
            this.listenTo('touchstart', function () {
                report();
                this.clearInterval(touchHolding);
                touchHolding = this.setInterval(report, 250);
            });
            const touchEnd = function (event) {
                report();
                this.clearInterval(touchHolding);
            };
            this.listenTo('touchmove', report);
            this.listenTo('touchend', touchEnd);
            this.listenTo('touchcancel', touchEnd);
        }
        setTimeout(fn, timeout) {
            var timeoutId, disposeFn;
            fn = Fn.bind(this, fn);
            this.clearTimersOnDispose_();
            timeoutId = window.setTimeout(() => {
                if (this.setTimeoutIds_.has(timeoutId)) {
                    this.setTimeoutIds_.delete(timeoutId);
                }
                fn();
            }, timeout);
            this.setTimeoutIds_.add(timeoutId);
            return timeoutId;
        }
        clearTimeout(timeoutId) {
            if (this.setTimeoutIds_.has(timeoutId)) {
                this.setTimeoutIds_.delete(timeoutId);
                window.clearTimeout(timeoutId);
            }
            return timeoutId;
        }
        setInterval(fn, interval) {
            fn = Fn.bind(this, fn);
            this.clearTimersOnDispose_();
            const intervalId = window.setInterval(fn, interval);
            this.setIntervalIds_.add(intervalId);
            return intervalId;
        }
        clearInterval(intervalId) {
            if (this.setIntervalIds_.has(intervalId)) {
                this.setIntervalIds_.delete(intervalId);
                window.clearInterval(intervalId);
            }
            return intervalId;
        }
        requestAnimationFrame(fn) {
            if (!this.supportsRaf_) {
                return this.setTimeout(fn, 1000 / 60);
            }
            this.clearTimersOnDispose_();
            var id;
            fn = Fn.bind(this, fn);
            id = window.requestAnimationFrame(() => {
                if (this.rafIds_.has(id)) {
                    this.rafIds_.delete(id);
                }
                fn();
            });
            this.rafIds_.add(id);
            return id;
        }
        requestNamedAnimationFrame(name, fn) {
            if (this.namedRafs_.has(name)) {
                return;
            }
            this.clearTimersOnDispose_();
            fn = Fn.bind(this, fn);
            const id = this.requestAnimationFrame(() => {
                fn();
                if (this.namedRafs_.has(name)) {
                    this.namedRafs_.delete(name);
                }
            });
            this.namedRafs_.set(name, id);
            return name;
        }
        cancelNamedAnimationFrame(name) {
            if (!this.namedRafs_.has(name)) {
                return;
            }
            this.cancelAnimationFrame(this.namedRafs_.get(name));
            this.namedRafs_.delete(name);
        }
        cancelAnimationFrame(id) {
            if (!this.supportsRaf_) {
                return this.clearTimeout(id);
            }
            if (this.rafIds_.has(id)) {
                this.rafIds_.delete(id);
                window.cancelAnimationFrame(id);
            }
            return id;
        }
        clearTimersOnDispose_() {
            if (this.clearingTimersOnDispose_) {
                return;
            }
            this.clearingTimersOnDispose_ = true;
            this.listenToOnce('dispose', () => {
                [
                    [
                        'namedRafs_',
                        'cancelNamedAnimationFrame'
                    ],
                    [
                        'rafIds_',
                        'cancelAnimationFrame'
                    ],
                    [
                        'setTimeoutIds_',
                        'clearTimeout'
                    ],
                    [
                        'setIntervalIds_',
                        'clearInterval'
                    ]
                ].forEach(([idName, cancelName]) => {
                    this[idName].forEach((val, key) => this[cancelName](key));
                });
                this.clearingTimersOnDispose_ = false;
            });
        }
        static registerComponent(name, ComponentToRegister) {
            if (typeof name !== 'string' || !name) {
                throw new Error(`Illegal component name, "${ name }"; must be a non-empty string.`);
            }
            const Tech = Component.getComponent('Tech');
            const isTech = Tech && Tech.isTech(ComponentToRegister);
            const isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);
            if (isTech || !isComp) {
                let reason;
                if (isTech) {
                    reason = 'techs must be registered using Tech.registerTech()';
                } else {
                    reason = 'must be a Component subclass';
                }
                throw new Error(`Illegal component, "${ name }"; ${ reason }.`);
            }
            name = stringCases.toTitleCase(name);
            if (!Component.components_) {
                Component.components_ = {};
            }
            const Player = Component.getComponent('Player');
            if (name === 'Player' && Player && Player.players) {
                const players = Player.players;
                const playerNames = Object.keys(players);
                if (players && playerNames.length > 0 && playerNames.map(pname => players[pname]).every(Boolean)) {
                    throw new Error('Can not register Player component after player has been created.');
                }
            }
            Component.components_[name] = ComponentToRegister;
            Component.components_[stringCases.toLowerCase(name)] = ComponentToRegister;
            return ComponentToRegister;
        }
        static getComponent(name) {
            if (!name || !Component.components_) {
                return;
            }
            return Component.components_[name];
        }
    }

    Component.prototype.getAttribute = Component.prototype.getAttr;
    Component.prototype.setAttribute = Component.prototype.getAttr;
    Component.prototype.removeAttribute = Component.prototype.removeAttr;


    Component.prototype.supportsRaf_ = typeof window.requestAnimationFrame === 'function' && typeof window.cancelAnimationFrame === 'function';
    Component.registerComponent('Component', Component);
    return Component;
});
define('skylark-videojs/utils/events',[
    'skylark-langx-globals/document',
    "skylark-domx",
    './dom-data',
    './guid',
    './log'
], function (document, domx, DomData, Guid, log) {
    'use strict';
    function _cleanUpEvents(elem, type) {
        if (!DomData.has(elem)) {
            return;
        }
        const data = DomData.get(elem);
        if (data.handlers[type].length === 0) {
            delete data.handlers[type];
            if (elem.removeEventListener) {
                elem.removeEventListener(type, data.dispatcher, false);
            } else if (elem.detachEvent) {
                elem.detachEvent('on' + type, data.dispatcher);
            }
        }
        if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
            delete data.handlers;
            delete data.dispatcher;
            delete data.disabled;
        }
        if (Object.getOwnPropertyNames(data).length === 0) {
            DomData.delete(elem);
        }
    }
    function _handleMultipleEvents(fn, elem, types, callback) {
        types.forEach(function (type) {
            fn(elem, type, callback);
        });
    }
    function fixEvent(event) {
        if (event.fixed_) {
            return event;
        }
        function returnTrue() {
            return true;
        }
        function returnFalse() {
            return false;
        }
        if (!event || !event.isPropagationStopped) {
            const old = event || window.event;
            event = {};
            for (const key in old) {
                if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {
                    if (!(key === 'returnValue' && old.preventDefault)) {
                        event[key] = old[key];
                    }
                }
            }
            if (!event.target) {
                event.target = event.srcElement || document;
            }
            if (!event.relatedTarget) {
                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
            }
            event.preventDefault = function () {
                if (old.preventDefault) {
                    old.preventDefault();
                }
                event.returnValue = false;
                old.returnValue = false;
                event.defaultPrevented = true;
            };
            event.defaultPrevented = false;
            event.stopPropagation = function () {
                if (old.stopPropagation) {
                    old.stopPropagation();
                }
                event.cancelBubble = true;
                old.cancelBubble = true;
                event.isPropagationStopped = returnTrue;
            };
            event.isPropagationStopped = returnFalse;
            event.stopImmediatePropagation = function () {
                if (old.stopImmediatePropagation) {
                    old.stopImmediatePropagation();
                }
                event.isImmediatePropagationStopped = returnTrue;
                event.stopPropagation();
            };
            event.isImmediatePropagationStopped = returnFalse;
            if (event.clientX !== null && event.clientX !== undefined) {
                const doc = document.documentElement;
                const body = document.body;
                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }
            event.which = event.charCode || event.keyCode;
            if (event.button !== null && event.button !== undefined) {
                event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
            }
        }
        event.fixed_ = true;
        return event;
    }
    let _supportsPassive;
    const supportsPassive = function () {
        if (typeof _supportsPassive !== 'boolean') {
            _supportsPassive = false;
            try {
                const opts = Object.defineProperty({}, 'passive', {
                    get() {
                        _supportsPassive = true;
                    }
                });
                window.addEventListener('test', null, opts);
                window.removeEventListener('test', null, opts);
            } catch (e) {
            }
        }
        return _supportsPassive;
    };
    const passiveEvents = [
        'touchstart',
        'touchmove'
    ];
    function on(elem, type, fn) {
        if (Array.isArray(type)) {
            return _handleMultipleEvents(on, elem, type, fn);
        }
        if (!DomData.has(elem)) {
            DomData.set(elem, {});
        }
        const data = DomData.get(elem);
        if (!data.handlers) {
            data.handlers = {};
        }
        if (!data.handlers[type]) {
            data.handlers[type] = [];
        }
        if (!fn.guid) {
            fn.guid = Guid.newGUID();
        }
        data.handlers[type].push(fn);
        if (!data.dispatcher) {
            data.disabled = false;
            data.dispatcher = function (event, hash) {
                if (data.disabled) {
                    return;
                }
                event = fixEvent(event);
                const handlers = data.handlers[event.type];
                if (handlers) {
                    const handlersCopy = handlers.slice(0);
                    for (let m = 0, n = handlersCopy.length; m < n; m++) {
                        if (event.isImmediatePropagationStopped()) {
                            break;
                        } else {
                            try {
                                handlersCopy[m].call(elem, event, hash);
                            } catch (e) {
                                log.error(e);
                            }
                        }
                    }
                }
            };
        }
        if (data.handlers[type].length === 1) {
            if (elem.addEventListener) {
                let options = false;
                if (supportsPassive() && passiveEvents.indexOf(type) > -1) {
                    options = { passive: true };
                }
                elem.addEventListener(type, data.dispatcher, options);
            } else if (elem.attachEvent) {
                elem.attachEvent('on' + type, data.dispatcher);
            }
        }
    }
    function off(elem, type, fn) {
        if (!DomData.has(elem)) {
            return;
        }
        const data = DomData.get(elem);
        if (!data.handlers) {
            return;
        }
        if (Array.isArray(type)) {
            return _handleMultipleEvents(off, elem, type, fn);
        }
        const removeType = function (el, t) {
            data.handlers[t] = [];
            _cleanUpEvents(el, t);
        };
        if (type === undefined) {
            for (const t in data.handlers) {
                if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
                    removeType(elem, t);
                }
            }
            return;
        }
        const handlers = data.handlers[type];
        if (!handlers) {
            return;
        }
        if (!fn) {
            removeType(elem, type);
            return;
        }
        if (fn.guid) {
            for (let n = 0; n < handlers.length; n++) {
                if (handlers[n].guid === fn.guid) {
                    handlers.splice(n--, 1);
                }
            }
        }
        _cleanUpEvents(elem, type);
    }
    function trigger(elem, event, hash) {
        const elemData = DomData.has(elem) ? DomData.get(elem) : {};
        const parent = elem.parentNode || elem.ownerDocument;
        if (typeof event === 'string') {
            event = {
                type: event,
                target: elem
            };
        } else if (!event.target) {
            event.target = elem;
        }
        event = fixEvent(event);
        if (elemData.dispatcher) {
            elemData.dispatcher.call(elem, event, hash);
        }
        if (parent && !event.isPropagationStopped() && event.bubbles === true) {
            trigger.call(null, parent, event, hash);
        } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
            if (!DomData.has(event.target)) {
                DomData.set(event.target, {});
            }
            const targetData = DomData.get(event.target);
            if (event.target[event.type]) {
                targetData.disabled = true;
                if (typeof event.target[event.type] === 'function') {
                    event.target[event.type]();
                }
                targetData.disabled = false;
            }
        }
        return !event.defaultPrevented;
    }
    function one(elem, type, fn) {
        if (Array.isArray(type)) {
            return _handleMultipleEvents(one, elem, type, fn);
        }
        const func = function () {
            off(elem, type, func);
            fn.apply(this, arguments);
        };
        func.guid = fn.guid = fn.guid || Guid.newGUID();
        on(elem, type, func);
    }
    function any(elem, type, fn) {
        const func = function () {
            off(elem, type, func);
            fn.apply(this, arguments);
        };
        func.guid = fn.guid = fn.guid || Guid.newGUID();
        on(elem, type, func);
    }
    return {
        fixEvent: fixEvent,
        on: domx.eventer.on, //on,
        off: domx.eventer.off, //off,
        trigger: domx.eventer.trigger, //trigger,
        one: domx.eventer.one, //one,
        any: domx.eventer.one //any
    };
});
define('skylark-videojs/event-target',[
    "skylark-langx-events/Emitter",
    './utils/events'
], function (Emitter,Events) {
    'use strict';

    /*
    const EventTarget = function () {
    };
    EventTarget.prototype.allowedEvents_ = {};
    EventTarget.prototype.on = function (type, fn) {
        const ael = this.addEventListener;
        this.addEventListener = () => {
        };
        Events.on(this, type, fn);
        this.addEventListener = ael;
    };
    EventTarget.prototype.addEventListener = EventTarget.prototype.on;
    EventTarget.prototype.off = function (type, fn) {
        Events.off(this, type, fn);
    };
    EventTarget.prototype.removeEventListener = EventTarget.prototype.off;
    EventTarget.prototype.one = function (type, fn) {
        const ael = this.addEventListener;
        this.addEventListener = () => {
        };
        Events.one(this, type, fn);
        this.addEventListener = ael;
    };
    EventTarget.prototype.any = function (type, fn) {
        const ael = this.addEventListener;
        this.addEventListener = () => {
        };
        Events.any(this, type, fn);
        this.addEventListener = ael;
    };
    EventTarget.prototype.trigger = function (event) {
        const type = event.type || event;
        if (typeof event === 'string') {
            event = { type };
        }
        event = Events.fixEvent(event);
        if (this.allowedEvents_[type] && this['on' + type]) {
            this['on' + type](event);
        }
        Events.trigger(this, event);
    };
    EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;

    */

    var EventTarget = Emitter.inherit({});
    EventTarget.prototype.addEventListener = EventTarget.prototype.on;
    EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;
    EventTarget.prototype.removeEventListener = EventTarget.prototype.off;
    EventTarget.prototype.any = EventTarget.prototype.one;

    let EVENT_MAP;
    EventTarget.prototype.queueTrigger = function (event) {
        if (!EVENT_MAP) {
            EVENT_MAP = new Map();
        }
        const type = event.type || event;
        let map = EVENT_MAP.get(this);
        if (!map) {
            map = new Map();
            EVENT_MAP.set(this, map);
        }
        const oldTimeout = map.get(type);
        map.delete(type);
        window.clearTimeout(oldTimeout);
        const timeout = window.setTimeout(() => {
            if (map.size === 0) {
                map = null;
                EVENT_MAP.delete(this);
            }
            this.trigger(event);
        }, 0);
        map.set(type, timeout);
    };

    return EventTarget;
});
define('skylark-videojs/utils/time-ranges',[],function () {
    'use strict';
    function rangeCheck(fnName, index, maxIndex) {
        if (typeof index !== 'number' || index < 0 || index > maxIndex) {
            throw new Error(`Failed to execute '${ fnName }' on 'TimeRanges': The index provided (${ index }) is non-numeric or out of bounds (0-${ maxIndex }).`);
        }
    }
    function getRange(fnName, valueIndex, ranges, rangeIndex) {
        rangeCheck(fnName, rangeIndex, ranges.length - 1);
        return ranges[rangeIndex][valueIndex];
    }
    function createTimeRangesObj(ranges) {
        if (ranges === undefined || ranges.length === 0) {
            return {
                length: 0,
                start() {
                    throw new Error('This TimeRanges object is empty');
                },
                end() {
                    throw new Error('This TimeRanges object is empty');
                }
            };
        }
        return {
            length: ranges.length,
            start: getRange.bind(null, 'start', 0, ranges),
            end: getRange.bind(null, 'end', 1, ranges)
        };
    }
    function createTimeRanges(start, end) {
        if (Array.isArray(start)) {
            return createTimeRangesObj(start);
        } else if (start === undefined || end === undefined) {
            return createTimeRangesObj();
        }
        return createTimeRangesObj([[
                start,
                end
            ]]);
    }
    return {
        createTimeRanges: createTimeRanges,
        createTimeRanges
    };
});
define('skylark-videojs/utils/buffer',['./time-ranges'], function (timeRages) {
    'use strict';
    function bufferedPercent(buffered, duration) {
        let bufferedDuration = 0;
        let start;
        let end;
        if (!duration) {
            return 0;
        }
        if (!buffered || !buffered.length) {
            buffered = timeRages.createTimeRange(0, 0);
        }
        for (let i = 0; i < buffered.length; i++) {
            start = buffered.start(i);
            end = buffered.end(i);
            if (end > duration) {
                end = duration;
            }
            bufferedDuration += end - start;
        }
        return bufferedDuration / duration;
    }
    return { bufferedPercent: bufferedPercent };
});
define('skylark-videojs/fullscreen-api',[
    "skylark-domx-browser"
], function (browser) {
    'use strict';
    /*
    const FullscreenApi = { prefixed: true };
    const apiMap = [
        [
            'requestFullscreen',
            'exitFullscreen',
            'fullscreenElement',
            'fullscreenEnabled',
            'fullscreenchange',
            'fullscreenerror',
            'fullscreen'
        ],
        [
            'webkitRequestFullscreen',
            'webkitExitFullscreen',
            'webkitFullscreenElement',
            'webkitFullscreenEnabled',
            'webkitfullscreenchange',
            'webkitfullscreenerror',
            '-webkit-full-screen'
        ],
        [
            'mozRequestFullScreen',
            'mozCancelFullScreen',
            'mozFullScreenElement',
            'mozFullScreenEnabled',
            'mozfullscreenchange',
            'mozfullscreenerror',
            '-moz-full-screen'
        ],
        [
            'msRequestFullscreen',
            'msExitFullscreen',
            'msFullscreenElement',
            'msFullscreenEnabled',
            'MSFullscreenChange',
            'MSFullscreenError',
            '-ms-fullscreen'
        ]
    ];
    const specApi = apiMap[0];
    let browserApi;
    for (let i = 0; i < apiMap.length; i++) {
        if (apiMap[i][1] in document) {
            browserApi = apiMap[i];
            break;
        }
    }
    if (browserApi) {
        for (let i = 0; i < browserApi.length; i++) {
            FullscreenApi[specApi[i]] = browserApi[i];
        }
        FullscreenApi.prefixed = browserApi[0] !== specApi[0];
    }
    return FullscreenApi;
    */

    return browser.support.fullscreen;
});
define('skylark-videojs/media-error',['./utils/obj'], function (obj) {
    'use strict';
    function MediaError(value) {
        if (value instanceof MediaError) {
            return value;
        }
        if (typeof value === 'number') {
            this.code = value;
        } else if (typeof value === 'string') {
            this.message = value;
        } else if (obj.isObject(value)) {
            if (typeof value.code === 'number') {
                this.code = value.code;
            }
            obj.assign(this, value);
        }
        if (!this.message) {
            this.message = MediaError.defaultMessages[this.code] || '';
        }
    }
    MediaError.prototype.code = 0;
    MediaError.prototype.message = '';
    MediaError.prototype.status = null;
    MediaError.errorTypes = [
        'MEDIA_ERR_CUSTOM',
        'MEDIA_ERR_ABORTED',
        'MEDIA_ERR_NETWORK',
        'MEDIA_ERR_DECODE',
        'MEDIA_ERR_SRC_NOT_SUPPORTED',
        'MEDIA_ERR_ENCRYPTED'
    ];
    MediaError.defaultMessages = {
        1: 'You aborted the media playback',
        2: 'A network error caused the media download to fail part-way.',
        3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
        4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
        5: 'The media is encrypted and we do not have the keys to decrypt it.'
    };
    for (let errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
        MediaError[MediaError.errorTypes[errNum]] = errNum;
        MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
    }
    return MediaError;
});
define('skylark-videojs/utils/safeParseTuple',[],function(){
	function safeParseTuple(obj, reviver) {
	    var json
	    var error = null

	    try {
	        json = JSON.parse(obj, reviver)
	    } catch (err) {
	        error = err
	    }

	    return [error, json]
	}

	return 	safeParseTuple;
});


define('skylark-videojs/utils/promise',[],function () {
    'use strict';
    function isPromise(value) {
        return value !== undefined && value !== null && typeof value.then === 'function';
    }
    function silencePromise(value) {
        if (isPromise(value)) {
            value.then(null, e => {
            });
        }
    }
    return {
        isPromise: isPromise,
        silencePromise: silencePromise
    };
});
define('skylark-videojs/tracks/text-track-list-converter',[],function () {
    'use strict';
    const trackToJson_ = function (track) {
        const ret = [
            'kind',
            'label',
            'language',
            'id',
            'inBandMetadataTrackDispatchType',
            'mode',
            'src'
        ].reduce((acc, prop, i) => {
            if (track[prop]) {
                acc[prop] = track[prop];
            }
            return acc;
        }, {
            cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
                return {
                    startTime: cue.startTime,
                    endTime: cue.endTime,
                    text: cue.text,
                    id: cue.id
                };
            })
        });
        return ret;
    };
    const textTracksToJson = function (tech) {
        const trackEls = tech.$$('track');
        const trackObjs = Array.prototype.map.call(trackEls, t => t.track);
        const tracks = Array.prototype.map.call(trackEls, function (trackEl) {
            const json = trackToJson_(trackEl.track);
            if (trackEl.src) {
                json.src = trackEl.src;
            }
            return json;
        });
        return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
            return trackObjs.indexOf(track) === -1;
        }).map(trackToJson_));
    };
    const jsonToTextTracks = function (json, tech) {
        json.forEach(function (track) {
            const addedTrack = tech.addRemoteTextTrack(track).track;
            if (!track.src && track.cues) {
                track.cues.forEach(cue => addedTrack.addCue(cue));
            }
        });
        return tech.textTracks();
    };
    return {
        textTracksToJson,
        jsonToTextTracks,
        trackToJson_
    };
});
define('skylark-devices-keyboard/keyboard',[
	"skylark-langx-ns"
],function(skylark){
	var keyboard = {};
	/**
	 * Function: isShiftDown
	 * 
	 * Returns true if the shift key is pressed for the given event.
	 */
	keyboard.isShiftDown = function (evt) {
		return (evt != null) ? evt.shiftKey : false;
	};

	/**
	 * Function: isAltDown
	 * 
	 * Returns true if the alt key is pressed for the given event.
	 */
	keyboard.isAltDown = function (evt) {
		return (evt != null) ? evt.altKey : false;
	};

	/**
	 * Function: isControlDown
	 * 
	 * Returns true if the control key is pressed for the given event.
	 */
	keyboard.isControlDown = function (evt) {
		return (evt != null) ? evt.ctrlKey : false;
	};

	/**
	 * Function: isMetaDown
	 * 
	 * Returns true if the meta key is pressed for the given event.
	 */
	keyboard.isMetaDown = function (evt){
		return (evt != null) ? evt.metaKey : false;
	};

	/**
	 * TAB key
	 * @attribute TAB
	 * @type {Number}
	 */
	keyboard.TAB = 9;

	/**
	 * ENTER key
	 * @attribute ENTER
	 * @type {Number}
	 */
	keyboard.ENTER = 13;

	/**
	 * SHIFT key
	 * @attribute SHIFT
	 * @type {Number}
	 */
	keyboard.SHIFT = 16;

	/**
	 * CTRL key
	 * @attribute CTRL
	 * @type {Number}
	 */
	keyboard.CTRL = 17;

	/**
	 * ALT key
	 * @attribute ALT
	 * @type {Number}
	 */
	keyboard.ALT = 18;

	/**
	 * CAPS_LOCK key
	 * @attribute CAPS_LOCK
	 * @type {Number}
	 */
	keyboard.CAPS_LOCK = 20;

	/**
	 * ESC key
	 * @attribute ESC
	 * @type {Number}
	 */
	keyboard.ESC = 27;

	/**
	 * SPACEBAR key
	 * @attribute SPACEBAR
	 * @type {Number}
	 */
	keyboard.SPACEBAR = 32;

	/**
	 * PAGE_UP key
	 * @attribute PAGE_UP
	 * @type {Number}
	 */
	keyboard.PAGE_UP = 33;

	/**
	 * PAGE_DOWN key
	 * @attribute PAGE_DOWN
	 * @type {Number}
	 */
	keyboard.PAGE_DOWN = 34;

	/**
	 * END key
	 * @attribute END
	 * @type {Number}
	 */
	keyboard.END = 35;

	/**
	 * HOME key
	 * @attribute HOME
	 * @type {Number}
	 */
	keyboard.HOME = 36;

	/**
	 * INSERT key
	 * @attribute INSERT
	 * @type {Number}
	 */
	keyboard.INSERT = 45;

	/**
	 * DEL key
	 * @attribute DEL
	 * @type {Number}
	 */
	keyboard.DEL = 46;

	/**
	 * LEFT key
	 * @attribute LEFT
	 * @type {Number}
	 */
	keyboard.LEFT = 37;

	/**
	 * RIGHT key
	 * @attribute RIGHT
	 * @type {Number}
	 */
	keyboard.RIGHT = 39;

	/**
	 * UP key
	 * @attribute UP
	 * @type {Number}
	 */
	keyboard.UP = 38;

	/**
	 * DOWN key
	 * @attribute DOWN
	 * @type {Number}
	 */
	keyboard.DOWN = 40;

	/**
	 * NUM0 key
	 * @attribute NUM0
	 * @type {Number}
	 */
	keyboard.NUM0 = 48;

	/**
	 * NUM1 key
	 * @attribute NUM1
	 * @type {Number}
	 */
	keyboard.NUM1 = 49;

	/**
	 * NUM2 key
	 * @attribute NUM2
	 * @type {Number}
	 */
	keyboard.NUM2 = 50;

	/**
	 * NUM3 key
	 * @attribute NUM3
	 * @type {Number}
	 */
	keyboard.NUM3 = 51;

	/**
	 * NUM4 key
	 * @attribute NUM4
	 * @type {Number}
	 */
	keyboard.NUM4 = 52;

	/**
	 * NUM5 key
	 * @attribute NUM5
	 * @type {Number}
	 */
	keyboard.NUM5 = 53;

	/**
	 * NUM6 key
	 * @attribute NUM6
	 * @type {Number}
	 */
	keyboard.NUM6 = 54;

	/**
	 * NUM7 key
	 * @attribute NUM7
	 * @type {Number}
	 */
	keyboard.NUM7 = 55;

	/**
	 * NUM8 key
	 * @attribute NUM8
	 * @type {Number}
	 */
	keyboard.NUM8 = 56;

	/**
	 * NUM9 key
	 * @attribute NUM9
	 * @type {Number}
	 */
	keyboard.NUM9 = 57;

	/**
	 * A key
	 * @attribute A
	 * @type {Number}
	 */
	keyboard.A = 65;

	/**
	 * B key
	 * @attribute B
	 * @type {Number}
	 */
	keyboard.B = 66;

	/**
	 * C key
	 * @attribute C
	 * @type {Number}
	 */
	keyboard.C = 67;

	/**
	 * D key
	 * @attribute D
	 * @type {Number}
	 */
	keyboard.D = 68;

	/**
	 * E key
	 * @attribute E
	 * @type {Number}
	 */
	keyboard.E = 69;

	/**
	 * F key
	 * @attribute F
	 * @type {Number}
	 */
	keyboard.F = 70;

	/**
	 * G key
	 * @attribute G
	 * @type {Number}
	 */
	keyboard.G = 71;

	/**
	 * H key
	 * @attribute H
	 * @type {Number}
	 */
	keyboard.H = 72;

	/**
	 * I key
	 * @attribute I
	 * @type {Number}
	 */
	keyboard.I = 73;

	/**
	 * J key
	 * @attribute J
	 * @type {Number}
	 */
	keyboard.J = 74;

	/**
	 * K key
	 * @attribute K
	 * @type {Number}
	 */
	keyboard.K = 75;

	/**
	 * L key
	 * @attribute L
	 * @type {Number}
	 */
	keyboard.L = 76;

	/**
	 * M key
	 * @attribute M
	 * @type {Number}
	 */
	keyboard.M = 77;

	/**
	 * N key
	 * @attribute N
	 * @type {Number}
	 */
	keyboard.N = 78;

	/**
	 * O key
	 * @attribute O
	 * @type {Number}
	 */
	keyboard.O = 79;

	/**
	 * P key
	 * @attribute P
	 * @type {Number}
	 */
	keyboard.P = 80;

	/**
	 * Q key
	 * @attribute Q
	 * @type {Number}
	 */
	keyboard.Q = 81;

	/**
	 * R key
	 * @attribute R
	 * @type {Number}
	 */
	keyboard.R = 82;

	/**
	 * S key
	 * @attribute S
	 * @type {Number}
	 */
	keyboard.S = 83;

	/**
	 * T key
	 * @attribute T
	 * @type {Number}
	 */
	keyboard.T = 84;

	/**
	 * U key
	 * @attribute U
	 * @type {Number}
	 */
	keyboard.U = 85;

	/**
	 * V key
	 * @attribute V
	 * @type {Number}
	 */
	keyboard.V = 86;

	/**
	 * W key
	 * @attribute W
	 * @type {Number}
	 */
	keyboard.W = 87;

	/**
	 * X key
	 * @attribute X
	 * @type {Number}
	 */
	keyboard.X = 88;

	/**
	 * Y key
	 * @attribute Y
	 * @type {Number}
	 */
	keyboard.Y = 89;

	/**
	 * Z key
	 * @attribute Z
	 * @type {Number}
	 */
	keyboard.Z = 90;

	/**
	 * F1 key
	 * @attribute F1
	 * @type {Number}
	 */
	keyboard.F1 = 112;

	/**
	 * F2 key
	 * @attribute F2
	 * @type {Number}
	 */
	keyboard.F2 = 113;

	/**
	 * F3 key
	 * @attribute F3
	 * @type {Number}
	 */
	keyboard.F3 = 114;

	/**
	 * F4 key
	 * @attribute F4
	 * @type {Number}
	 */
	keyboard.F4 = 115;

	/**
	 * F5 key
	 * @attribute F5
	 * @type {Number}
	 */
	keyboard.F5 = 116;

	/**
	 * F6 key
	 * @attribute F6
	 * @type {Number}
	 */
	keyboard.F6 = 117;

	/**
	 * F7 key
	 * @attribute F7
	 * @type {Number}
	 */
	keyboard.F7 = 118;

	/**
	 * F8 key
	 * @attribute F8
	 * @type {Number}
	 */
	keyboard.F8 = 119;

	/**
	 * F9 key
	 * @attribute F9
	 * @type {Number}
	 */
	keyboard.F9 = 120;

	/**
	 * F10 key
	 * @attribute F10
	 * @type {Number}
	 */
	keyboard.F10 = 121;

	/**
	 * F11 key
	 * @attribute F11
	 * @type {Number}
	 */
	keyboard.F11 = 122;

	/**
	 * F12 key
	 * @attribute F12
	 * @type {Number}
	 */
	keyboard.F12 = 123;

	return skylark.attach("devices.keyboard",keyboard);	
});
define('skylark-devices-keyboard/Key',[
	"skylark-langx-klass",
	"./keyboard"
],function(klass,keyboard){
	"use strict";

	/**
	 * Key is used by Keyboard, Mouse, etc, to represent a key state.
	 *
	 * @class Key
	 * @module Input
	*/
	var Key = klass({
		_construct : function() {
			/**
			 * Indicates if this key is currently pressed.
			 * @property pressed
			 * @default false
			 * @type {boolean}
			 */
			this.pressed = false;

			/**
			 * Indicates if this key was just pressed.
			 * @property justPressed
			 * @default false
			 * @type {boolean}
			 */
			this.justPressed = false;
			
			/**
			 * Indicates if this key was just released.
			 * @property justReleased
			 * @default false
			 * @type {boolean}
			 */
			this.justReleased = false;

		},

		/**
		 * Update Key status based on new key state.
		 * 
		 * @method update
		 */
		update : function(action)  {
			this.justPressed = false;
			this.justReleased = false;

			if(action === Key.DOWN)
			{
				if(this.pressed === false)
				{
					this.justPressed = true;
				}
				this.pressed = true;
			}
			else if(action === Key.UP)
			{
				if(this.pressed)
				{
					this.justReleased = true;
				}
				this.pressed = false;
			}
			else if(action === Key.RESET)
			{
				this.justReleased = false;
				this.justPressed = false;
			}
		},

		/**
		 * Set this key attributes manually.
		 * 
		 * @method set
		 */
		set : function(justPressed, pressed, justReleased){
			this.justPressed = justPressed;
			this.pressed = pressed;
			this.justReleased = justReleased;
		},

		/**
		 * Reset key to default values.
		 * 
		 * @method reset
		*/
		reset : function() 	{
			this.justPressed = false;
			this.pressed = false;
			this.justReleased = false;
		}
	});

	/**
	 * Down
	 * @attribute DOWN
	 * @type {Number}
	 */
	Key.DOWN = -1;

	/**
	 * Up
	 * @attribute UP
	 * @type {Number}
	 */
	Key.UP = 1;

	/**
	 * Reset
	 * @attribute RESET
	 * @type {Number}
	 */
	Key.RESET = 0;


	return keyboard.Key = Key;

});
define('skylark-devices-keyboard/Monitor',[
	"skylark-langx-klass",
	"./keyboard",
	"./Key"
],function(
	klass,
	keyboard,
	Key
){
	"use strict";

	/**
	 * Keyboard instance for input in sync with the running 3D application.
	 * 
	 * The keyboard object provided by scripts is automatically updated by the runtime handler.
	 * 
	 * @class Keyboard
	 * @module Input
	 * @param {Boolean} dontInitialize If true the mouse events are not created.
	 */
	var Monitor = klass({
		_construct : function (dontInitialize) 	{
			/**
			 * Array with keyboard keys status.
			 *
			 * @property keys
			 * @type {Array}
			 */
			this.keys = [];


			/**
			 * The actions array serves as a buffer for the key input actions.
			 *
			 * Until the update method is called it stores all the key stroke actions.
			 *
			 * On update the key strokes are updated and the keys array stores the correct values.
			 *
			 * @property actions
			 * @type {Array}
			 */
			this.actions = [];

			var self = this;
			var actions = this.actions;

			/**
			 * Event manager used to handle the keyup, keydown and focus events.
			 *
			 * On each event actions are added to the actions array.
			 *
			 * @property events
			 * @type {EventManager}
			 */
			//this.events = new EventManager();
			/*
			this.events.add(window, "keydown", function(event)
			{
				actions.push(event.keyCode);
				actions.push(Key.DOWN);
			});
			this.events.add(window, "keyup", function(event)
			{
				actions.push(event.keyCode);
				actions.push(Key.UP);
			});
			this.events.add(window, "focus", function(event)
			{
				self.reset();
			});
			*/
			this.handlers = {
				"keydown" : function(event) {
								actions.push(event.keyCode);
								actions.push(Key.DOWN);
							},			
				"keyup" : function(event) {
								actions.push(event.keyCode);
								actions.push(Key.UP);
							},			
				"focus" : function(event) {
								self.reset();
							},			


			};

			if(dontInitialize !== true)
			{
				this.create();
			}


		},

		/**
		 * Update key flags synchronously.
		 * 
		 * @method update
		 */
		update : function() 	{
			var end = 0;

			while(this.actions.length > end)
			{
				var key = this.actions.shift();
				var action = this.actions.shift();

				if(this.keys[key] === undefined)
				{
					this.keys[key] = new Key();
				}

				this.keys[key].update(action);

				if(this.keys[key].justReleased || this.keys[key].justPressed)
				{
					this.actions.push(key);
					this.actions.push(Key.RESET);
					end += 2;
				}
			}
		},

		/**
		 * Reset keyboard status to default.
		 *
		 * Does not clean the action list.
		 * 
		 * @method reset
		 */
		reset : function() {
			//Reset all keys
			for(var i = 0; i < this.keys.length; i++)
			{
				if(this.keys[i] !== undefined)
				{
					this.keys[i].reset();
				}
			}
		},

		/**
		 * Check if a key is pressed.
		 * 
		 * @method keyPressed
		 * @return {boolean} True is the key is currently pressed
		 */
		keyPressed : function(key){
			return this.keys[key] !== undefined && this.keys[key].pressed;
		},

		/**
		 * Check is a key as just pressed.
		 * 
		 * @method keyJustPressed
		 * @return {boolean} True is the key was just pressed
		 */
		keyJustPressed : function(key){
			return this.keys[key] !== undefined && this.keys[key].justPressed;
		},

		/**
		 * Check if a key was just released.
		 * 
		 * @method keyJustReleased
		 * @return {boolean} True is the key was just pressed
		 */
		keyJustReleased : function(key){
			return this.keys[key] !== undefined && this.keys[key].justReleased;
		},


		/**
		 * Create keyboard events.
		 * 
		 * @method dispose
		 */
		create : function(){
			//this.events.create();
			for (var event in this.handlers) {
				window.addEventListener(event,this.handlers[event]);
			}
		},

		/**
		 * Dispose keyboard events.
		 * 
		 * @method dispose
		 */
		dispose : function()	{
			//this.events.destroy();
			for (var event in this.handlers) {
				window.removeEventListener(event,this.handlers[event]);
			}
		}

	});


	return keyboard.Monitor =  Monitor;
});
define('skylark-devices-keyboard/codes',[
	"./keyboard"
],function(keyboard){

  /**
   * Get by name
   *
   *   exports.code['enter'] // => 13
   */

  var codes =  {
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'shift': 16,
    'ctrl': 17,
    'alt': 18,
    'pause/break': 19,
    'caps lock': 20,
    'esc': 27,
    'space': 32,
    'page up': 33,
    'page down': 34,
    'end': 35,
    'home': 36,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40,
    'insert': 45,
    'delete': 46,
    'command': 91,
    'left command': 91,
    'right command': 93,
    'numpad *': 106,
    'numpad +': 107,
    'numpad -': 109,
    'numpad .': 110,
    'numpad /': 111,
    'num lock': 144,
    'scroll lock': 145,
    'my computer': 182,
    'my calculator': 183,
    ';': 186,
    '=': 187,
    ',': 188,
    '-': 189,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    "'": 222
  };

  /*!
   * Programatically add the following
   */

  // lower case chars a-z
  for (var i = 97; i < 123; i++) {
    codes[String.fromCharCode(i)] = i - 32;
  }

  // numbers 0-9
  for (var i = 48; i < 58; i++) {
    codes[i - 48] = i;
  }

  // function keys f1-f12
  for (var i = 1; i < 13; i++) {
    codes['f'+i] = i + 111;
  }

  // numpad keys
  for (var i = 0; i < 10; i++) {
    codes['numpad '+i] = i + 96;
  }

  // Helper aliases




  return keyboard.codes = codes;
});
define('skylark-devices-keyboard/names',[
	"./keyboard",
	"./codes"
],function(keyboard,codes){

  /**
   * Get by code
   *
   *   exports.name[13] // => 'Enter'
   */

  var names = {} ;

  // Create reverse mapping
  for (var i in codes) {
  	names[codes[i]] = i;
  }

  return keyboard.names = names;
});
define('skylark-devices-keyboard/aliases',[
	"./keyboard",
	"./codes",
    "./names"
],function(keyboard,codes){

  var aliases =  {
    'windows': 91,
    '': 16,
    '': 18,
    '': 17,
    '': 91,
    'ctl': 17,
    'control': 17,
    'option': 18,
    'pause': 19,
    'break': 19,
    'caps': 20,
    'return': 13,
    'escape': 27,
    'spc': 32,
    'spacebar': 32,
    'pgup': 33,
    'pgdn': 34,
    'ins': 45,
    'del': 46,
    'cmd': 91
  }

  return keyboard.aliases = aliases;
});
define('skylark-devices-keyboard/isEventKey',[
	"skylark-langx-types",
	"./keyboard",
	"./aliases",
	"./codes",
	"./names"
],function(types,keyboard,alias,codes,names){

  /**
   * Compares a keyboard event with a given keyCode or keyName.
   *
   * @param {Event} event Keyboard event that should be tested
   * @param {Mixed} keyCode {Number} or keyName {String}
   * @return {Boolean}
   * @api public
   */
   function isEventKey(event, nameOrCode) {
      var keyCode = event.which || event.keyCode || event.charCode;
      if (keyCode === null || keyCode === undefined) { 
      	return false; 
      }

      if (types.isString(nameOrCode)) {
        // check codes
        var foundNamedKey = codes[nameOrCode.toLowerCase()]
        if (foundNamedKey) { return foundNamedKey === keyCode; }
      
        // check aliases
        var foundNamedKey = aliases[nameOrCode.toLowerCase()]
        if (foundNamedKey) { return foundNamedKey === keyCode; }
      } else if (types.isNumber(nameOrCode)) {
        return nameOrCode === keyCode;
      }
      return false;
  }

  return keyboard.isEventKey = isEventKey;

});

define('skylark-devices-keyboard/main',[
	"./keyboard",
	"./Key",
	"./Monitor",
	"./aliases",
	"./codes",
	"./isEventKey",
	"./names"
],function(keyboard){
	return keyboard;
});
define('skylark-devices-keyboard', ['skylark-devices-keyboard/main'], function (main) { return main; });

define('skylark-videojs/utils/keycode',[
  "skylark-devices-keyboard"
],function(keyboard){
  // Source: http://jsfiddle.net/vWx8V/
  // http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes

  /**
   * Conenience method returns corresponding value for given keyName or keyCode.
   *
   * @param {Mixed} keyCode {Number} or keyName {String}
   * @return {Mixed}
   * @api public
   */

  function keyCode(searchInput) {
    // Keyboard Events
    if (searchInput && 'object' === typeof searchInput) {
      var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode
      if (hasKeyCode) searchInput = hasKeyCode
    }

    // Numbers
    if ('number' === typeof searchInput) return names[searchInput]

    // Everything else (cast to string)
    var search = String(searchInput)

    // check codes
    var foundNamedKey = codes[search.toLowerCase()]
    if (foundNamedKey) return foundNamedKey

    // check aliases
    var foundNamedKey = aliases[search.toLowerCase()]
    if (foundNamedKey) return foundNamedKey

    // weird character?
    if (search.length === 1) return search.charCodeAt(0)

    return undefined
  }

  /**
   * Compares a keyboard event with a given keyCode or keyName.
   *
   * @param {Event} event Keyboard event that should be tested
   * @param {Mixed} keyCode {Number} or keyName {String}
   * @return {Boolean}
   * @api public
   */
  keyCode.isEventKey = function isEventKey(event, nameOrCode) {
    if (event && 'object' === typeof event) {
      var keyCode = event.which || event.keyCode || event.charCode
      if (keyCode === null || keyCode === undefined) { return false; }
      if (typeof nameOrCode === 'string') {
        // check codes
        var foundNamedKey = codes[nameOrCode.toLowerCase()]
        if (foundNamedKey) { return foundNamedKey === keyCode; }
      
        // check aliases
        var foundNamedKey = aliases[nameOrCode.toLowerCase()]
        if (foundNamedKey) { return foundNamedKey === keyCode; }
      } else if (typeof nameOrCode === 'number') {
        return nameOrCode === keyCode;
      }
      return false;
    }
  }

  var exports = keyCode;

  /**
   * Get by name
   *
   *   exports.code['enter'] // => 13
   */

  var codes = exports.code = exports.codes = {
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'shift': 16,
    'ctrl': 17,
    'alt': 18,
    'pause/break': 19,
    'caps lock': 20,
    'esc': 27,
    'space': 32,
    'page up': 33,
    'page down': 34,
    'end': 35,
    'home': 36,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40,
    'insert': 45,
    'delete': 46,
    'command': 91,
    'left command': 91,
    'right command': 93,
    'numpad *': 106,
    'numpad +': 107,
    'numpad -': 109,
    'numpad .': 110,
    'numpad /': 111,
    'num lock': 144,
    'scroll lock': 145,
    'my computer': 182,
    'my calculator': 183,
    ';': 186,
    '=': 187,
    ',': 188,
    '-': 189,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    "'": 222
  }

  // Helper aliases

  var aliases = exports.aliases = {
    'windows': 91,
    '': 16,
    '': 18,
    '': 17,
    '': 91,
    'ctl': 17,
    'control': 17,
    'option': 18,
    'pause': 19,
    'break': 19,
    'caps': 20,
    'return': 13,
    'escape': 27,
    'spc': 32,
    'spacebar': 32,
    'pgup': 33,
    'pgdn': 34,
    'ins': 45,
    'del': 46,
    'cmd': 91
  }

  /*!
   * Programatically add the following
   */

  // lower case chars
  for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32

  // numbers
  for (var i = 48; i < 58; i++) codes[i - 48] = i

  // function keys
  for (i = 1; i < 13; i++) codes['f'+i] = i + 111

  // numpad keys
  for (i = 0; i < 10; i++) codes['numpad '+i] = i + 96

  /**
   * Get by code
   *
   *   exports.name[13] // => 'Enter'
   */

  var names = exports.names = exports.title = {} // title for backward compat

  // Create reverse mapping
  for (i in codes) names[codes[i]] = i

  // Add aliases
  for (var alias in aliases) {
    codes[alias] = aliases[alias]
  }

  //return exports;

  return {
    codes : keyboard.codes,
    names : keyboard.names,
    aliases : keyboard.aliases,
    isEventKey : keyboard.isEventKey
  }

});
define('skylark-videojs/modal-dialog',[
    'skylark-langx-globals/document',
    './utils/dom',
    './component',
    './utils/keycode'
], function (document,Dom, Component, keycode) {
    'use strict';
    const MODAL_CLASS_NAME = 'vjs-modal-dialog';
    class ModalDialog extends Component {
        constructor(player, options) {
            super(player, options);
            this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;
            this.closeable(!this.options_.uncloseable);
            this.content(this.options_.content);
            this.contentEl_ = Dom.createEl('div', { className: `${ MODAL_CLASS_NAME }-content` }, { role: 'document' });
            this.descEl_ = Dom.createEl('p', {
                className: `${ MODAL_CLASS_NAME }-description vjs-control-text`,
                id: this.el().getAttribute('aria-describedby')
            });
            Dom.textContent(this.descEl_, this.description());
            this.el_.appendChild(this.descEl_);
            this.el_.appendChild(this.contentEl_);
        }
        createEl() {
            return super.createEl('div', {
                className: this.buildCSSClass(),
                tabIndex: -1
            }, {
                'aria-describedby': `${ this.id() }_description`,
                'aria-hidden': 'true',
                'aria-label': this.label(),
                'role': 'dialog'
            });
        }
        dispose() {
            this.contentEl_ = null;
            this.descEl_ = null;
            this.previouslyActiveEl_ = null;
            super.dispose();
        }
        buildCSSClass() {
            return `${ MODAL_CLASS_NAME } vjs-hidden ${ super.buildCSSClass() }`;
        }
        label() {
            return this.localize(this.options_.label || 'Modal Window');
        }
        description() {
            let desc = this.options_.description || this.localize('This is a modal window.');
            if (this.closeable()) {
                desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
            }
            return desc;
        }
        open() {
            if (!this.opened_) {
                const player = this.player();
                this.trigger('beforemodalopen');
                this.opened_ = true;
                if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
                    this.fill();
                }
                this.wasPlaying_ = !player.paused();
                if (this.options_.pauseOnOpen && this.wasPlaying_) {
                    player.pause();
                }
                this.listenTo('keydown', this.handleKeyDown);
                this.hadControls_ = player.controls();
                player.controls(false);
                this.show();
                this.conditionalFocus_();
                this.el().setAttribute('aria-hidden', 'false');
                this.trigger('modalopen');
                this.hasBeenOpened_ = true;
            }
        }
        opened(value) {
            if (typeof value === 'boolean') {
                this[value ? 'open' : 'close']();
            }
            return this.opened_;
        }
        close() {
            if (!this.opened_) {
                return;
            }
            const player = this.player();
            this.trigger('beforemodalclose');
            this.opened_ = false;
            if (this.wasPlaying_ && this.options_.pauseOnOpen) {
                player.play();
            }
            this.unlistenTo('keydown', this.handleKeyDown);
            if (this.hadControls_) {
                player.controls(true);
            }
            this.hide();
            this.el().setAttribute('aria-hidden', 'true');
            this.trigger('modalclose');
            this.conditionalBlur_();
            if (this.options_.temporary) {
                this.dispose();
            }
        }
        closeable(value) {
            if (typeof value === 'boolean') {
                const closeable = this.closeable_ = !!value;
                let close = this.getChild('closeButton');
                if (closeable && !close) {
                    const temp = this.contentEl_;
                    this.contentEl_ = this.el_;
                    close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });
                    this.contentEl_ = temp;
                    this.listenTo(close, 'close', this.close);
                }
                if (!closeable && close) {
                    this.unlistenTo(close, 'close', this.close);
                    this.removeChild(close);
                    close.dispose();
                }
            }
            return this.closeable_;
        }
        fill() {
            this.fillWith(this.content());
        }
        fillWith(content) {
            const contentEl = this.contentEl();
            const parentEl = contentEl.parentNode;
            const nextSiblingEl = contentEl.nextSibling;
            this.trigger('beforemodalfill');
            this.hasBeenFilled_ = true;
            parentEl.removeChild(contentEl);
            this.empty();
            Dom.insertContent(contentEl, content);
            this.trigger('modalfill');
            if (nextSiblingEl) {
                parentEl.insertBefore(contentEl, nextSiblingEl);
            } else {
                parentEl.appendChild(contentEl);
            }
            const closeButton = this.getChild('closeButton');
            if (closeButton) {
                parentEl.appendChild(closeButton.el_);
            }
        }
        empty() {
            this.trigger('beforemodalempty');
            Dom.emptyEl(this.contentEl());
            this.trigger('modalempty');
        }
        content(value) {
            if (typeof value !== 'undefined') {
                this.content_ = value;
            }
            return this.content_;
        }
        conditionalFocus_() {
            const activeEl = document.activeElement;
            const playerEl = this.player_.el_;
            this.previouslyActiveEl_ = null;
            if (playerEl.contains(activeEl) || playerEl === activeEl) {
                this.previouslyActiveEl_ = activeEl;
                this.focus();
            }
        }
        conditionalBlur_() {
            if (this.previouslyActiveEl_) {
                this.previouslyActiveEl_.focus();
                this.previouslyActiveEl_ = null;
            }
        }
        handleKeyDown(event) {
            event.stopPropagation();
            if (keycode.isEventKey(event, 'Escape') && this.closeable()) {
                event.preventDefault();
                this.close();
                return;
            }
            if (!keycode.isEventKey(event, 'Tab')) {
                return;
            }
            const focusableEls = this.focusableEls_();
            const activeEl = this.el_.querySelector(':focus');
            let focusIndex;
            for (let i = 0; i < focusableEls.length; i++) {
                if (activeEl === focusableEls[i]) {
                    focusIndex = i;
                    break;
                }
            }
            if (document.activeElement === this.el_) {
                focusIndex = 0;
            }
            if (event.shiftKey && focusIndex === 0) {
                focusableEls[focusableEls.length - 1].focus();
                event.preventDefault();
            } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
                focusableEls[0].focus();
                event.preventDefault();
            }
        }
        focusableEls_() {
            const allChildren = this.el_.querySelectorAll('*');
            return Array.prototype.filter.call(allChildren, child => {
                return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || (child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement) || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');
            });
        }
    }
    ModalDialog.prototype.options_ = {
        pauseOnOpen: true,
        temporary: true
    };
    Component.registerComponent('ModalDialog', ModalDialog);
    return ModalDialog;
});
define('skylark-videojs/tracks/track-list',[
    '../event-target'
    ///'../mixins/evented'
], function (EventTarget) {
    'use strict';
    class TrackList extends EventTarget {
        constructor(tracks = []) {
            super();
            this.tracks_ = [];
            Object.defineProperty(this, 'length', {
                get() {
                    return this.tracks_.length;
                }
            });
            for (let i = 0; i < tracks.length; i++) {
                this.addTrack(tracks[i]);
            }
        }
        addTrack(track) {
            const index = this.tracks_.length;
            if (!('' + index in this)) {
                Object.defineProperty(this, index, {
                    get() {
                        return this.tracks_[index];
                    }
                });
            }
            if (this.tracks_.indexOf(track) === -1) {
                this.tracks_.push(track);
                this.trigger({
                    track,
                    type: 'addtrack',
                    target: this
                });
            }
            track.labelchange_ = () => {
                this.trigger({
                    track,
                    type: 'labelchange',
                    target: this
                });
            };
            ///if (evented.isEvented(track)) {
            if (track.addEventListener) {
                track.addEventListener('labelchange', track.labelchange_);
            }
        }
        removeTrack(rtrack) {
            let track;
            for (let i = 0, l = this.length; i < l; i++) {
                if (this[i] === rtrack) {
                    track = this[i];
                    if (track.off) {
                        track.off();
                    }
                    this.tracks_.splice(i, 1);
                    break;
                }
            }
            if (!track) {
                return;
            }
            this.trigger({
                track,
                type: 'removetrack',
                target: this
            });
        }
        getTrackById(id) {
            let result = null;
            for (let i = 0, l = this.length; i < l; i++) {
                const track = this[i];
                if (track.id === id) {
                    result = track;
                    break;
                }
            }
            return result;
        }
    }
    TrackList.prototype.allowedEvents_ = {
        change: 'change',
        addtrack: 'addtrack',
        removetrack: 'removetrack',
        labelchange: 'labelchange'
    };
    for (const event in TrackList.prototype.allowedEvents_) {
        TrackList.prototype['on' + event] = null;
    }
    return TrackList;
});
define('skylark-videojs/tracks/audio-track-list',[
    './track-list'
], function (TrackList) {
    'use strict';
    const disableOthers = function (list, track) {
        for (let i = 0; i < list.length; i++) {
            if (!Object.keys(list[i]).length || track.id === list[i].id) {
                continue;
            }
            list[i].enabled = false;
        }
    };
    class AudioTrackList extends TrackList {
        constructor(tracks = []) {
            for (let i = tracks.length - 1; i >= 0; i--) {
                if (tracks[i].enabled) {
                    disableOthers(tracks, tracks[i]);
                    break;
                }
            }
            super(tracks);
            this.changing_ = false;
        }
        addTrack(track) {
            if (track.enabled) {
                disableOthers(this, track);
            }
            super.addTrack(track);
            if (!track.addEventListener) {
                return;
            }
            track.enabledChange_ = () => {
                if (this.changing_) {
                    return;
                }
                this.changing_ = true;
                disableOthers(this, track);
                this.changing_ = false;
                this.trigger('change');
            };
            track.addEventListener('enabledchange', track.enabledChange_);
        }
        removeTrack(rtrack) {
            super.removeTrack(rtrack);
            if (rtrack.removeEventListener && rtrack.enabledChange_) {
                rtrack.removeEventListener('enabledchange', rtrack.enabledChange_);
                rtrack.enabledChange_ = null;
            }
        }
    }
    return AudioTrackList;
});
define('skylark-videojs/tracks/video-track-list',['./track-list'], function (TrackList) {
    'use strict';
    const disableOthers = function (list, track) {
        for (let i = 0; i < list.length; i++) {
            if (!Object.keys(list[i]).length || track.id === list[i].id) {
                continue;
            }
            list[i].selected = false;
        }
    };
    class VideoTrackList extends TrackList {
        constructor(tracks = []) {
            for (let i = tracks.length - 1; i >= 0; i--) {
                if (tracks[i].selected) {
                    disableOthers(tracks, tracks[i]);
                    break;
                }
            }
            super(tracks);
            this.changing_ = false;
            Object.defineProperty(this, 'selectedIndex', {
                get() {
                    for (let i = 0; i < this.length; i++) {
                        if (this[i].selected) {
                            return i;
                        }
                    }
                    return -1;
                },
                set() {
                }
            });
        }
        addTrack(track) {
            if (track.selected) {
                disableOthers(this, track);
            }
            super.addTrack(track);
            if (!track.addEventListener) {
                return;
            }
            track.selectedChange_ = () => {
                if (this.changing_) {
                    return;
                }
                this.changing_ = true;
                disableOthers(this, track);
                this.changing_ = false;
                this.trigger('change');
            };
            track.addEventListener('selectedchange', track.selectedChange_);
        }
        removeTrack(rtrack) {
            super.removeTrack(rtrack);
            if (rtrack.removeEventListener && rtrack.selectedChange_) {
                rtrack.removeEventListener('selectedchange', rtrack.selectedChange_);
                rtrack.selectedChange_ = null;
            }
        }
    }
    return VideoTrackList;
});
define('skylark-videojs/tracks/text-track-list',[
    './track-list'
], function (TrackList) {

    'use strict';
    
    class TextTrackList extends TrackList {
        addTrack(track) {
            super.addTrack(track);
            if (!this.queueChange_) {
                this.queueChange_ = () => this.queueTrigger('change');
            }
            if (!this.triggerSelectedlanguagechange) {
                this.triggerSelectedlanguagechange_ = () => this.trigger('selectedlanguagechange');
            }
            track.addEventListener('modechange', this.queueChange_);
            const nonLanguageTextTrackKind = [
                'metadata',
                'chapters'
            ];
            if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
                track.addEventListener('modechange', this.triggerSelectedlanguagechange_);
            }
        }
        removeTrack(rtrack) {
            super.removeTrack(rtrack);
            if (rtrack.removeEventListener) {
                if (this.queueChange_) {
                    rtrack.removeEventListener('modechange', this.queueChange_);
                }
                if (this.selectedlanguagechange_) {
                    rtrack.removeEventListener('modechange', this.triggerSelectedlanguagechange_);
                }
            }
        }
    }

    return TextTrackList;
});
define('skylark-videojs/tracks/html-track-element-list',[],function () {
    'use strict';
    class HtmlTrackElementList {
        constructor(trackElements = []) {
            this.trackElements_ = [];
            Object.defineProperty(this, 'length', {
                get() {
                    return this.trackElements_.length;
                }
            });
            for (let i = 0, length = trackElements.length; i < length; i++) {
                this.addTrackElement_(trackElements[i]);
            }
        }
        addTrackElement_(trackElement) {
            const index = this.trackElements_.length;
            if (!('' + index in this)) {
                Object.defineProperty(this, index, {
                    get() {
                        return this.trackElements_[index];
                    }
                });
            }
            if (this.trackElements_.indexOf(trackElement) === -1) {
                this.trackElements_.push(trackElement);
            }
        }
        getTrackElementByTrack_(track) {
            let trackElement_;
            for (let i = 0, length = this.trackElements_.length; i < length; i++) {
                if (track === this.trackElements_[i].track) {
                    trackElement_ = this.trackElements_[i];
                    break;
                }
            }
            return trackElement_;
        }
        removeTrackElement_(trackElement) {
            for (let i = 0, length = this.trackElements_.length; i < length; i++) {
                if (trackElement === this.trackElements_[i]) {
                    if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === 'function') {
                        this.trackElements_[i].track.off();
                    }
                    if (typeof this.trackElements_[i].off === 'function') {
                        this.trackElements_[i].off();
                    }
                    this.trackElements_.splice(i, 1);
                    break;
                }
            }
        }
    }
    return HtmlTrackElementList;
});
define('skylark-videojs-vtt/vtt',["skylark-langx-globals/document"],function(document){
  /**
   * Copyright 2013 vtt.js Contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */

  var _objCreate = Object.create || (function() {
    function F() {}
    return function(o) {
      if (arguments.length !== 1) {
        throw new Error('Object.create shim only accepts one parameter.');
      }
      F.prototype = o;
      return new F();
    };
  })();

  // Creates a new ParserError object from an errorData object. The errorData
  // object should have default code and message properties. The default message
  // property can be overriden by passing in a message parameter.
  // See ParsingError.Errors below for acceptable errors.
  function ParsingError(errorData, message) {
    this.name = "ParsingError";
    this.code = errorData.code;
    this.message = message || errorData.message;
  }
  ParsingError.prototype = _objCreate(Error.prototype);
  ParsingError.prototype.constructor = ParsingError;

  // ParsingError metadata for acceptable ParsingErrors.
  ParsingError.Errors = {
    BadSignature: {
      code: 0,
      message: "Malformed WebVTT signature."
    },
    BadTimeStamp: {
      code: 1,
      message: "Malformed time stamp."
    }
  };

  // Try to parse input as a time stamp.
  function parseTimeStamp(input) {

    function computeSeconds(h, m, s, f) {
      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
    }

    var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
    if (!m) {
      return null;
    }

    if (m[3]) {
      // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
      return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
    } else if (m[1] > 59) {
      // Timestamp takes the form of [hours]:[minutes].[milliseconds]
      // First position is hours as it's over 59.
      return computeSeconds(m[1], m[2], 0,  m[4]);
    } else {
      // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
      return computeSeconds(0, m[1], m[2], m[4]);
    }
  }

  // A settings object holds key/value pairs and will ignore anything but the first
  // assignment to a specific key.
  function Settings() {
    this.values = _objCreate(null);
  }

  Settings.prototype = {
    // Only accept the first assignment to any key.
    set: function(k, v) {
      if (!this.get(k) && v !== "") {
        this.values[k] = v;
      }
    },
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get: function(k, dflt, defaultKey) {
      if (defaultKey) {
        return this.has(k) ? this.values[k] : dflt[defaultKey];
      }
      return this.has(k) ? this.values[k] : dflt;
    },
    // Check whether we have a value for a key.
    has: function(k) {
      return k in this.values;
    },
    // Accept a setting if its one of the given alternatives.
    alt: function(k, v, a) {
      for (var n = 0; n < a.length; ++n) {
        if (v === a[n]) {
          this.set(k, v);
          break;
        }
      }
    },
    // Accept a setting if its a valid (signed) integer.
    integer: function(k, v) {
      if (/^-?\d+$/.test(v)) { // integer
        this.set(k, parseInt(v, 10));
      }
    },
    // Accept a setting if its a valid percentage.
    percent: function(k, v) {
      var m;
      if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
        v = parseFloat(v);
        if (v >= 0 && v <= 100) {
          this.set(k, v);
          return true;
        }
      }
      return false;
    }
  };

  // Helper function to parse input into groups separated by 'groupDelim', and
  // interprete each group as a key/value pair separated by 'keyValueDelim'.
  function parseOptions(input, callback, keyValueDelim, groupDelim) {
    var groups = groupDelim ? input.split(groupDelim) : [input];
    for (var i in groups) {
      if (typeof groups[i] !== "string") {
        continue;
      }
      var kv = groups[i].split(keyValueDelim);
      if (kv.length !== 2) {
        continue;
      }
      var k = kv[0];
      var v = kv[1];
      callback(k, v);
    }
  }

  function parseCue(input, cue, regionList) {
    // Remember the original input if we need to throw an error.
    var oInput = input;
    // 4.1 WebVTT timestamp
    function consumeTimeStamp() {
      var ts = parseTimeStamp(input);
      if (ts === null) {
        throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                              "Malformed timestamp: " + oInput);
      }
      // Remove time stamp from input.
      input = input.replace(/^[^\sa-zA-Z-]+/, "");
      return ts;
    }

    // 4.4.2 WebVTT cue settings
    function consumeCueSettings(input, cue) {
      var settings = new Settings();

      parseOptions(input, function (k, v) {
        switch (k) {
        case "region":
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case "vertical":
          settings.alt(k, v, ["rl", "lr"]);
          break;
        case "line":
          var vals = v.split(","),
              vals0 = vals[0];
          settings.integer(k, vals0);
          settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
          settings.alt(k, vals0, ["auto"]);
          if (vals.length === 2) {
            settings.alt("lineAlign", vals[1], ["start", "center", "end"]);
          }
          break;
        case "position":
          vals = v.split(",");
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt("positionAlign", vals[1], ["start", "center", "end"]);
          }
          break;
        case "size":
          settings.percent(k, v);
          break;
        case "align":
          settings.alt(k, v, ["start", "center", "end", "left", "right"]);
          break;
        }
      }, /:/, /\s/);

      // Apply default values for any missing fields.
      cue.region = settings.get("region", null);
      cue.vertical = settings.get("vertical", "");
      try {
        cue.line = settings.get("line", "auto");
      } catch (e) {}
      cue.lineAlign = settings.get("lineAlign", "start");
      cue.snapToLines = settings.get("snapToLines", true);
      cue.size = settings.get("size", 100);
      // Safari still uses the old middle value and won't accept center
      try {
        cue.align = settings.get("align", "center");
      } catch (e) {
        cue.align = settings.get("align", "middle");
      }
      try {
        cue.position = settings.get("position", "auto");
      } catch (e) {
        cue.position = settings.get("position", {
          start: 0,
          left: 0,
          center: 50,
          middle: 50,
          end: 100,
          right: 100
        }, cue.align);
      }


      cue.positionAlign = settings.get("positionAlign", {
        start: "start",
        left: "start",
        center: "center",
        middle: "center",
        end: "end",
        right: "end"
      }, cue.align);
    }

    function skipWhitespace() {
      input = input.replace(/^\s+/, "");
    }

    // 4.1 WebVTT cue timings.
    skipWhitespace();
    cue.startTime = consumeTimeStamp();   // (1) collect cue start time
    skipWhitespace();
    if (input.substr(0, 3) !== "-->") {     // (3) next characters must match "-->"
      throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                             "Malformed time stamp (time stamps must be separated by '-->'): " +
                             oInput);
    }
    input = input.substr(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp();     // (5) collect cue end time

    // 4.1 WebVTT cue settings list.
    skipWhitespace();
    consumeCueSettings(input, cue);
  }

  var TEXTAREA_ELEMENT = document.createElement("textarea");

  var TAG_NAME = {
    c: "span",
    i: "i",
    b: "b",
    u: "u",
    ruby: "ruby",
    rt: "rt",
    v: "span",
    lang: "span"
  };

  // 5.1 default text color
  // 5.2 default text background color is equivalent to text color with bg_ prefix
  var DEFAULT_COLOR_CLASS = {
    white: 'rgba(255,255,255,1)',
    lime: 'rgba(0,255,0,1)',
    cyan: 'rgba(0,255,255,1)',
    red: 'rgba(255,0,0,1)',
    yellow: 'rgba(255,255,0,1)',
    magenta: 'rgba(255,0,255,1)',
    blue: 'rgba(0,0,255,1)',
    black: 'rgba(0,0,0,1)'
  };

  var TAG_ANNOTATION = {
    v: "title",
    lang: "lang"
  };

  var NEEDS_PARENT = {
    rt: "ruby"
  };

  // Parse content into a document fragment.
  function parseContent(window, input) {
    function nextToken() {
      // Check for end-of-string.
      if (!input) {
        return null;
      }

      // Consume 'n' characters from the input.
      function consume(result) {
        input = input.substr(result.length);
        return result;
      }

      var m = input.match(/^([^<]*)(<[^>]*>?)?/);
      // If there is some text before the next tag, return it, otherwise return
      // the tag.
      return consume(m[1] ? m[1] : m[2]);
    }

    function unescape(s) {
      TEXTAREA_ELEMENT.innerHTML = s;
      s = TEXTAREA_ELEMENT.textContent;
      TEXTAREA_ELEMENT.textContent = "";
      return s;
    }

    function shouldAdd(current, element) {
      return !NEEDS_PARENT[element.localName] ||
             NEEDS_PARENT[element.localName] === current.localName;
    }

    // Create an element for this tag.
    function createElement(type, annotation) {
      var tagName = TAG_NAME[type];
      if (!tagName) {
        return null;
      }
      var element = window.document.createElement(tagName);
      var name = TAG_ANNOTATION[type];
      if (name && annotation) {
        element[name] = annotation.trim();
      }
      return element;
    }

    var rootDiv = window.document.createElement("div"),
        current = rootDiv,
        t,
        tagStack = [];

    while ((t = nextToken()) !== null) {
      if (t[0] === '<') {
        if (t[1] === "/") {
          // If the closing tag matches, move back up to the parent node.
          if (tagStack.length &&
              tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
            tagStack.pop();
            current = current.parentNode;
          }
          // Otherwise just ignore the end tag.
          continue;
        }
        var ts = parseTimeStamp(t.substr(1, t.length - 2));
        var node;
        if (ts) {
          // Timestamps are lead nodes as well.
          node = window.document.createProcessingInstruction("timestamp", ts);
          current.appendChild(node);
          continue;
        }
        var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
        // If we can't parse the tag, skip to the next tag.
        if (!m) {
          continue;
        }
        // Try to construct an element, and ignore the tag if we couldn't.
        node = createElement(m[1], m[3]);
        if (!node) {
          continue;
        }
        // Determine if the tag should be added based on the context of where it
        // is placed in the cuetext.
        if (!shouldAdd(current, node)) {
          continue;
        }
        // Set the class list (as a list of classes, separated by space).
        if (m[2]) {
          var classes = m[2].split('.');

          classes.forEach(function(cl) {
            var bgColor = /^bg_/.test(cl);
            // slice out `bg_` if it's a background color
            var colorName = bgColor ? cl.slice(3) : cl;

            if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
              var propName = bgColor ? 'background-color' : 'color';
              var propValue = DEFAULT_COLOR_CLASS[colorName];

              node.style[propName] = propValue;
            }
          });

          node.className = classes.join(' ');
        }
        // Append the node to the current node, and enter the scope of the new
        // node.
        tagStack.push(m[1]);
        current.appendChild(node);
        current = node;
        continue;
      }

      // Text nodes are leaf nodes.
      current.appendChild(window.document.createTextNode(unescape(t)));
    }

    return rootDiv;
  }

  // This is a list of all the Unicode characters that have a strong
  // right-to-left category. What this means is that these characters are
  // written right-to-left for sure. It was generated by pulling all the strong
  // right-to-left characters out of the Unicode data table. That table can
  // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
  var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],
   [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],
   [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],
   [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],
   [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],
   [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],
   [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],
   [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],
   [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],
   [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],
   [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],
   [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],
   [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],
   [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],
   [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],
   [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],
   [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],
   [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],
   [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],
   [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],
   [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],
   [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],
   [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],
   [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],
   [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];

  function isStrongRTLChar(charCode) {
    for (var i = 0; i < strongRTLRanges.length; i++) {
      var currentRange = strongRTLRanges[i];
      if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
        return true;
      }
    }

    return false;
  }

  function determineBidi(cueDiv) {
    var nodeStack = [],
        text = "",
        charCode;

    if (!cueDiv || !cueDiv.childNodes) {
      return "ltr";
    }

    function pushNodes(nodeStack, node) {
      for (var i = node.childNodes.length - 1; i >= 0; i--) {
        nodeStack.push(node.childNodes[i]);
      }
    }

    function nextTextNode(nodeStack) {
      if (!nodeStack || !nodeStack.length) {
        return null;
      }

      var node = nodeStack.pop(),
          text = node.textContent || node.innerText;
      if (text) {
        // TODO: This should match all unicode type B characters (paragraph
        // separator characters). See issue #115.
        var m = text.match(/^.*(\n|\r)/);
        if (m) {
          nodeStack.length = 0;
          return m[0];
        }
        return text;
      }
      if (node.tagName === "ruby") {
        return nextTextNode(nodeStack);
      }
      if (node.childNodes) {
        pushNodes(nodeStack, node);
        return nextTextNode(nodeStack);
      }
    }

    pushNodes(nodeStack, cueDiv);
    while ((text = nextTextNode(nodeStack))) {
      for (var i = 0; i < text.length; i++) {
        charCode = text.charCodeAt(i);
        if (isStrongRTLChar(charCode)) {
          return "rtl";
        }
      }
    }
    return "ltr";
  }

  function computeLinePos(cue) {
    if (typeof cue.line === "number" &&
        (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
      return cue.line;
    }
    if (!cue.track || !cue.track.textTrackList ||
        !cue.track.textTrackList.mediaElement) {
      return -1;
    }
    var track = cue.track,
        trackList = track.textTrackList,
        count = 0;
    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
      if (trackList[i].mode === "showing") {
        count++;
      }
    }
    return ++count * -1;
  }

  function StyleBox() {
  }

  // Apply styles to a div. If there is no div passed then it defaults to the
  // div on 'this'.
  StyleBox.prototype.applyStyles = function(styles, div) {
    div = div || this.div;
    for (var prop in styles) {
      if (styles.hasOwnProperty(prop)) {
        div.style[prop] = styles[prop];
      }
    }
  };

  StyleBox.prototype.formatStyle = function(val, unit) {
    return val === 0 ? 0 : val + unit;
  };

  // Constructs the computed display state of the cue (a div). Places the div
  // into the overlay which should be a block level element (usually a div).
  function CueStyleBox(window, cue, styleOptions) {
    StyleBox.call(this);
    this.cue = cue;

    // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will
    // have inline positioning and will function as the cue background box.
    this.cueDiv = parseContent(window, cue.text);
    var styles = {
      color: "rgba(255, 255, 255, 1)",
      backgroundColor:  "rgba(0, 0, 0, 0.8)",
      position: "relative",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      display: "inline",
      writingMode: cue.vertical === "" ? "horizontal-tb"
                                       : cue.vertical === "lr" ? "vertical-lr"
                                                               : "vertical-rl",
      unicodeBidi: "plaintext"
    };

    this.applyStyles(styles, this.cueDiv);

    // Create an absolutely positioned div that will be used to position the cue
    // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS
    // mirrors of them except middle instead of center on Safari.
    this.div = window.document.createElement("div");
    styles = {
      direction: determineBidi(this.cueDiv),
      writingMode: cue.vertical === "" ? "horizontal-tb"
                                       : cue.vertical === "lr" ? "vertical-lr"
                                                               : "vertical-rl",
      unicodeBidi: "plaintext",
      textAlign: cue.align === "middle" ? "center" : cue.align,
      font: styleOptions.font,
      whiteSpace: "pre-line",
      position: "absolute"
    };

    this.applyStyles(styles);
    this.div.appendChild(this.cueDiv);

    // Calculate the distance from the reference edge of the viewport to the text
    // position of the cue box. The reference edge will be resolved later when
    // the box orientation styles are applied.
    var textPos = 0;
    switch (cue.positionAlign) {
    case "start":
      textPos = cue.position;
      break;
    case "center":
      textPos = cue.position - (cue.size / 2);
      break;
    case "end":
      textPos = cue.position - cue.size;
      break;
    }

    // Horizontal box orientation; textPos is the distance from the left edge of the
    // area to the left edge of the box and cue.size is the distance extending to
    // the right from there.
    if (cue.vertical === "") {
      this.applyStyles({
        left:  this.formatStyle(textPos, "%"),
        width: this.formatStyle(cue.size, "%")
      });
    // Vertical box orientation; textPos is the distance from the top edge of the
    // area to the top edge of the box and cue.size is the height extending
    // downwards from there.
    } else {
      this.applyStyles({
        top: this.formatStyle(textPos, "%"),
        height: this.formatStyle(cue.size, "%")
      });
    }

    this.move = function(box) {
      this.applyStyles({
        top: this.formatStyle(box.top, "px"),
        bottom: this.formatStyle(box.bottom, "px"),
        left: this.formatStyle(box.left, "px"),
        right: this.formatStyle(box.right, "px"),
        height: this.formatStyle(box.height, "px"),
        width: this.formatStyle(box.width, "px")
      });
    };
  }
  CueStyleBox.prototype = _objCreate(StyleBox.prototype);
  CueStyleBox.prototype.constructor = CueStyleBox;

  // Represents the co-ordinates of an Element in a way that we can easily
  // compute things with such as if it overlaps or intersects with another Element.
  // Can initialize it with either a StyleBox or another BoxPosition.
  function BoxPosition(obj) {
    // Either a BoxPosition was passed in and we need to copy it, or a StyleBox
    // was passed in and we need to copy the results of 'getBoundingClientRect'
    // as the object returned is readonly. All co-ordinate values are in reference
    // to the viewport origin (top left).
    var lh, height, width, top;
    if (obj.div) {
      height = obj.div.offsetHeight;
      width = obj.div.offsetWidth;
      top = obj.div.offsetTop;

      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&
                  rects.getClientRects && rects.getClientRects();
      obj = obj.div.getBoundingClientRect();
      // In certain cases the outter div will be slightly larger then the sum of
      // the inner div's lines. This could be due to bold text, etc, on some platforms.
      // In this case we should get the average line height and use that. This will
      // result in the desired behaviour.
      lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)
                 : 0;

    }
    this.left = obj.left;
    this.right = obj.right;
    this.top = obj.top || top;
    this.height = obj.height || height;
    this.bottom = obj.bottom || (top + (obj.height || height));
    this.width = obj.width || width;
    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;
  }

  // Move the box along a particular axis. Optionally pass in an amount to move
  // the box. If no amount is passed then the default is the line height of the
  // box.
  BoxPosition.prototype.move = function(axis, toMove) {
    toMove = toMove !== undefined ? toMove : this.lineHeight;
    switch (axis) {
    case "+x":
      this.left += toMove;
      this.right += toMove;
      break;
    case "-x":
      this.left -= toMove;
      this.right -= toMove;
      break;
    case "+y":
      this.top += toMove;
      this.bottom += toMove;
      break;
    case "-y":
      this.top -= toMove;
      this.bottom -= toMove;
      break;
    }
  };

  // Check if this box overlaps another box, b2.
  BoxPosition.prototype.overlaps = function(b2) {
    return this.left < b2.right &&
           this.right > b2.left &&
           this.top < b2.bottom &&
           this.bottom > b2.top;
  };

  // Check if this box overlaps any other boxes in boxes.
  BoxPosition.prototype.overlapsAny = function(boxes) {
    for (var i = 0; i < boxes.length; i++) {
      if (this.overlaps(boxes[i])) {
        return true;
      }
    }
    return false;
  };

  // Check if this box is within another box.
  BoxPosition.prototype.within = function(container) {
    return this.top >= container.top &&
           this.bottom <= container.bottom &&
           this.left >= container.left &&
           this.right <= container.right;
  };

  // Check if this box is entirely within the container or it is overlapping
  // on the edge opposite of the axis direction passed. For example, if "+x" is
  // passed and the box is overlapping on the left edge of the container, then
  // return true.
  BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
    switch (axis) {
    case "+x":
      return this.left < container.left;
    case "-x":
      return this.right > container.right;
    case "+y":
      return this.top < container.top;
    case "-y":
      return this.bottom > container.bottom;
    }
  };

  // Find the percentage of the area that this box is overlapping with another
  // box.
  BoxPosition.prototype.intersectPercentage = function(b2) {
    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
        y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
        intersectArea = x * y;
    return intersectArea / (this.height * this.width);
  };

  // Convert the positions from this box to CSS compatible positions using
  // the reference container's positions. This has to be done because this
  // box's positions are in reference to the viewport origin, whereas, CSS
  // values are in referecne to their respective edges.
  BoxPosition.prototype.toCSSCompatValues = function(reference) {
    return {
      top: this.top - reference.top,
      bottom: reference.bottom - this.bottom,
      left: this.left - reference.left,
      right: reference.right - this.right,
      height: this.height,
      width: this.width
    };
  };

  // Get an object that represents the box's position without anything extra.
  // Can pass a StyleBox, HTMLElement, or another BoxPositon.
  BoxPosition.getSimpleBoxPosition = function(obj) {
    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;

    obj = obj.div ? obj.div.getBoundingClientRect() :
                  obj.tagName ? obj.getBoundingClientRect() : obj;
    var ret = {
      left: obj.left,
      right: obj.right,
      top: obj.top || top,
      height: obj.height || height,
      bottom: obj.bottom || (top + (obj.height || height)),
      width: obj.width || width
    };
    return ret;
  };

  // Move a StyleBox to its specified, or next best, position. The containerBox
  // is the box that contains the StyleBox, such as a div. boxPositions are
  // a list of other boxes that the styleBox can't overlap with.
  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {

    // Find the best position for a cue box, b, on the video. The axis parameter
    // is a list of axis, the order of which, it will move the box along. For example:
    // Passing ["+x", "-x"] will move the box first along the x axis in the positive
    // direction. If it doesn't find a good position for it there it will then move
    // it along the x axis in the negative direction.
    function findBestPosition(b, axis) {
      var bestPosition,
          specifiedPosition = new BoxPosition(b),
          percentage = 1; // Highest possible so the first thing we get is better.

      for (var i = 0; i < axis.length; i++) {
        while (b.overlapsOppositeAxis(containerBox, axis[i]) ||
               (b.within(containerBox) && b.overlapsAny(boxPositions))) {
          b.move(axis[i]);
        }
        // We found a spot where we aren't overlapping anything. This is our
        // best position.
        if (b.within(containerBox)) {
          return b;
        }
        var p = b.intersectPercentage(containerBox);
        // If we're outside the container box less then we were on our last try
        // then remember this position as the best position.
        if (percentage > p) {
          bestPosition = new BoxPosition(b);
          percentage = p;
        }
        // Reset the box position to the specified position.
        b = new BoxPosition(specifiedPosition);
      }
      return bestPosition || specifiedPosition;
    }

    var boxPosition = new BoxPosition(styleBox),
        cue = styleBox.cue,
        linePos = computeLinePos(cue),
        axis = [];

    // If we have a line number to align the cue to.
    if (cue.snapToLines) {
      var size;
      switch (cue.vertical) {
      case "":
        axis = [ "+y", "-y" ];
        size = "height";
        break;
      case "rl":
        axis = [ "+x", "-x" ];
        size = "width";
        break;
      case "lr":
        axis = [ "-x", "+x" ];
        size = "width";
        break;
      }

      var step = boxPosition.lineHeight,
          position = step * Math.round(linePos),
          maxPosition = containerBox[size] + step,
          initialAxis = axis[0];

      // If the specified intial position is greater then the max position then
      // clamp the box to the amount of steps it would take for the box to
      // reach the max position.
      if (Math.abs(position) > maxPosition) {
        position = position < 0 ? -1 : 1;
        position *= Math.ceil(maxPosition / step) * step;
      }

      // If computed line position returns negative then line numbers are
      // relative to the bottom of the video instead of the top. Therefore, we
      // need to increase our initial position by the length or width of the
      // video, depending on the writing direction, and reverse our axis directions.
      if (linePos < 0) {
        position += cue.vertical === "" ? containerBox.height : containerBox.width;
        axis = axis.reverse();
      }

      // Move the box to the specified position. This may not be its best
      // position.
      boxPosition.move(initialAxis, position);

    } else {
      // If we have a percentage line value for the cue.
      var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;

      switch (cue.lineAlign) {
      case "center":
        linePos -= (calculatedPercentage / 2);
        break;
      case "end":
        linePos -= calculatedPercentage;
        break;
      }

      // Apply initial line position to the cue box.
      switch (cue.vertical) {
      case "":
        styleBox.applyStyles({
          top: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "rl":
        styleBox.applyStyles({
          left: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "lr":
        styleBox.applyStyles({
          right: styleBox.formatStyle(linePos, "%")
        });
        break;
      }

      axis = [ "+y", "-x", "+x", "-y" ];

      // Get the box position again after we've applied the specified positioning
      // to it.
      boxPosition = new BoxPosition(styleBox);
    }

    var bestPosition = findBestPosition(boxPosition, axis);
    styleBox.move(bestPosition.toCSSCompatValues(containerBox));
  }

  function WebVTT() {
    // Nothing
  }

  // Helper to allow strings to be decoded instead of the default binary utf8 data.
  WebVTT.StringDecoder = function() {
    return {
      decode: function(data) {
        if (!data) {
          return "";
        }
        if (typeof data !== "string") {
          throw new Error("Error - expected string data.");
        }
        return decodeURIComponent(encodeURIComponent(data));
      }
    };
  };

  WebVTT.convertCueToDOMTree = function(window, cuetext) {
    if (!window || !cuetext) {
      return null;
    }
    return parseContent(window, cuetext);
  };

  var FONT_SIZE_PERCENT = 0.05;
  var FONT_STYLE = "sans-serif";
  var CUE_BACKGROUND_PADDING = "1.5%";

  // Runs the processing model over the cues and regions passed to it.
  // @param overlay A block level element (usually a div) that the computed cues
  //                and regions will be placed into.
  WebVTT.processCues = function(window, cues, overlay) {
    if (!window || !cues || !overlay) {
      return null;
    }

    // Remove all previous children.
    while (overlay.firstChild) {
      overlay.removeChild(overlay.firstChild);
    }

    var paddedOverlay = window.document.createElement("div");
    paddedOverlay.style.position = "absolute";
    paddedOverlay.style.left = "0";
    paddedOverlay.style.right = "0";
    paddedOverlay.style.top = "0";
    paddedOverlay.style.bottom = "0";
    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
    overlay.appendChild(paddedOverlay);

    // Determine if we need to compute the display states of the cues. This could
    // be the case if a cue's state has been changed since the last computation or
    // if it has not been computed yet.
    function shouldCompute(cues) {
      for (var i = 0; i < cues.length; i++) {
        if (cues[i].hasBeenReset || !cues[i].displayState) {
          return true;
        }
      }
      return false;
    }

    // We don't need to recompute the cues' display states. Just reuse them.
    if (!shouldCompute(cues)) {
      for (var i = 0; i < cues.length; i++) {
        paddedOverlay.appendChild(cues[i].displayState);
      }
      return;
    }

    var boxPositions = [],
        containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
        fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
    var styleOptions = {
      font: fontSize + "px " + FONT_STYLE
    };

    (function() {
      var styleBox, cue;

      for (var i = 0; i < cues.length; i++) {
        cue = cues[i];

        // Compute the intial position and styles of the cue div.
        styleBox = new CueStyleBox(window, cue, styleOptions);
        paddedOverlay.appendChild(styleBox.div);

        // Move the cue div to it's correct line position.
        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);

        // Remember the computed div so that we don't have to recompute it later
        // if we don't have too.
        cue.displayState = styleBox.div;

        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
      }
    })();
  };

  WebVTT.Parser = function(window, vttjs, decoder) {
    if (!decoder) {
      decoder = vttjs;
      vttjs = {};
    }
    if (!vttjs) {
      vttjs = {};
    }

    this.window = window;
    this.vttjs = vttjs;
    this.state = "INITIAL";
    this.buffer = "";
    this.decoder = decoder || new TextDecoder("utf8");
    this.regionList = [];
  };

  WebVTT.Parser.prototype = {
    // If the error is a ParsingError then report it to the consumer if
    // possible. If it's not a ParsingError then throw it like normal.
    reportOrThrowError: function(e) {
      if (e instanceof ParsingError) {
        this.onparsingerror && this.onparsingerror(e);
      } else {
        throw e;
      }
    },
    parse: function (data) {
      var self = this;

      // If there is no data then we won't decode it, but will just try to parse
      // whatever is in buffer already. This may occur in circumstances, for
      // example when flush() is called.
      if (data) {
        // Try to decode the data that we received.
        self.buffer += self.decoder.decode(data, {stream: true});
      }

      function collectNextLine() {
        var buffer = self.buffer;
        var pos = 0;
        while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
          ++pos;
        }
        var line = buffer.substr(0, pos);
        // Advance the buffer early in case we fail below.
        if (buffer[pos] === '\r') {
          ++pos;
        }
        if (buffer[pos] === '\n') {
          ++pos;
        }
        self.buffer = buffer.substr(pos);
        return line;
      }

      // 3.4 WebVTT region and WebVTT region settings syntax
      function parseRegion(input) {
        var settings = new Settings();

        parseOptions(input, function (k, v) {
          switch (k) {
          case "id":
            settings.set(k, v);
            break;
          case "width":
            settings.percent(k, v);
            break;
          case "lines":
            settings.integer(k, v);
            break;
          case "regionanchor":
          case "viewportanchor":
            var xy = v.split(',');
            if (xy.length !== 2) {
              break;
            }
            // We have to make sure both x and y parse, so use a temporary
            // settings object here.
            var anchor = new Settings();
            anchor.percent("x", xy[0]);
            anchor.percent("y", xy[1]);
            if (!anchor.has("x") || !anchor.has("y")) {
              break;
            }
            settings.set(k + "X", anchor.get("x"));
            settings.set(k + "Y", anchor.get("y"));
            break;
          case "scroll":
            settings.alt(k, v, ["up"]);
            break;
          }
        }, /=/, /\s/);

        // Create the region, using default values for any values that were not
        // specified.
        if (settings.has("id")) {
          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
          region.width = settings.get("width", 100);
          region.lines = settings.get("lines", 3);
          region.regionAnchorX = settings.get("regionanchorX", 0);
          region.regionAnchorY = settings.get("regionanchorY", 100);
          region.viewportAnchorX = settings.get("viewportanchorX", 0);
          region.viewportAnchorY = settings.get("viewportanchorY", 100);
          region.scroll = settings.get("scroll", "");
          // Register the region.
          self.onregion && self.onregion(region);
          // Remember the VTTRegion for later in case we parse any VTTCues that
          // reference it.
          self.regionList.push({
            id: settings.get("id"),
            region: region
          });
        }
      }

      // draft-pantos-http-live-streaming-20
      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5
      // 3.5 WebVTT
      function parseTimestampMap(input) {
        var settings = new Settings();

        parseOptions(input, function(k, v) {
          switch(k) {
          case "MPEGT":
            settings.integer(k + 'S', v);
            break;
          case "LOCA":
            settings.set(k + 'L', parseTimeStamp(v));
            break;
          }
        }, /[^\d]:/, /,/);

        self.ontimestampmap && self.ontimestampmap({
          "MPEGTS": settings.get("MPEGTS"),
          "LOCAL": settings.get("LOCAL")
        });
      }

      // 3.2 WebVTT metadata header syntax
      function parseHeader(input) {
        if (input.match(/X-TIMESTAMP-MAP/)) {
          // This line contains HLS X-TIMESTAMP-MAP metadata
          parseOptions(input, function(k, v) {
            switch(k) {
            case "X-TIMESTAMP-MAP":
              parseTimestampMap(v);
              break;
            }
          }, /=/);
        } else {
          parseOptions(input, function (k, v) {
            switch (k) {
            case "Region":
              // 3.3 WebVTT region metadata header syntax
              parseRegion(v);
              break;
            }
          }, /:/);
        }

      }

      // 5.1 WebVTT file parsing.
      try {
        var line;
        if (self.state === "INITIAL") {
          // We can't start parsing until we have the first line.
          if (!/\r\n|\n/.test(self.buffer)) {
            return this;
          }

          line = collectNextLine();

          var m = line.match(/^WEBVTT([ \t].*)?$/);
          if (!m || !m[0]) {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }

          self.state = "HEADER";
        }

        var alreadyCollectedLine = false;
        while (self.buffer) {
          // We can't parse a line until we have the full line.
          if (!/\r\n|\n/.test(self.buffer)) {
            return this;
          }

          if (!alreadyCollectedLine) {
            line = collectNextLine();
          } else {
            alreadyCollectedLine = false;
          }

          switch (self.state) {
          case "HEADER":
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = "ID";
            }
            continue;
          case "NOTE":
            // Ignore NOTE blocks.
            if (!line) {
              self.state = "ID";
            }
            continue;
          case "ID":
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = "NOTE";
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }
            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
            // Safari still uses the old middle value and won't accept center
            try {
              self.cue.align = "center";
            } catch (e) {
              self.cue.align = "middle";
            }
            self.state = "CUE";
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf("-->") === -1) {
              self.cue.id = line;
              continue;
            }
            // Process line as start of a cue.
            /*falls through*/
          case "CUE":
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              self.reportOrThrowError(e);
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = "BADCUE";
              continue;
            }
            self.state = "CUETEXT";
            continue;
          case "CUETEXT":
            var hasSubstring = line.indexOf("-->") !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              self.oncue && self.oncue(self.cue);
              self.cue = null;
              self.state = "ID";
              continue;
            }
            if (self.cue.text) {
              self.cue.text += "\n";
            }
            self.cue.text += line.replace(/\u2028/g, '\n').replace(/u2029/g, '\n');
            continue;
          case "BADCUE": // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = "ID";
            }
            continue;
          }
        }
      } catch (e) {
        self.reportOrThrowError(e);

        // If we are currently parsing a cue, report what we have.
        if (self.state === "CUETEXT" && self.cue && self.oncue) {
          self.oncue(self.cue);
        }
        self.cue = null;
        // Enter BADWEBVTT state if header was not parsed correctly otherwise
        // another exception occurred so enter BADCUE state.
        self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    },
    flush: function () {
      var self = this;
      try {
        // Finish decoding the stream.
        self.buffer += self.decoder.decode();
        // Synthesize the end of the current cue or region.
        if (self.cue || self.state === "HEADER") {
          self.buffer += "\n\n";
          self.parse();
        }
        // If we've flushed, parsed, and we're still on the INITIAL state then
        // that means we don't have enough of the stream to parse the first
        // line.
        if (self.state === "INITIAL") {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }
      } catch(e) {
        self.reportOrThrowError(e);
      }
      self.onflush && self.onflush();
      return this;
    }
  };

  return WebVTT;


});
define('skylark-videojs-vtt/vttcue',[
  "./vtt"
],function(WebVTT){
  /**
  /**
   * Copyright 2013 vtt.js Contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var autoKeyword = "auto";
  var directionSetting = {
    "": 1,
    "lr": 1,
    "rl": 1
  };
  var alignSetting = {
    "start": 1,
    "center": 1,
    "end": 1,
    "left": 1,
    "right": 1,
    "auto": 1,
    "line-left": 1,
    "line-right": 1
  };

  function findDirectionSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function VTTCue(startTime, endTime, text) {
    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    this.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = "";
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = "";
    var _snapToLines = true;
    var _line = "auto";
    var _lineAlign = "start";
    var _position = "auto";
    var _positionAlign = "auto";
    var _size = 100;
    var _align = "center";

    Object.defineProperties(this, {
      "id": {
        enumerable: true,
        get: function() {
          return _id;
        },
        set: function(value) {
          _id = "" + value;
        }
      },

      "pauseOnExit": {
        enumerable: true,
        get: function() {
          return _pauseOnExit;
        },
        set: function(value) {
          _pauseOnExit = !!value;
        }
      },

      "startTime": {
        enumerable: true,
        get: function() {
          return _startTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Start time must be set to a number.");
          }
          _startTime = value;
          this.hasBeenReset = true;
        }
      },

      "endTime": {
        enumerable: true,
        get: function() {
          return _endTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("End time must be set to a number.");
          }
          _endTime = value;
          this.hasBeenReset = true;
        }
      },

      "text": {
        enumerable: true,
        get: function() {
          return _text;
        },
        set: function(value) {
          _text = "" + value;
          this.hasBeenReset = true;
        }
      },

      "region": {
        enumerable: true,
        get: function() {
          return _region;
        },
        set: function(value) {
          _region = value;
          this.hasBeenReset = true;
        }
      },

      "vertical": {
        enumerable: true,
        get: function() {
          return _vertical;
        },
        set: function(value) {
          var setting = findDirectionSetting(value);
          // Have to check for false because the setting an be an empty string.
          if (setting === false) {
            throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
          }
          _vertical = setting;
          this.hasBeenReset = true;
        }
      },

      "snapToLines": {
        enumerable: true,
        get: function() {
          return _snapToLines;
        },
        set: function(value) {
          _snapToLines = !!value;
          this.hasBeenReset = true;
        }
      },

      "line": {
        enumerable: true,
        get: function() {
          return _line;
        },
        set: function(value) {
          if (typeof value !== "number" && value !== autoKeyword) {
            throw new SyntaxError("Line: an invalid number or illegal string was specified.");
          }
          _line = value;
          this.hasBeenReset = true;
        }
      },

      "lineAlign": {
        enumerable: true,
        get: function() {
          return _lineAlign;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            console.warn("lineAlign: an invalid or illegal string was specified.");
          } else {
            _lineAlign = setting;
            this.hasBeenReset = true;
          }
        }
      },

      "position": {
        enumerable: true,
        get: function() {
          return _position;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Position must be between 0 and 100.");
          }
          _position = value;
          this.hasBeenReset = true;
        }
      },

      "positionAlign": {
        enumerable: true,
        get: function() {
          return _positionAlign;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            console.warn("positionAlign: an invalid or illegal string was specified.");
          } else {
            _positionAlign = setting;
            this.hasBeenReset = true;
          }
        }
      },

      "size": {
        enumerable: true,
        get: function() {
          return _size;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Size must be between 0 and 100.");
          }
          _size = value;
          this.hasBeenReset = true;
        }
      },

      "align": {
        enumerable: true,
        get: function() {
          return _align;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
          }
          _align = setting;
          this.hasBeenReset = true;
        }
      }
    });

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    this.displayState = undefined;
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function() {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
});

define('skylark-videojs-vtt/vttregion',[
],function(){
  /**
   * Copyright 2013 vtt.js Contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var scrollSetting = {
    "": true,
    "up": true
  };

  function findScrollSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var scroll = scrollSetting[value.toLowerCase()];
    return scroll ? value.toLowerCase() : false;
  }

  function isValidPercentValue(value) {
    return typeof value === "number" && (value >= 0 && value <= 100);
  }

  // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface
  function VTTRegion() {
    var _width = 100;
    var _lines = 3;
    var _regionAnchorX = 0;
    var _regionAnchorY = 100;
    var _viewportAnchorX = 0;
    var _viewportAnchorY = 100;
    var _scroll = "";

    Object.defineProperties(this, {
      "width": {
        enumerable: true,
        get: function() {
          return _width;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("Width must be between 0 and 100.");
          }
          _width = value;
        }
      },
      "lines": {
        enumerable: true,
        get: function() {
          return _lines;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Lines must be set to a number.");
          }
          _lines = value;
        }
      },
      "regionAnchorY": {
        enumerable: true,
        get: function() {
          return _regionAnchorY;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("RegionAnchorX must be between 0 and 100.");
          }
          _regionAnchorY = value;
        }
      },
      "regionAnchorX": {
        enumerable: true,
        get: function() {
          return _regionAnchorX;
        },
        set: function(value) {
          if(!isValidPercentValue(value)) {
            throw new Error("RegionAnchorY must be between 0 and 100.");
          }
          _regionAnchorX = value;
        }
      },
      "viewportAnchorY": {
        enumerable: true,
        get: function() {
          return _viewportAnchorY;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorY must be between 0 and 100.");
          }
          _viewportAnchorY = value;
        }
      },
      "viewportAnchorX": {
        enumerable: true,
        get: function() {
          return _viewportAnchorX;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorX must be between 0 and 100.");
          }
          _viewportAnchorX = value;
        }
      },
      "scroll": {
        enumerable: true,
        get: function() {
          return _scroll;
        },
        set: function(value) {
          var setting = findScrollSetting(value);
          // Have to check for false as an empty string is a legal value.
          if (setting === false) {
            console.warn("Scroll: an invalid or illegal string was specified.");
          } else {
            _scroll = setting;
          }
        }
      }
    });
  }

  return VTTRegion;
});
define('skylark-videojs-vtt/main',[
	"./vtt",
	"./vttcue",
	"./vttregion"
],function(WebVTT,VTTCue,VTTRegion){
	return {
		WebVTT,
		VTTCue,
		VTTRegion
	};
});


define('skylark-videojs-vtt', ['skylark-videojs-vtt/main'], function (main) { return main; });

define('skylark-videojs/tracks/text-track-cue-list',[],function () {
    'use strict';
    class TextTrackCueList {
        constructor(cues) {
            TextTrackCueList.prototype.setCues_.call(this, cues);
            Object.defineProperty(this, 'length', {
                get() {
                    return this.length_;
                }
            });
        }
        setCues_(cues) {
            const oldLength = this.length || 0;
            let i = 0;
            const l = cues.length;
            this.cues_ = cues;
            this.length_ = cues.length;
            const defineProp = function (index) {
                if (!('' + index in this)) {
                    Object.defineProperty(this, '' + index, {
                        get() {
                            return this.cues_[index];
                        }
                    });
                }
            };
            if (oldLength < l) {
                i = oldLength;
                for (; i < l; i++) {
                    defineProp.call(this, i);
                }
            }
        }
        getCueById(id) {
            let result = null;
            for (let i = 0, l = this.length; i < l; i++) {
                const cue = this[i];
                if (cue.id === id) {
                    result = cue;
                    break;
                }
            }
            return result;
        }
    }
    return TextTrackCueList;
});
define('skylark-videojs/tracks/track-enums',[],function () {
    'use strict';
    const VideoTrackKind = {
        alternative: 'alternative',
        captions: 'captions',
        main: 'main',
        sign: 'sign',
        subtitles: 'subtitles',
        commentary: 'commentary'
    };
    const AudioTrackKind = {
        'alternative': 'alternative',
        'descriptions': 'descriptions',
        'main': 'main',
        'main-desc': 'main-desc',
        'translation': 'translation',
        'commentary': 'commentary'
    };
    const TextTrackKind = {
        subtitles: 'subtitles',
        captions: 'captions',
        descriptions: 'descriptions',
        chapters: 'chapters',
        metadata: 'metadata'
    };
    const TextTrackMode = {
        disabled: 'disabled',
        hidden: 'hidden',
        showing: 'showing'
    };
    return {
        VideoTrackKind: VideoTrackKind,
        AudioTrackKind: AudioTrackKind,
        TextTrackKind: TextTrackKind,
        TextTrackMode: TextTrackMode
    };
});
define('skylark-videojs/tracks/track',[
    '../utils/guid',
    '../event-target'
], function (Guid, EventTarget) {
    'use strict';
    class Track extends EventTarget {
        constructor(options = {}) {
            super();
            const trackProps = {
                id: options.id || 'vjs_track_' + Guid.newGUID(),
                kind: options.kind || '',
                language: options.language || ''
            };
            let label = options.label || '';
            for (const key in trackProps) {
                Object.defineProperty(this, key, {
                    get() {
                        return trackProps[key];
                    },
                    set() {
                    }
                });
            }
            Object.defineProperty(this, 'label', {
                get() {
                    return label;
                },
                set(newLabel) {
                    if (newLabel !== label) {
                        label = newLabel;
                        this.trigger('labelchange');
                    }
                }
            });
        }
    }
    return Track;
});
define('skylark-videojs/utils/url',[
    'skylark-langx-globals/document'
], function (document) {
    'use strict';
    const parseUrl = function (url) {
        const props = [
            'protocol',
            'hostname',
            'port',
            'pathname',
            'search',
            'hash',
            'host'
        ];
        let a = document.createElement('a');
        a.href = url;
        const addToBody = a.host === '' && a.protocol !== 'file:';
        let div;
        if (addToBody) {
            div = document.createElement('div');
            div.innerHTML = `<a href="${ url }"></a>`;
            a = div.firstChild;
            div.setAttribute('style', 'display:none; position:absolute;');
            document.body.appendChild(div);
        }
        const details = {};
        for (let i = 0; i < props.length; i++) {
            details[props[i]] = a[props[i]];
        }
        if (details.protocol === 'http:') {
            details.host = details.host.replace(/:80$/, '');
        }
        if (details.protocol === 'https:') {
            details.host = details.host.replace(/:443$/, '');
        }
        if (!details.protocol) {
            details.protocol = window.location.protocol;
        }
        if (addToBody) {
            document.body.removeChild(div);
        }
        return details;
    };
    const getAbsoluteURL = function (url) {
        if (!url.match(/^https?:\/\//)) {
            const div = document.createElement('div');
            div.innerHTML = `<a href="${ url }">x</a>`;
            url = div.firstChild.href;
        }
        return url;
    };
    const getFileExtension = function (path) {
        if (typeof path === 'string') {
            const splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
            const pathParts = splitPathRe.exec(path);
            if (pathParts) {
                return pathParts.pop().toLowerCase();
            }
        }
        return '';
    };
    const isCrossOrigin = function (url, winLoc = window.location) {
        const urlInfo = parseUrl(url);
        const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;
        const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
        return crossOrigin;
    };
    return {
        parseUrl: parseUrl,
        getAbsoluteURL: getAbsoluteURL,
        getFileExtension: getFileExtension,
        isCrossOrigin: isCrossOrigin
    };
});
define('skylark-videojs/utils/xhr',[
	"skylark-langx-globals/window",
	"skylark-langx-objects",
	"skylark-langx-types",
	"skylark-net-http/Xhr"
],function(window,objects,types,_Xhr){

	"use strict";

	/**
	 * @license
	 * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
	 * Copyright (c) 2014 David Bjrklund
	 * Available under the MIT license
	 * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
	 */

	var parseHeaders = function(headers) {
	    var result = {};

	    if (!headers) {
	        return result;
	    }

	    headers.trim().split('\n').forEach(function(row) {
	        var index = row.indexOf(':');
	        var key = row.slice(0, index).trim().toLowerCase();
	        var value = row.slice(index + 1).trim();

	        if (typeof(result[key]) === 'undefined') {
	          result[key] = value
	        } else if (Array.isArray(result[key])) {
	          result[key].push(value)
	        } else {
	          result[key] = [ result[key], value ]
	        }
	    });

	    return result;
	};


	createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
	createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

	forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
	    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
	        options = initParams(uri, options, callback)
	        options.method = method.toUpperCase()
	        return _createXHR(options)
	    }
	})

	function forEachArray(array, iterator) {
	    for (var i = 0; i < array.length; i++) {
	        iterator(array[i])
	    }
	}

	function isEmpty(obj){
	    for(var i in obj){
	        if(obj.hasOwnProperty(i)) return false
	    }
	    return true
	}

	function initParams(uri, options, callback) {
	    var params = uri

	    if (types.isFunction(options)) {
	        callback = options
	        if (typeof uri === "string") {
	            params = {uri:uri}
	        }
	    } else {
	        params = objects.mixin({}, options, {uri: uri})
	    }

	    params.callback = callback
	    return params
	}

	function createXHR(uri, options, callback) {
	    options = initParams(uri, options, callback)
	    return _createXHR(options)
	}

	function _createXHR(options) {
	    if(typeof options.callback === "undefined"){
	        throw new Error("callback argument missing")
	    }

	    var called = false
	    var callback = function cbOnce(err, response, body){
	        if(!called){
	            called = true
	            options.callback(err, response, body)
	        }
	    }

	    function readystatechange() {
	        if (xhr.readyState === 4) {
	            setTimeout(loadFunc, 0)
	        }
	    }

	    function getBody() {
	        // Chrome with requestType=blob throws errors arround when even testing access to responseText
	        var body = undefined

	        if (xhr.response) {
	            body = xhr.response
	        } else {
	            body = xhr.responseText || getXml(xhr)
	        }

	        if (isJson) {
	            try {
	                body = JSON.parse(body)
	            } catch (e) {}
	        }

	        return body
	    }

	    function errorFunc(evt) {
	        clearTimeout(timeoutTimer)
	        if(!(evt instanceof Error)){
	            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
	        }
	        evt.statusCode = 0
	        return callback(evt, failureResponse)
	    }

	    // will load the data & process the response in a special response object
	    function loadFunc() {
	        if (aborted) return
	        var status
	        clearTimeout(timeoutTimer)
	        if(options.useXDR && xhr.status===undefined) {
	            //IE8 CORS GET successful response doesn't have a status field, but body is fine
	            status = 200
	        } else {
	            status = (xhr.status === 1223 ? 204 : xhr.status)
	        }
	        var response = failureResponse
	        var err = null

	        if (status !== 0){
	            response = {
	                body: getBody(),
	                statusCode: status,
	                method: method,
	                headers: {},
	                url: uri,
	                rawRequest: xhr
	            }
	            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
	                response.headers = parseHeaders(xhr.getAllResponseHeaders())
	            }
	        } else {
	            err = new Error("Internal XMLHttpRequest Error")
	        }
	        return callback(err, response, response.body)
	    }

	    var xhr = options.xhr || null

	    if (!xhr) {
	        if (options.cors || options.useXDR) {
	            xhr = new createXHR.XDomainRequest()
	        }else{
	            xhr = new createXHR.XMLHttpRequest()
	        }
	    }

	    var key
	    var aborted
	    var uri = xhr.url = options.uri || options.url
	    var method = xhr.method = options.method || "GET"
	    var body = options.body || options.data
	    var headers = xhr.headers = options.headers || {}
	    var sync = !!options.sync
	    var isJson = false
	    var timeoutTimer
	    var failureResponse = {
	        body: undefined,
	        headers: {},
	        statusCode: 0,
	        method: method,
	        url: uri,
	        rawRequest: xhr
	    }

	    if ("json" in options && options.json !== false) {
	        isJson = true
	        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
	        if (method !== "GET" && method !== "HEAD") {
	            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
	            body = JSON.stringify(options.json === true ? body : options.json)
	        }
	    }

	    xhr.onreadystatechange = readystatechange
	    xhr.onload = loadFunc
	    xhr.onerror = errorFunc
	    // IE9 must have onprogress be set to a unique function.
	    xhr.onprogress = function () {
	        // IE must die
	    }
	    xhr.onabort = function(){
	        aborted = true;
	    }
	    xhr.ontimeout = errorFunc
	    xhr.open(method, uri, !sync, options.username, options.password)
	    //has to be after open
	    if(!sync) {
	        xhr.withCredentials = !!options.withCredentials
	    }
	    // Cannot set timeout with sync request
	    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
	    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
	    if (!sync && options.timeout > 0 ) {
	        timeoutTimer = setTimeout(function(){
	            if (aborted) return
	            aborted = true//IE9 may still call readystatechange
	            xhr.abort("timeout")
	            var e = new Error("XMLHttpRequest timeout")
	            e.code = "ETIMEDOUT"
	            errorFunc(e)
	        }, options.timeout )
	    }

	    if (xhr.setRequestHeader) {
	        for(key in headers){
	            if(headers.hasOwnProperty(key)){
	                xhr.setRequestHeader(key, headers[key])
	            }
	        }
	    } else if (options.headers && !isEmpty(options.headers)) {
	        throw new Error("Headers cannot be set on an XDomainRequest object")
	    }

	    if ("responseType" in options) {
	        xhr.responseType = options.responseType
	    }

	    if ("beforeSend" in options &&
	        typeof options.beforeSend === "function"
	    ) {
	        options.beforeSend(xhr)
	    }

	    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
	    // XMLHttpRequest spec says to pass null as body to indicate no body
	    // See https://github.com/naugtur/xhr/issues/100.
	    xhr.send(body || null)

	    return xhr


	}

	function getXml(xhr) {
	    // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
	    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
	    try {
	        if (xhr.responseType === "document") {
	            return xhr.responseXML
	        }
	        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
	        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
	            return xhr.responseXML
	        }
	    } catch (e) {}

	    return null
	}

	function noop() {}

	//return createXHR;


	return function(uri, options, callback) {
	    options = initParams(uri, options, callback);

	    var x =  _Xhr.request(options.uri,options).then(function(result){
	    	options.callback(null,x,result)
	    }).catch(function(e,status){
	    	options.callback(e,status);
	    });

	    return x;

	};


});
define('skylark-videojs/tracks/text-track',[
    'skylark-videojs-vtt',
    './text-track-cue-list',
    '../utils/fn',
    './track-enums',
    '../utils/log',
    './track',
    '../utils/url',
    '../utils/xhr',
    '../utils/merge-options'
], function (vtt,TextTrackCueList, Fn, TrackEnums, log, Track, url, XHR, merge) {
    'use strict';
    const parseCues = function (srcContent, track) {
        const parser = new vtt.WebVTT.Parser(window, vtt, vtt.WebVTT.StringDecoder());
        const errors = [];
        parser.oncue = function (cue) {
            track.addCue(cue);
        };
        parser.onparsingerror = function (error) {
            errors.push(error);
        };
        parser.onflush = function () {
            track.trigger({
                type: 'loadeddata',
                target: track
            });
        };
        parser.parse(srcContent);
        if (errors.length > 0) {
            if (window.console && window.console.groupCollapsed) {
                window.console.groupCollapsed(`Text Track parsing errors for ${ track.src }`);
            }
            errors.forEach(error => log.error(error));
            if (window.console && window.console.groupEnd) {
                window.console.groupEnd();
            }
        }
        parser.flush();
    };
    const loadTrack = function (src, track) {
        const opts = { uri: src };
        const crossOrigin = url.isCrossOrigin(src);
        if (crossOrigin) {
            opts.cors = crossOrigin;
        }
        const withCredentials = track.tech_.crossOrigin() === 'use-credentials';
        if (withCredentials) {
            opts.withCredentials = withCredentials;
        }
        XHR(opts, Fn.bind(this, function (err, response, responseBody) {
            if (err) {
                return log.error(err, response);
            }
            track.loaded_ = true;
            if (typeof vtt.WebVTT !== 'function') {
                if (track.tech_) {
                    track.tech_.any([
                        'vttjsloaded',
                        'vttjserror'
                    ], event => {
                        if (event.type === 'vttjserror') {
                            log.error(`vttjs failed to load, stopping trying to process ${ track.src }`);
                            return;
                        }
                        return parseCues(responseBody, track);
                    });
                }
            } else {
                parseCues(responseBody, track);
            }
        }));
    };
    class TextTrack extends Track {
        constructor(options = {}) {
            if (!options.tech) {
                throw new Error('A tech was not provided.');
            }
            const settings = merge(options, {
                kind: TrackEnums.TextTrackKind[options.kind] || 'subtitles',
                language: options.language || options.srclang || ''
            });
            let mode = TrackEnums.TextTrackMode[settings.mode] || 'disabled';
            const default_ = settings.default;
            if (settings.kind === 'metadata' || settings.kind === 'chapters') {
                mode = 'hidden';
            }
            super(settings);
            this.tech_ = settings.tech;
            this.cues_ = [];
            this.activeCues_ = [];
            this.preload_ = this.tech_.preloadTextTracks !== false;
            const cues = new TextTrackCueList(this.cues_);
            const activeCues = new TextTrackCueList(this.activeCues_);
            let changed = false;
            const timeupdateHandler = Fn.bind(this, function () {
                if (!this.tech_.isReady_ || this.tech_.isDisposed()) {
                    return;
                }
                this.activeCues = this.activeCues;
                if (changed) {
                    this.trigger('cuechange');
                    changed = false;
                }
            });
            const disposeHandler = () => {
                this.tech_.off('timeupdate', timeupdateHandler);
            };
            this.tech_.one('dispose', disposeHandler);
            if (mode !== 'disabled') {
                this.tech_.on('timeupdate', timeupdateHandler);
            }
            Object.defineProperties(this, {
                default: {
                    get() {
                        return default_;
                    },
                    set() {
                    }
                },
                mode: {
                    get() {
                        return mode;
                    },
                    set(newMode) {
                        if (!TrackEnums.TextTrackMode[newMode]) {
                            return;
                        }
                        if (mode === newMode) {
                            return;
                        }
                        mode = newMode;
                        if (!this.preload_ && mode !== 'disabled' && this.cues.length === 0) {
                            loadTrack(this.src, this);
                        }
                        this.tech_.off('timeupdate', timeupdateHandler);
                        if (mode !== 'disabled') {
                            this.tech_.on('timeupdate', timeupdateHandler);
                        }
                        this.trigger('modechange');
                    }
                },
                cues: {
                    get() {
                        if (!this.loaded_) {
                            return null;
                        }
                        return cues;
                    },
                    set() {
                    }
                },
                activeCues: {
                    get() {
                        if (!this.loaded_) {
                            return null;
                        }
                        if (this.cues.length === 0) {
                            return activeCues;
                        }
                        const ct = this.tech_.currentTime();
                        const active = [];
                        for (let i = 0, l = this.cues.length; i < l; i++) {
                            const cue = this.cues[i];
                            if (cue.startTime <= ct && cue.endTime >= ct) {
                                active.push(cue);
                            } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
                                active.push(cue);
                            }
                        }
                        changed = false;
                        if (active.length !== this.activeCues_.length) {
                            changed = true;
                        } else {
                            for (let i = 0; i < active.length; i++) {
                                if (this.activeCues_.indexOf(active[i]) === -1) {
                                    changed = true;
                                }
                            }
                        }
                        this.activeCues_ = active;
                        activeCues.setCues_(this.activeCues_);
                        return activeCues;
                    },
                    set() {
                    }
                }
            });
            if (settings.src) {
                this.src = settings.src;
                if (!this.preload_) {
                    this.loaded_ = true;
                }
                if (this.preload_ || default_ || settings.kind !== 'subtitles' && settings.kind !== 'captions') {
                    loadTrack(this.src, this);
                }
            } else {
                this.loaded_ = true;
            }
        }
        addCue(originalCue) {
            let cue = originalCue;
            if (vtt && !(originalCue instanceof vtt.VTTCue)) {
                cue = new vtt.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
                for (const prop in originalCue) {
                    if (!(prop in cue)) {
                        cue[prop] = originalCue[prop];
                    }
                }
                cue.id = originalCue.id;
                cue.originalCue_ = originalCue;
            }
            const tracks = this.tech_.textTracks();
            for (let i = 0; i < tracks.length; i++) {
                if (tracks[i] !== this) {
                    tracks[i].removeCue(cue);
                }
            }
            this.cues_.push(cue);
            this.cues.setCues_(this.cues_);
        }
        removeCue(removeCue) {
            let i = this.cues_.length;
            while (i--) {
                const cue = this.cues_[i];
                if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {
                    this.cues_.splice(i, 1);
                    this.cues.setCues_(this.cues_);
                    break;
                }
            }
        }
    }
    TextTrack.prototype.allowedEvents_ = { cuechange: 'cuechange' };
    return TextTrack;
});
define('skylark-videojs/tracks/audio-track',[
    './track-enums',
    './track',
    '../utils/merge-options'
], function (TrackEnums, Track, merge) {
    'use strict';
    class AudioTrack extends Track {
        constructor(options = {}) {
            const settings = merge(options, { kind: TrackEnums.AudioTrackKind[options.kind] || '' });
            super(settings);
            let enabled = false;
            Object.defineProperty(this, 'enabled', {
                get() {
                    return enabled;
                },
                set(newEnabled) {
                    if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
                        return;
                    }
                    enabled = newEnabled;
                    this.trigger('enabledchange');
                }
            });
            if (settings.enabled) {
                this.enabled = settings.enabled;
            }
            this.loaded_ = true;
        }
    }
    return AudioTrack;
});
define('skylark-videojs/tracks/video-track',[
    './track-enums',
    './track',
    '../utils/merge-options'
], function (TrackEnums, Track, merge) {
    'use strict';
    class VideoTrack extends Track {
        constructor(options = {}) {
            const settings = merge(options, { kind: TrackEnums.VideoTrackKind[options.kind] || '' });
            super(settings);
            let selected = false;
            Object.defineProperty(this, 'selected', {
                get() {
                    return selected;
                },
                set(newSelected) {
                    if (typeof newSelected !== 'boolean' || newSelected === selected) {
                        return;
                    }
                    selected = newSelected;
                    this.trigger('selectedchange');
                }
            });
            if (settings.selected) {
                this.selected = settings.selected;
            }
        }
    }
    return VideoTrack;
});
define('skylark-videojs/tracks/html-track-element',[
    '../event-target',
    '../tracks/text-track'
], function (EventTarget, TextTrack) {
    'use strict';
    const NONE = 0;
    const LOADING = 1;
    const LOADED = 2;
    const ERROR = 3;
    class HTMLTrackElement extends EventTarget {
        constructor(options = {}) {
            super();
            let readyState;
            const track = new TextTrack(options);
            this.kind = track.kind;
            this.src = track.src;
            this.srclang = track.language;
            this.label = track.label;
            this.default = track.default;
            Object.defineProperties(this, {
                readyState: {
                    get() {
                        return readyState;
                    }
                },
                track: {
                    get() {
                        return track;
                    }
                }
            });
            readyState = NONE;
            track.addEventListener('loadeddata', () => {
                readyState = LOADED;
                this.trigger({
                    type: 'load',
                    target: this
                });
            });
        }
    }
    HTMLTrackElement.prototype.allowedEvents_ = { load: 'load' };
    HTMLTrackElement.NONE = NONE;
    HTMLTrackElement.LOADING = LOADING;
    HTMLTrackElement.LOADED = LOADED;
    HTMLTrackElement.ERROR = ERROR;
    return HTMLTrackElement;
});
define('skylark-videojs/tracks/track-types',[
    './audio-track-list',
    './video-track-list',
    './text-track-list',
    './html-track-element-list',
    './text-track',
    './audio-track',
    './video-track',
    './html-track-element'
], function (AudioTrackList, VideoTrackList, TextTrackList, HtmlTrackElementList, TextTrack, AudioTrack, VideoTrack, HTMLTrackElement) {
    'use strict';
    const NORMAL = {
        audio: {
            ListClass: AudioTrackList,
            TrackClass: AudioTrack,
            capitalName: 'Audio'
        },
        video: {
            ListClass: VideoTrackList,
            TrackClass: VideoTrack,
            capitalName: 'Video'
        },
        text: {
            ListClass: TextTrackList,
            TrackClass: TextTrack,
            capitalName: 'Text'
        }
    };
    Object.keys(NORMAL).forEach(function (type) {
        NORMAL[type].getterName = `${ type }Tracks`;
        NORMAL[type].privateName = `${ type }Tracks_`;
    });
    const REMOTE = {
        remoteText: {
            ListClass: TextTrackList,
            TrackClass: TextTrack,
            capitalName: 'RemoteText',
            getterName: 'remoteTextTracks',
            privateName: 'remoteTextTracks_'
        },
        remoteTextEl: {
            ListClass: HtmlTrackElementList,
            TrackClass: HTMLTrackElement,
            capitalName: 'RemoteTextTrackEls',
            getterName: 'remoteTextTrackEls',
            privateName: 'remoteTextTrackEls_'
        }
    };
    const ALL = Object.assign({}, NORMAL, REMOTE);
    REMOTE.names = Object.keys(REMOTE);
    NORMAL.names = Object.keys(NORMAL);
    ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
    return {
        NORMAL,
        REMOTE,
        ALL
    };
});
define('skylark-videojs/tech/tech',[
    'skylark-langx-globals/window',
    'skylark-langx-globals/document',
    '../component',
    '../utils/merge-options',
    '../utils/fn',
    '../utils/log',
    '../utils/time-ranges',
    '../utils/buffer',
    '../media-error',
    '../utils/obj',
    '../tracks/track-types',
    '../utils/string-cases',
    'skylark-videojs-vtt'
], function (window, document, Component, mergeOptions, Fn, log, timeRages, buffer, MediaError, obj, TRACK_TYPES, stringCases, vtt) {
    'use strict';
    function createTrackHelper(self, kind, label, language, options = {}) {
        const tracks = self.textTracks();
        options.kind = kind;
        if (label) {
            options.label = label;
        }
        if (language) {
            options.language = language;
        }
        options.tech = self;
        const track = new TRACK_TYPES.ALL.text.TrackClass(options);
        tracks.addTrack(track);
        return track;
    }
    class Tech extends Component {
        constructor(options = {}, ready = function () {
        }) {
            options.reportTouchActivity = false;
            super(null, options, ready);
            this.hasStarted_ = false;
            this.listenTo('playing', function () {
                this.hasStarted_ = true;
            });
            this.listenTo('loadstart', function () {
                this.hasStarted_ = false;
            });
            TRACK_TYPES.ALL.names.forEach(name => {
                const props = TRACK_TYPES.ALL[name];
                if (options && options[props.getterName]) {
                    this[props.privateName] = options[props.getterName];
                }
            });
            if (!this.featuresProgressEvents) {
                this.manualProgressOn();
            }
            if (!this.featuresTimeupdateEvents) {
                this.manualTimeUpdatesOn();
            }
            [
                'Text',
                'Audio',
                'Video'
            ].forEach(track => {
                if (options[`native${ track }Tracks`] === false) {
                    this[`featuresNative${ track }Tracks`] = false;
                }
            });
            if (options.nativeCaptions === false || options.nativeTextTracks === false) {
                this.featuresNativeTextTracks = false;
            } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
                this.featuresNativeTextTracks = true;
            }
            if (!this.featuresNativeTextTracks) {
                this.emulateTextTracks();
            }
            this.preloadTextTracks = options.preloadTextTracks !== false;
            this.autoRemoteTextTracks_ = new TRACK_TYPES.ALL.text.ListClass();
            this.initTrackListeners();
            if (!options.nativeControlsForTouch) {
                this.emitTapEvents();
            }
            if (this.constructor) {
                this.name_ = this.constructor.name || 'Unknown Tech';
            }
        }
        triggerSourceset(src) {
            if (!this.isReady_) {
                this.listenToOnce('ready', () => this.setTimeout(() => this.triggerSourceset(src), 1));
            }
            this.trigger({
                src,
                type: 'sourceset'
            });
        }
        manualProgressOn() {
            this.listenTo('durationchange', this.listenToDurationChange);
            this.manualProgress = true;
            this.listenToOnce('ready', this.trackProgress);
        }
        manualProgressOff() {
            this.manualProgress = false;
            this.stopTrackingProgress();
            this.unlistenTo('durationchange', this.listenToDurationChange);
        }
        trackProgress(event) {
            this.stopTrackingProgress();
            this.progressInterval = this.setInterval(Fn.bind(this, function () {
                const numBufferedPercent = this.undefined();
                if (this.bufferedPercent_ !== numBufferedPercent) {
                    this.trigger('progress');
                }
                this.bufferedPercent_ = numBufferedPercent;
                if (numBufferedPercent === 1) {
                    this.stopTrackingProgress();
                }
            }), 500);
        }
        onDurationChange(event) {
            this.duration_ = this.duration();
        }
        buffered() {
            return timeRages.createTimeRange(0, 0);
        }
        bufferedPercent() {
            return buffer.bufferedPercent(this.buffered(), this.duration_);
        }
        stopTrackingProgress() {
            this.clearInterval(this.progressInterval);
        }
        manualTimeUpdatesOn() {
            this.manualTimeUpdates = true;
            this.listenTo('play', this.trackCurrentTime);
            this.listenTo('pause', this.stopTrackingCurrentTime);
        }
        manualTimeUpdatesOff() {
            this.manualTimeUpdates = false;
            this.stopTrackingCurrentTime();
            this.unlistenTo('play', this.trackCurrentTime);
            this.unlistenTo('pause', this.stopTrackingCurrentTime);
        }
        trackCurrentTime() {
            if (this.currentTimeInterval) {
                this.stopTrackingCurrentTime();
            }
            this.currentTimeInterval = this.setInterval(function () {
                this.trigger({
                    type: 'timeupdate',
                    target: this,
                    manuallyTriggered: true
                });
            }, 250);
        }
        stopTrackingCurrentTime() {
            this.clearInterval(this.currentTimeInterval);
            this.trigger({
                type: 'timeupdate',
                target: this,
                manuallyTriggered: true
            });
        }
        dispose() {
            this.clearTracks(TRACK_TYPES.NORMAL.names);
            if (this.manualProgress) {
                this.manualProgressOff();
            }
            if (this.manualTimeUpdates) {
                this.manualTimeUpdatesOff();
            }
            super.dispose();
        }
        clearTracks(types) {
            types = [].concat(types);
            types.forEach(type => {
                const list = this[`${ type }Tracks`]() || [];
                let i = list.length;
                while (i--) {
                    const track = list[i];
                    if (type === 'text') {
                        this.removeRemoteTextTrack(track);
                    }
                    list.removeTrack(track);
                }
            });
        }
        cleanupAutoTextTracks() {
            const list = this.autoRemoteTextTracks_ || [];
            let i = list.length;
            while (i--) {
                const track = list[i];
                this.removeRemoteTextTrack(track);
            }
        }
        reset() {
        }
        crossOrigin() {
        }
        setCrossOrigin() {
        }
        error(err) {
            if (err !== undefined) {
                this.error_ = new MediaError(err);
                this.trigger('error');
            }
            return this.error_;
        }
        played() {
            if (this.hasStarted_) {
                return timeRages.createTimeRange(0, 0);
            }
            return timeRages.createTimeRange();
        }
        play() {
        }
        setScrubbing() {
        }
        scrubbing() {
        }
        setCurrentTime() {
            if (this.manualTimeUpdates) {
                this.trigger({
                    type: 'timeupdate',
                    target: this,
                    manuallyTriggered: true
                });
            }
        }
        initTrackListeners() {
            TRACK_TYPES.NORMAL.names.forEach(name => {
                const props = TRACK_TYPES.NORMAL[name];
                const trackListChanges = () => {
                    this.trigger(`${ name }trackchange`);
                };
                const tracks = this[props.getterName]();
                tracks.addEventListener('removetrack', trackListChanges);
                tracks.addEventListener('addtrack', trackListChanges);
                this.listenTo('dispose', () => {
                    tracks.removeEventListener('removetrack', trackListChanges);
                    tracks.removeEventListener('addtrack', trackListChanges);
                });
            });
        }
        addWebVttScript_() {
            if (window.WebVTT) {
                return;
            }
            if (document.body.contains(this.el())) {
                if (!this.options_['vtt.js'] && obj.isPlain(vtt) && Object.keys(vtt).length > 0) {
                    this.trigger('vttjsloaded');
                    return;
                }
                const script = document.createElement('script');
                script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';
                script.onload = () => {
                    this.trigger('vttjsloaded');
                };
                script.onerror = () => {
                    this.trigger('vttjserror');
                };
                this.listenTo('dispose', () => {
                    script.onload = null;
                    script.onerror = null;
                });
                window.WebVTT = true;
                this.el().parentNode.appendChild(script);
            } else {
                this.ready(this.addWebVttScript_);
            }
        }
        emulateTextTracks() {
            const tracks = this.textTracks();
            const remoteTracks = this.remoteTextTracks();
            const handleAddTrack = e => tracks.addTrack(e.track);
            const handleRemoveTrack = e => tracks.removeTrack(e.track);
            remoteTracks.on('addtrack', handleAddTrack);
            remoteTracks.on('removetrack', handleRemoveTrack);
            this.addWebVttScript_();
            const updateDisplay = () => this.trigger('texttrackchange');
            const textTracksChanges = () => {
                updateDisplay();
                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    track.removeEventListener('cuechange', updateDisplay);
                    if (track.mode === 'showing') {
                        track.addEventListener('cuechange', updateDisplay);
                    }
                }
            };
            textTracksChanges();
            tracks.addEventListener('change', textTracksChanges);
            tracks.addEventListener('addtrack', textTracksChanges);
            tracks.addEventListener('removetrack', textTracksChanges);
            this.listenTo('dispose', function () {
                remoteTracks.off('addtrack', handleAddTrack);
                remoteTracks.off('removetrack', handleRemoveTrack);
                tracks.removeEventListener('change', textTracksChanges);
                tracks.removeEventListener('addtrack', textTracksChanges);
                tracks.removeEventListener('removetrack', textTracksChanges);
                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    track.removeEventListener('cuechange', updateDisplay);
                }
            });
        }
        addTextTrack(kind, label, language) {
            if (!kind) {
                throw new Error('TextTrack kind is required but was not provided');
            }
            return createTrackHelper(this, kind, label, language);
        }
        createRemoteTextTrack(options) {
            const track = mergeOptions(options, { tech: this });
            return new TRACK_TYPES.REMOTE.remoteTextEl.TrackClass(track);
        }
        addRemoteTextTrack(options = {}, manualCleanup) {
            const htmlTrackElement = this.createRemoteTextTrack(options);
            if (manualCleanup !== true && manualCleanup !== false) {
                log.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
                manualCleanup = true;
            }
            this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
            this.remoteTextTracks().addTrack(htmlTrackElement.track);
            if (manualCleanup !== true) {
                this.ready(() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track));
            }
            return htmlTrackElement;
        }
        removeRemoteTextTrack(track) {
            const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
            this.remoteTextTrackEls().removeTrackElement_(trackElement);
            this.remoteTextTracks().removeTrack(track);
            this.autoRemoteTextTracks_.removeTrack(track);
        }
        getVideoPlaybackQuality() {
            return {};
        }
        requestPictureInPicture() {
            const PromiseClass = this.options_.Promise || window.Promise;
            if (PromiseClass) {
                return PromiseClass.reject();
            }
        }
        disablePictureInPicture() {
            return true;
        }
        setDisablePictureInPicture() {
        }
        setPoster() {
        }
        playsinline() {
        }
        setPlaysinline() {
        }
        overrideNativeAudioTracks() {
        }
        overrideNativeVideoTracks() {
        }
        canPlayType() {
            return '';
        }
        static canPlayType() {
            return '';
        }
        static canPlaySource(srcObj, options) {
            return Tech.canPlayType(srcObj.type);
        }
        static isTech(component) {
            return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
        }
        static registerTech(name, tech) {
            if (!Tech.techs_) {
                Tech.techs_ = {};
            }
            if (!Tech.isTech(tech)) {
                throw new Error(`Tech ${ name } must be a Tech`);
            }
            if (!Tech.canPlayType) {
                throw new Error('Techs must have a static canPlayType method on them');
            }
            if (!Tech.canPlaySource) {
                throw new Error('Techs must have a static canPlaySource method on them');
            }
            name = stringCases.toTitleCase(name);
            Tech.techs_[name] = tech;
            Tech.techs_[stringCases.toLowerCase(name)] = tech;
            if (name !== 'Tech') {
                Tech.defaultTechOrder_.push(name);
            }
            return tech;
        }
        static getTech(name) {
            if (!name) {
                return;
            }
            if (Tech.techs_ && Tech.techs_[name]) {
                return Tech.techs_[name];
            }
            name = stringCases.toTitleCase(name);
            if (window && window.videojs && window.videojs[name]) {
                log.warn(`The ${ name } tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);
                return window.videojs[name];
            }
        }
    }
    TRACK_TYPES.ALL.names.forEach(function (name) {
        const props = TRACK_TYPES.ALL[name];
        Tech.prototype[props.getterName] = function () {
            this[props.privateName] = this[props.privateName] || new props.ListClass();
            return this[props.privateName];
        };
    });
    Tech.prototype.featuresVolumeControl = true;
    Tech.prototype.featuresMuteControl = true;
    Tech.prototype.featuresFullscreenResize = false;
    Tech.prototype.featuresPlaybackRate = false;
    Tech.prototype.featuresProgressEvents = false;
    Tech.prototype.featuresSourceset = false;
    Tech.prototype.featuresTimeupdateEvents = false;
    Tech.prototype.featuresNativeTextTracks = false;
    Tech.withSourceHandlers = function (_Tech) {
        _Tech.registerSourceHandler = function (handler, index) {
            let handlers = _Tech.sourceHandlers;
            if (!handlers) {
                handlers = _Tech.sourceHandlers = [];
            }
            if (index === undefined) {
                index = handlers.length;
            }
            handlers.splice(index, 0, handler);
        };
        _Tech.canPlayType = function (type) {
            const handlers = _Tech.sourceHandlers || [];
            let can;
            for (let i = 0; i < handlers.length; i++) {
                can = handlers[i].canPlayType(type);
                if (can) {
                    return can;
                }
            }
            return '';
        };
        _Tech.selectSourceHandler = function (source, options) {
            const handlers = _Tech.sourceHandlers || [];
            let can;
            for (let i = 0; i < handlers.length; i++) {
                can = handlers[i].canHandleSource(source, options);
                if (can) {
                    return handlers[i];
                }
            }
            return null;
        };
        _Tech.canPlaySource = function (srcObj, options) {
            const sh = _Tech.selectSourceHandler(srcObj, options);
            if (sh) {
                return sh.canHandleSource(srcObj, options);
            }
            return '';
        };
        const deferrable = [
            'seekable',
            'seeking',
            'duration'
        ];
        deferrable.forEach(function (fnName) {
            const originalFn = this[fnName];
            if (typeof originalFn !== 'function') {
                return;
            }
            this[fnName] = function () {
                if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
                    return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
                }
                return originalFn.apply(this, arguments);
            };
        }, _Tech.prototype);
        _Tech.prototype.setSource = function (source) {
            let sh = _Tech.selectSourceHandler(source, this.options_);
            if (!sh) {
                if (_Tech.nativeSourceHandler) {
                    sh = _Tech.nativeSourceHandler;
                } else {
                    log.error('No source handler found for the current source.');
                }
            }
            this.disposeSourceHandler();
            this.unlistenTo('dispose', this.disposeSourceHandler);
            if (sh !== _Tech.nativeSourceHandler) {
                this.currentSource_ = source;
            }
            this.sourceHandler_ = sh.handleSource(source, this, this.options_);
            this.listenToOnce('dispose', this.disposeSourceHandler);
        };
        _Tech.prototype.disposeSourceHandler = function () {
            if (this.currentSource_) {
                this.clearTracks([
                    'audio',
                    'video'
                ]);
                this.currentSource_ = null;
            }
            this.cleanupAutoTextTracks();
            if (this.sourceHandler_) {
                if (this.sourceHandler_.dispose) {
                    this.sourceHandler_.dispose();
                }
                this.sourceHandler_ = null;
            }
        };
    };
    Component.registerComponent('Tech', Tech);
    Tech.registerTech('Tech', Tech);
    Tech.defaultTechOrder_ = [];
    return Tech;
});
define('skylark-videojs/tech/middleware',[
    '../utils/obj',
    '../utils/string-cases'
], function (obj, stringCases) {
    'use strict';
    const middlewares = {};
    const middlewareInstances = {};
    const TERMINATOR = {};
    function use(type, middleware) {
        middlewares[type] = middlewares[type] || [];
        middlewares[type].push(middleware);
    }
    function getMiddleware(type) {
        if (type) {
            return middlewares[type];
        }
        return middlewares;
    }
    function setSource(player, src, next) {
        player.setTimeout(() => setSourceHelper(src, middlewares[src.type], next, player), 1);
    }
    function setTech(middleware, tech) {
        middleware.forEach(mw => mw.setTech && mw.setTech(tech));
    }
    function get(middleware, tech, method) {
        return middleware.reduceRight(middlewareIterator(method), tech[method]());
    }
    function set(middleware, tech, method, arg) {
        return tech[method](middleware.reduce(middlewareIterator(method), arg));
    }
    function mediate(middleware, tech, method, arg = null) {
        const callMethod = 'call' + stringCases.toTitleCase(method);
        const middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
        const terminated = middlewareValue === TERMINATOR;
        const returnValue = terminated ? null : tech[method](middlewareValue);
        executeRight(middleware, method, returnValue, terminated);
        return returnValue;
    }
    const allowedGetters = {
        buffered: 1,
        currentTime: 1,
        duration: 1,
        muted: 1,
        played: 1,
        paused: 1,
        seekable: 1,
        volume: 1
    };
    const allowedSetters = {
        setCurrentTime: 1,
        setMuted: 1,
        setVolume: 1
    };
    const allowedMediators = {
        play: 1,
        pause: 1
    };
    function middlewareIterator(method) {
        return (value, mw) => {
            if (value === TERMINATOR) {
                return TERMINATOR;
            }
            if (mw[method]) {
                return mw[method](value);
            }
            return value;
        };
    }
    function executeRight(mws, method, value, terminated) {
        for (let i = mws.length - 1; i >= 0; i--) {
            const mw = mws[i];
            if (mw[method]) {
                mw[method](terminated, value);
            }
        }
    }
    function clearCacheForPlayer(player) {
        middlewareInstances[player.id()] = null;
    }
    function getOrCreateFactory(player, mwFactory) {
        const mws = middlewareInstances[player.id()];
        let mw = null;
        if (mws === undefined || mws === null) {
            mw = mwFactory(player);
            middlewareInstances[player.id()] = [[
                    mwFactory,
                    mw
                ]];
            return mw;
        }
        for (let i = 0; i < mws.length; i++) {
            const [mwf, mwi] = mws[i];
            if (mwf !== mwFactory) {
                continue;
            }
            mw = mwi;
        }
        if (mw === null) {
            mw = mwFactory(player);
            mws.push([
                mwFactory,
                mw
            ]);
        }
        return mw;
    }
    function setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {
        const [mwFactory, ...mwrest] = middleware;
        if (typeof mwFactory === 'string') {
            setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
        } else if (mwFactory) {
            const mw = getOrCreateFactory(player, mwFactory);
            if (!mw.setSource) {
                acc.push(mw);
                return setSourceHelper(src, mwrest, next, player, acc, lastRun);
            }
            mw.setSource(obj.assign({}, src), function (err, _src) {
                if (err) {
                    return setSourceHelper(src, mwrest, next, player, acc, lastRun);
                }
                acc.push(mw);
                setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
            });
        } else if (mwrest.length) {
            setSourceHelper(src, mwrest, next, player, acc, lastRun);
        } else if (lastRun) {
            next(src, acc);
        } else {
            setSourceHelper(src, middlewares['*'], next, player, acc, true);
        }
    }
    return {
        TERMINATOR: TERMINATOR,
        use: use,
        getMiddleware: getMiddleware,
        setSource: setSource,
        setTech: setTech,
        get: get,
        set: set,
        mediate: mediate,
        allowedGetters: allowedGetters,
        allowedSetters: allowedSetters,
        allowedMediators: allowedMediators,
        clearCacheForPlayer: clearCacheForPlayer
    };
});
define('skylark-videojs/utils/mimetypes',['./url'], function (Url) {
    'use strict';
    const MimetypesKind = {
        opus: 'video/ogg',
        ogv: 'video/ogg',
        mp4: 'video/mp4',
        mov: 'video/mp4',
        m4v: 'video/mp4',
        mkv: 'video/x-matroska',
        m4a: 'audio/mp4',
        mp3: 'audio/mpeg',
        aac: 'audio/aac',
        caf: 'audio/x-caf',
        flac: 'audio/flac',
        oga: 'audio/ogg',
        wav: 'audio/wav',
        m3u8: 'application/x-mpegURL',
        jpg: 'image/jpeg',
        jpeg: 'image/jpeg',
        gif: 'image/gif',
        png: 'image/png',
        svg: 'image/svg+xml',
        webp: 'image/webp'
    };
    const getMimetype = function (src = '') {
        const ext = Url.getFileExtension(src);
        const mimetype = MimetypesKind[ext.toLowerCase()];
        return mimetype || '';
    };
    const findMimetype = (player, src) => {
        if (!src) {
            return '';
        }
        if (player.cache_.source.src === src && player.cache_.source.type) {
            return player.cache_.source.type;
        }
        const matchingSources = player.cache_.sources.filter(s => s.src === src);
        if (matchingSources.length) {
            return matchingSources[0].type;
        }
        const sources = player.$$('source');
        for (let i = 0; i < sources.length; i++) {
            const s = sources[i];
            if (s.type && s.src && s.src === src) {
                return s.type;
            }
        }
        return getMimetype(src);
    };
    return {
        MimetypesKind: MimetypesKind,
        getMimetype: getMimetype,
        findMimetype: findMimetype
    };
});
define('skylark-videojs/utils/filter-source',[
    './obj',
    './mimetypes'
], function (obj, mimetypes) {
    'use strict';
    const filterSource = function (src) {
        if (Array.isArray(src)) {
            let newsrc = [];
            src.forEach(function (srcobj) {
                srcobj = filterSource(srcobj);
                if (Array.isArray(srcobj)) {
                    newsrc = newsrc.concat(srcobj);
                } else if (obj.isObject(srcobj)) {
                    newsrc.push(srcobj);
                }
            });
            src = newsrc;
        } else if (typeof src === 'string' && src.trim()) {
            src = [fixSource({ src })];
        } else if (obj.isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {
            src = [fixSource(src)];
        } else {
            src = [];
        }
        return src;
    };
    function fixSource(src) {
        if (!src.type) {
            const mimetype = mimetypes.getMimetype(src.src);
            if (mimetype) {
                src.type = mimetype;
            }
        }
        return src;
    }
    return filterSource;
});
define('skylark-videojs/tech/loader',[
    '../component',
    './tech',
    '../utils/string-cases',
    '../utils/merge-options'
], function (Component, Tech, stringCases, mergeOptions) {
    'use strict';
    class MediaLoader extends Component {
        constructor(player, options, ready) {
            const options_ = mergeOptions({ createEl: false }, options);
            super(player, options_, ready);
            if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
                for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
                    const techName = stringCases.toTitleCase(j[i]);
                    let tech = Tech.getTech(techName);
                    if (!techName) {
                        tech = Component.getComponent(techName);
                    }
                    if (tech && tech.isSupported()) {
                        player.loadTech_(techName);
                        break;
                    }
                }
            } else {
                player.src(options.playerOptions.sources);
            }
        }
    }
    Component.registerComponent('MediaLoader', MediaLoader);
    return MediaLoader;
});
define('skylark-videojs/clickable-component',[
    './component',
    './utils/dom',
    './utils/log',
    './utils/obj',
    './utils/keycode'
], function (Component, Dom, log, obj, keycode) {
    'use strict';
    class ClickableComponent extends Component {
        constructor(player, options) {
            super(player, options);
            this.emitTapEvents();
            this.enable();
        }
        createEl(tag = 'div', props = {}, attributes = {}) {
            props = obj.assign({
                innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
                className: this.buildCSSClass(),
                tabIndex: 0
            }, props);
            if (tag === 'button') {
                log.error(`Creating a ClickableComponent with an HTML element of ${ tag } is not supported; use a Button instead.`);
            }
            attributes = obj.assign({ role: 'button' }, attributes);
            this.tabIndex_ = props.tabIndex;
            const el = super.createEl(tag, props, attributes);
            this.createControlTextEl(el);
            return el;
        }
        dispose() {
            this.controlTextEl_ = null;
            super.dispose();
        }
        createControlTextEl(el) {
            this.controlTextEl_ = Dom.createEl('span', { className: 'vjs-control-text' }, { 'aria-live': 'polite' });
            if (el) {
                el.appendChild(this.controlTextEl_);
            }
            this.controlText(this.controlText_, el);
            return this.controlTextEl_;
        }
        controlText(text, el = this.el()) {
            if (text === undefined) {
                return this.controlText_ || 'Need Text';
            }
            const localizedText = this.localize(text);
            this.controlText_ = text;
            Dom.textContent(this.controlTextEl_, localizedText);
            if (!this.nonIconControl) {
                el.setAttribute('title', localizedText);
            }
        }
        buildCSSClass() {
            return `vjs-control vjs-button ${ super.buildCSSClass() }`;
        }
        enable() {
            if (!this.enabled_) {
                this.enabled_ = true;
                this.removeClass('vjs-disabled');
                this.el_.setAttribute('aria-disabled', 'false');
                if (typeof this.tabIndex_ !== 'undefined') {
                    this.el_.setAttribute('tabIndex', this.tabIndex_);
                }
                this.listenTo([
                    'tap',
                    'click'
                ], this.handleClick);
                this.listenTo('keydown', this.handleKeyDown);
            }
        }
        disable() {
            this.enabled_ = false;
            this.addClass('vjs-disabled');
            this.el_.setAttribute('aria-disabled', 'true');
            if (typeof this.tabIndex_ !== 'undefined') {
                this.el_.removeAttribute('tabIndex');
            }
            this.unlistenTo('mouseover', this.handleMouseOver);
            this.unlistenTo('mouseout', this.handleMouseOut);
            this.unlistenTo([
                'tap',
                'click'
            ], this.handleClick);
            this.unlistenTo('keydown', this.handleKeyDown);
        }
        handleLanguagechange() {
            this.controlText(this.controlText_);
        }
        handleClick(event) {
            if (this.options_.clickHandler) {
                this.options_.clickHandler.call(this, arguments);
            }
        }
        handleKeyDown(event) {
            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {
                event.preventDefault();
                event.stopPropagation();
                this.trigger('click');
            } else {
                super.handleKeyDown(event);
            }
        }
    }
    Component.registerComponent('ClickableComponent', ClickableComponent);
    return ClickableComponent;
});
define('skylark-videojs/poster-image',[
    './clickable-component',
    './component',
    './utils/fn',
    './utils/dom',
    './utils/promise',
    './utils/browser'
], function (ClickableComponent, Component, Fn, Dom, promise, browser) {
    'use strict';
    class PosterImage extends ClickableComponent {
        constructor(player, options) {
            super(player, options);
            this.update();
            this.listenTo(player,'posterchange',this.update);
        }
        dispose() {
            this.unlistenTo(this.player(),'posterchange', this.update);
            super.dispose();
        }
        createEl() {
            const el = Dom.createEl('div', {
                className: 'vjs-poster',
                tabIndex: -1
            });
            return el;
        }
        update(event) {
            const url = this.player().poster();
            this.setSrc(url);
            if (url) {
                this.show();
            } else {
                this.hide();
            }
        }
        setSrc(url) {
            let backgroundImage = '';
            if (url) {
                backgroundImage = `url("${ url }")`;
            }
            this.el_.style.backgroundImage = backgroundImage;
        }
        handleClick(event) {
            if (!this.player_.controls()) {
                return;
            }
            const sourceIsEncrypted = this.player_.usingPlugin('eme') && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
            if (this.player_.tech(true) && !((browser.IE_VERSION || browser.IS_EDGE) && sourceIsEncrypted)) {
                this.player_.tech(true).focus();
            }
            if (this.player_.paused()) {
                promise.silencePromise(this.player_.play());
            } else {
                this.player_.pause();
            }
        }
    }
    Component.registerComponent('PosterImage', PosterImage);
    return PosterImage;
});
define('skylark-videojs/tracks/text-track-display',[
    '../component',
    '../utils/fn',
    '../utils/dom'
], function (Component, Fn, Dom) {
    'use strict';
    const darkGray = '#222';
    const lightGray = '#ccc';
    const fontMap = {
        monospace: 'monospace',
        sansSerif: 'sans-serif',
        serif: 'serif',
        monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
        monospaceSerif: '"Courier New", monospace',
        proportionalSansSerif: 'sans-serif',
        proportionalSerif: 'serif',
        casual: '"Comic Sans MS", Impact, fantasy',
        script: '"Monotype Corsiva", cursive',
        smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
    };
    function constructColor(color, opacity) {
        let hex;
        if (color.length === 4) {
            hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
        } else if (color.length === 7) {
            hex = color.slice(1);
        } else {
            throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');
        }
        return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';
    }
    function tryUpdateStyle(el, style, rule) {
        try {
            el.style[style] = rule;
        } catch (e) {
            return;
        }
    }
    class TextTrackDisplay extends Component {
        constructor(player, options, ready) {
            super(player, options, ready);
            const updateDisplayHandler = Fn.bind(this, this.updateDisplay);
            player.on('loadstart', Fn.bind(this, this.toggleDisplay));
            player.on('texttrackchange', updateDisplayHandler);
            player.on('loadedmetadata', Fn.bind(this, this.preselectTrack));
            player.ready(Fn.bind(this, function () {
                if (player.tech_ && player.tech_.featuresNativeTextTracks) {
                    this.hide();
                    return;
                }
                player.on('fullscreenchange', updateDisplayHandler);
                player.on('playerresize', updateDisplayHandler);
                window.addEventListener('orientationchange', updateDisplayHandler);
                player.on('dispose', () => window.removeEventListener('orientationchange', updateDisplayHandler));
                const tracks = this.options_.playerOptions.tracks || [];
                for (let i = 0; i < tracks.length; i++) {
                    this.player_.addRemoteTextTrack(tracks[i], true);
                }
                this.preselectTrack();
            }));
        }
        preselectTrack() {
            const modes = {
                captions: 1,
                subtitles: 1
            };
            const trackList = this.player_.textTracks();
            const userPref = this.player_.cache_.selectedLanguage;
            let firstDesc;
            let firstCaptions;
            let preferredTrack;
            for (let i = 0; i < trackList.length; i++) {
                const track = trackList[i];
                if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
                    if (track.kind === userPref.kind) {
                        preferredTrack = track;
                    } else if (!preferredTrack) {
                        preferredTrack = track;
                    }
                } else if (userPref && !userPref.enabled) {
                    preferredTrack = null;
                    firstDesc = null;
                    firstCaptions = null;
                } else if (track.default) {
                    if (track.kind === 'descriptions' && !firstDesc) {
                        firstDesc = track;
                    } else if (track.kind in modes && !firstCaptions) {
                        firstCaptions = track;
                    }
                }
            }
            if (preferredTrack) {
                preferredTrack.mode = 'showing';
            } else if (firstCaptions) {
                firstCaptions.mode = 'showing';
            } else if (firstDesc) {
                firstDesc.mode = 'showing';
            }
        }
        toggleDisplay() {
            if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
                this.hide();
            } else {
                this.show();
            }
        }
        createEl() {
            return super.createEl('div', { className: 'vjs-text-track-display' }, {
                'aria-live': 'off',
                'aria-atomic': 'true'
            });
        }
        clearDisplay() {
            if (typeof window.WebVTT === 'function') {
                window.WebVTT.processCues(window, [], this.el_);
            }
        }
        updateDisplay() {
            const tracks = this.player_.textTracks();
            const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
            this.clearDisplay();
            if (allowMultipleShowingTracks) {
                const showingTracks = [];
                for (let i = 0; i < tracks.length; ++i) {
                    const track = tracks[i];
                    if (track.mode !== 'showing') {
                        continue;
                    }
                    showingTracks.push(track);
                }
                this.updateForTrack(showingTracks);
                return;
            }
            let descriptionsTrack = null;
            let captionsSubtitlesTrack = null;
            let i = tracks.length;
            while (i--) {
                const track = tracks[i];
                if (track.mode === 'showing') {
                    if (track.kind === 'descriptions') {
                        descriptionsTrack = track;
                    } else {
                        captionsSubtitlesTrack = track;
                    }
                }
            }
            if (captionsSubtitlesTrack) {
                if (this.getAttribute('aria-live') !== 'off') {
                    this.setAttribute('aria-live', 'off');
                }
                this.updateForTrack(captionsSubtitlesTrack);
            } else if (descriptionsTrack) {
                if (this.getAttribute('aria-live') !== 'assertive') {
                    this.setAttribute('aria-live', 'assertive');
                }
                this.updateForTrack(descriptionsTrack);
            }
        }
        updateDisplayState(track) {
            const overrides = this.player_.textTrackSettings.getValues();
            const cues = track.activeCues;
            let i = cues.length;
            while (i--) {
                const cue = cues[i];
                if (!cue) {
                    continue;
                }
                const cueDiv = cue.displayState;
                if (overrides.color) {
                    cueDiv.firstChild.style.color = overrides.color;
                }
                if (overrides.textOpacity) {
                    tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
                }
                if (overrides.backgroundColor) {
                    cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
                }
                if (overrides.backgroundOpacity) {
                    tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
                }
                if (overrides.windowColor) {
                    if (overrides.windowOpacity) {
                        tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
                    } else {
                        cueDiv.style.backgroundColor = overrides.windowColor;
                    }
                }
                if (overrides.edgeStyle) {
                    if (overrides.edgeStyle === 'dropshadow') {
                        cueDiv.firstChild.style.textShadow = `2px 2px 3px ${ darkGray }, 2px 2px 4px ${ darkGray }, 2px 2px 5px ${ darkGray }`;
                    } else if (overrides.edgeStyle === 'raised') {
                        cueDiv.firstChild.style.textShadow = `1px 1px ${ darkGray }, 2px 2px ${ darkGray }, 3px 3px ${ darkGray }`;
                    } else if (overrides.edgeStyle === 'depressed') {
                        cueDiv.firstChild.style.textShadow = `1px 1px ${ lightGray }, 0 1px ${ lightGray }, -1px -1px ${ darkGray }, 0 -1px ${ darkGray }`;
                    } else if (overrides.edgeStyle === 'uniform') {
                        cueDiv.firstChild.style.textShadow = `0 0 4px ${ darkGray }, 0 0 4px ${ darkGray }, 0 0 4px ${ darkGray }, 0 0 4px ${ darkGray }`;
                    }
                }
                if (overrides.fontPercent && overrides.fontPercent !== 1) {
                    const fontSize = window.parseFloat(cueDiv.style.fontSize);
                    cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
                    cueDiv.style.height = 'auto';
                    cueDiv.style.top = 'auto';
                }
                if (overrides.fontFamily && overrides.fontFamily !== 'default') {
                    if (overrides.fontFamily === 'small-caps') {
                        cueDiv.firstChild.style.fontVariant = 'small-caps';
                    } else {
                        cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
                    }
                }
            }
        }
        updateForTrack(tracks) {
            if (!Array.isArray(tracks)) {
                tracks = [tracks];
            }
            if (typeof window.WebVTT !== 'function' || tracks.every(track => {
                    return !track.activeCues;
                })) {
                return;
            }
            const cues = [];
            for (let i = 0; i < tracks.length; ++i) {
                const track = tracks[i];
                for (let j = 0; j < track.activeCues.length; ++j) {
                    cues.push(track.activeCues[j]);
                }
            }
            window.WebVTT.processCues(window, cues, this.el_);
            for (let i = 0; i < tracks.length; ++i) {
                const track = tracks[i];
                for (let j = 0; j < track.activeCues.length; ++j) {
                    const cueEl = track.activeCues[j].displayState;
                    Dom.addClass(cueEl, 'vjs-text-track-cue');
                    Dom.addClass(cueEl, 'vjs-text-track-cue-' + (track.language ? track.language : i));
                }
                if (this.player_.textTrackSettings) {
                    this.updateDisplayState(track);
                }
            }
        }
    }
    
    Component.registerComponent('TextTrackDisplay', TextTrackDisplay);


    TextTrackDisplay.constructColor = constructColor;

    return TextTrackDisplay;
});
define('skylark-videojs/loading-spinner',[
    './component',
    './utils/dom'
], function (Component, dom) {
    'use strict';
    class LoadingSpinner extends Component {
        createEl() {
            const isAudio = this.player_.isAudio();
            const playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');
            const controlText = dom.createEl('span', {
                className: 'vjs-control-text',
                innerHTML: this.localize('{1} is loading.', [playerType])
            });
            const el = super.createEl('div', {
                className: 'vjs-loading-spinner',
                dir: 'ltr'
            });
            el.appendChild(controlText);
            return el;
        }
    }
    Component.registerComponent('LoadingSpinner', LoadingSpinner);
    return LoadingSpinner;
});
define('skylark-videojs/button',[
    './clickable-component',
    './component',
    './utils/log',
    './utils/obj',
    './utils/keycode'
], function (ClickableComponent, Component, log, obj, keycode) {
    'use strict';
    class Button extends ClickableComponent {
        createEl(tag, props = {}, attributes = {}) {
            tag = 'button';
            props = obj.assign({
                innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
                className: this.buildCSSClass()
            }, props);
            attributes = obj.assign({ type: 'button' }, attributes);
            const el = Component.prototype.createEl.call(this, tag, props, attributes);
            this.createControlTextEl(el);
            return el;
        }
        addChild(child, options = {}) {
            const className = this.constructor.name;
            log.warn(`Adding an actionable (user controllable) child to a Button (${ className }) is not supported; use a ClickableComponent instead.`);
            return Component.prototype.addChild.call(this, child, options);
        }
        enable() {
            super.enable();
            this.el_.removeAttribute('disabled');
        }
        disable() {
            super.disable();
            this.el_.setAttribute('disabled', 'disabled');
        }
        handleKeyDown(event) {
            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {
                event.stopPropagation();
                return;
            }
            super.handleKeyDown(event);
        }
    }
    Component.registerComponent('Button', Button);
    return Button;
});
define('skylark-videojs/big-play-button',[
    './button',
    './component',
    './utils/promise',
    './utils/browser'
], function (Button, Component, promise, browser) {
    'use strict';
    class BigPlayButton extends Button {
        constructor(player, options) {
            super(player, options);
            this.mouseused_ = false;
            this.listenTo('mousedown', this.handleMouseDown);
        }
        buildCSSClass() {
            return 'vjs-big-play-button';
        }
        handleClick(event) {
            const playPromise = this.player_.play();
            if (this.mouseused_ && event.clientX && event.clientY) {
                const sourceIsEncrypted = this.player_.usingPlugin('eme') && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
                promise.silencePromise(playPromise);
                if (this.player_.tech(true) && !((browser.IE_VERSION || browser.IS_EDGE) && sourceIsEncrypted)) {
                    this.player_.tech(true).focus();
                }
                return;
            }
            const cb = this.player_.getChild('controlBar');
            const playToggle = cb && cb.getChild('playToggle');
            if (!playToggle) {
                this.player_.tech(true).focus();
                return;
            }
            const playFocus = () => playToggle.focus();
            if (promise.isPromise(playPromise)) {
                playPromise.then(playFocus, () => {
                });
            } else {
                this.setTimeout(playFocus, 1);
            }
        }
        handleKeyDown(event) {
            this.mouseused_ = false;
            super.handleKeyDown(event);
        }
        handleMouseDown(event) {
            this.mouseused_ = true;
        }
    }
    BigPlayButton.prototype.controlText_ = 'Play Video';
    Component.registerComponent('BigPlayButton', BigPlayButton);
    return BigPlayButton;
});
define('skylark-videojs/close-button',[
    './button',
    './component',
    './utils/keycode'
], function (Button, Component, keycode) {
    'use strict';
    class CloseButton extends Button {
        constructor(player, options) {
            super(player, options);
            this.controlText(options && options.controlText || this.localize('Close'));
        }
        buildCSSClass() {
            return `vjs-close-button ${ super.buildCSSClass() }`;
        }
        handleClick(event) {
            this.trigger({
                type: 'close',
                bubbles: false
            });
        }
        handleKeyDown(event) {
            if (keycode.isEventKey(event, 'Esc')) {
                event.preventDefault();
                event.stopPropagation();
                this.trigger('click');
            } else {
                super.handleKeyDown(event);
            }
        }
    }
    Component.registerComponent('CloseButton', CloseButton);
    return CloseButton;
});
define('skylark-videojs/control-bar/play-toggle',[
    '../button',
    '../component'
], function (Button, Component) {
    'use strict';
    class PlayToggle extends Button {
        constructor(player, options = {}) {
            super(player, options);
            options.replay = options.replay === undefined || options.replay;
            this.listenTo(player, 'play', this.handlePlay);
            this.listenTo(player, 'pause', this.handlePause);
            if (options.replay) {
                this.listenTo(player, 'ended', this.handleEnded);
            }
        }
        buildCSSClass() {
            return `vjs-play-control ${ super.buildCSSClass() }`;
        }
        handleClick(event) {
            if (this.player_.paused()) {
                this.player_.play();
            } else {
                this.player_.pause();
            }
        }
        handleSeeked(event) {
            this.removeClass('vjs-ended');
            if (this.player_.paused()) {
                this.handlePause(event);
            } else {
                this.handlePlay(event);
            }
        }
        handlePlay(event) {
            this.removeClass('vjs-ended');
            this.removeClass('vjs-paused');
            this.addClass('vjs-playing');
            this.controlText('Pause');
        }
        handlePause(event) {
            this.removeClass('vjs-playing');
            this.addClass('vjs-paused');
            this.controlText('Play');
        }
        handleEnded(event) {
            this.removeClass('vjs-playing');
            this.addClass('vjs-ended');
            this.controlText('Replay');
            this.listenToOnce(this.player_, 'seeked', this.handleSeeked);
        }
    }
    PlayToggle.prototype.controlText_ = 'Play';
    Component.registerComponent('PlayToggle', PlayToggle);
    return PlayToggle;
});
define('skylark-videojs/utils/format-time',[],function () {
    'use strict';
    const defaultImplementation = function (seconds, guide) {
        seconds = seconds < 0 ? 0 : seconds;
        let s = Math.floor(seconds % 60);
        let m = Math.floor(seconds / 60 % 60);
        let h = Math.floor(seconds / 3600);
        const gm = Math.floor(guide / 60 % 60);
        const gh = Math.floor(guide / 3600);
        if (isNaN(seconds) || seconds === Infinity) {
            h = m = s = '-';
        }
        h = h > 0 || gh > 0 ? h + ':' : '';
        m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';
        s = s < 10 ? '0' + s : s;
        return h + m + s;
    };
    let implementation = defaultImplementation;
    function setFormatTime(customImplementation) {
        implementation = customImplementation;
    }
    function resetFormatTime() {
        implementation = defaultImplementation;
    }
    function formatTime(seconds, guide = seconds) {
        return implementation(seconds, guide);
    }

    formatTime.setFormatTime = setFormatTime;
    formatTime.resetFormatTime = resetFormatTime;

    return   formatTime;
});
define('skylark-videojs/control-bar/time-controls/time-display',[
    'skylark-langx-globals/document',
    '../../component',
    '../../utils/dom',
    '../../utils/format-time',
    '../../utils/log'
], function (document, Component, Dom, formatTime, log) {
    'use strict';
    class TimeDisplay extends Component {
        constructor(player, options) {
            super(player, options);
            this.listenTo(player, [
                'timeupdate',
                'ended'
            ], this.updateContent);
            this.updateTextNode_();
        }
        createEl() {
            const className = this.buildCSSClass();
            const el = super.createEl('div', {
                className: `${ className } vjs-time-control vjs-control`,
                innerHTML: `<span class="vjs-control-text" role="presentation">${ this.localize(this.labelText_) }\u00a0</span>`
            });
            this.contentEl_ = Dom.createEl('span', { className: `${ className }-display` }, {
                'aria-live': 'off',
                'role': 'presentation'
            });
            el.appendChild(this.contentEl_);
            return el;
        }
        dispose() {
            this.contentEl_ = null;
            this.textNode_ = null;
            super.dispose();
        }
        updateTextNode_(time = 0) {
            time = formatTime(time);
            if (this.formattedTime_ === time) {
                return;
            }
            this.formattedTime_ = time;
            this.requestNamedAnimationFrame('TimeDisplay#updateTextNode_', () => {
                if (!this.contentEl_) {
                    return;
                }
                let oldNode = this.textNode_;
                if (oldNode && this.contentEl_.firstChild !== oldNode) {
                    oldNode = null;
                    log.warn('TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.');
                }
                this.textNode_ = document.createTextNode(this.formattedTime_);
                if (!this.textNode_) {
                    return;
                }
                if (oldNode) {
                    this.contentEl_.replaceChild(this.textNode_, oldNode);
                } else {
                    this.contentEl_.appendChild(this.textNode_);
                }
            });
        }
        updateContent(event) {
        }
    }
    TimeDisplay.prototype.labelText_ = 'Time';
    TimeDisplay.prototype.controlText_ = 'Time';
    Component.registerComponent('TimeDisplay', TimeDisplay);
    return TimeDisplay;
});
define('skylark-videojs/control-bar/time-controls/current-time-display',[
    './time-display',
    '../../component'
], function (TimeDisplay, Component) {
    'use strict';
    class CurrentTimeDisplay extends TimeDisplay {
        buildCSSClass() {
            return 'vjs-current-time';
        }
        updateContent(event) {
            let time;
            if (this.player_.ended()) {
                time = this.player_.duration();
            } else {
                time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
            }
            this.updateTextNode_(time);
        }
    }
    CurrentTimeDisplay.prototype.labelText_ = 'Current Time';
    CurrentTimeDisplay.prototype.controlText_ = 'Current Time';
    Component.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);
    return CurrentTimeDisplay;
});
define('skylark-videojs/control-bar/time-controls/duration-display',[
    './time-display',
    '../../component'
], function (TimeDisplay, Component) {
    'use strict';
    class DurationDisplay extends TimeDisplay {
        constructor(player, options) {
            super(player, options);
            this.listenTo(player, 'durationchange', this.updateContent);
            this.listenTo(player, 'loadstart', this.updateContent);
            this.listenTo(player, 'loadedmetadata', this.updateContent);
        }
        buildCSSClass() {
            return 'vjs-duration';
        }
        updateContent(event) {
            const duration = this.player_.duration();
            this.updateTextNode_(duration);
        }
    }
    DurationDisplay.prototype.labelText_ = 'Duration';
    DurationDisplay.prototype.controlText_ = 'Duration';
    Component.registerComponent('DurationDisplay', DurationDisplay);
    return DurationDisplay;
});
define('skylark-videojs/control-bar/time-controls/time-divider',[
    '../../component'
], function (Component) {
    'use strict';
    class TimeDivider extends Component {
        createEl() {
            return super.createEl('div', {
                className: 'vjs-time-control vjs-time-divider',
                innerHTML: '<div><span>/</span></div>'
            }, { 'aria-hidden': true });
        }
    }
    Component.registerComponent('TimeDivider', TimeDivider);
    return TimeDivider;
});
define('skylark-videojs/control-bar/time-controls/remaining-time-display',[
    './time-display',
    '../../component',
    '../../utils/dom'
], function (TimeDisplay, Component, Dom) {
    'use strict';
    class RemainingTimeDisplay extends TimeDisplay {
        constructor(player, options) {
            super(player, options);
            this.listenTo(player, 'durationchange', this.updateContent);
        }
        buildCSSClass() {
            return 'vjs-remaining-time';
        }
        createEl() {
            const el = super.createEl();
            el.insertBefore(Dom.createEl('span', {}, { 'aria-hidden': true }, '-'), this.contentEl_);
            return el;
        }
        updateContent(event) {
            if (typeof this.player_.duration() !== 'number') {
                return;
            }
            let time;
            if (this.player_.ended()) {
                time = 0;
            } else if (this.player_.remainingTimeDisplay) {
                time = this.player_.remainingTimeDisplay();
            } else {
                time = this.player_.remainingTime();
            }
            this.updateTextNode_(time);
        }
    }
    RemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';
    RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';
    Component.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);
    return RemainingTimeDisplay;
});
define('skylark-videojs/control-bar/live-display',[
    '../component',
    '../utils/dom'
], function (Component, Dom) {
    'use strict';
    class LiveDisplay extends Component {
        constructor(player, options) {
            super(player, options);
            this.updateShowing();
            this.listenTo(this.player(), 'durationchange', this.updateShowing);
        }
        createEl() {
            const el = super.createEl('div', { className: 'vjs-live-control vjs-control' });
            this.contentEl_ = Dom.createEl('div', {
                className: 'vjs-live-display',
                innerHTML: `<span class="vjs-control-text">${ this.localize('Stream Type') }\u00a0</span>${ this.localize('LIVE') }`
            }, { 'aria-live': 'off' });
            el.appendChild(this.contentEl_);
            return el;
        }
        dispose() {
            this.contentEl_ = null;
            super.dispose();
        }
        updateShowing(event) {
            if (this.player().duration() === Infinity) {
                this.show();
            } else {
                this.hide();
            }
        }
    }
    Component.registerComponent('LiveDisplay', LiveDisplay);
    return LiveDisplay;
});
define('skylark-videojs/control-bar/seek-to-live',[
    '../button',
    '../component',
    '../utils/dom'
], function (Button, Component, Dom) {
    'use strict';
    class SeekToLive extends Button {
        constructor(player, options) {
            super(player, options);
            this.updateLiveEdgeStatus();
            if (this.player_.liveTracker) {
                this.listenTo(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatus);
            }
        }
        createEl() {
            const el = super.createEl('button', { className: 'vjs-seek-to-live-control vjs-control' });
            this.textEl_ = Dom.createEl('span', {
                className: 'vjs-seek-to-live-text',
                innerHTML: this.localize('LIVE')
            }, { 'aria-hidden': 'true' });
            el.appendChild(this.textEl_);
            return el;
        }
        updateLiveEdgeStatus() {
            if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
                this.setAttribute('aria-disabled', true);
                this.addClass('vjs-at-live-edge');
                this.controlText('Seek to live, currently playing live');
            } else {
                this.setAttribute('aria-disabled', false);
                this.removeClass('vjs-at-live-edge');
                this.controlText('Seek to live, currently behind live');
            }
        }
        handleClick() {
            this.player_.liveTracker.seekToLiveEdge();
        }
        dispose() {
            if (this.player_.liveTracker) {
                this.unlistenTo(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatus);
            }
            this.textEl_ = null;
            super.dispose();
        }
    }
    SeekToLive.prototype.controlText_ = 'Seek to live, currently playing live';
    Component.registerComponent('SeekToLive', SeekToLive);
    return SeekToLive;
});
define('skylark-videojs/utils/clamp',[],function () {
    'use strict';
    const clamp = function (number, min, max) {
        number = Number(number);
        return Math.min(max, Math.max(min, isNaN(number) ? min : number));
    };
    return clamp;
});
define('skylark-videojs/slider/slider',[
    '../component',
    '../utils/dom',
    '../utils/obj',
    '../utils/browser',
    '../utils/clamp',
    '../utils/keycode'
], function (Component, Dom, obj, browser, clamp, keycode) {
    'use strict';
    class Slider extends Component {
        constructor(player, options) {
            super(player, options);
            this.bar = this.getChild(this.options_.barName);
            this.vertical(!!this.options_.vertical);
            this.enable();
        }
        enabled() {
            return this.enabled_;
        }
        enable() {
            if (this.enabled()) {
                return;
            }
            this.listenTo('mousedown', this.handleMouseDown);
            this.listenTo('touchstart', this.handleMouseDown);
            this.listenTo('keydown', this.handleKeyDown);
            this.listenTo('click', this.handleClick);
            this.listenTo(this.player_, 'controlsvisible', this.update);
            if (this.playerEvent) {
                this.listenTo(this.player_, this.playerEvent, this.update);
            }
            this.removeClass('disabled');
            this.setAttribute('tabindex', 0);
            this.enabled_ = true;
        }
        disable() {
            if (!this.enabled()) {
                return;
            }
            const doc = this.bar.el_.ownerDocument;
            this.unlistenTo('mousedown', this.handleMouseDown);
            this.unlistenTo('touchstart', this.handleMouseDown);
            this.unlistenTo('keydown', this.handleKeyDown);
            this.unlistenTo('click', this.handleClick);
            this.unlistenTo(this.player_, 'controlsvisible', this.update);
            this.unlistenTo(doc, 'mousemove', this.handleMouseMove);
            this.unlistenTo(doc, 'mouseup', this.handleMouseUp);
            this.unlistenTo(doc, 'touchmove', this.handleMouseMove);
            this.unlistenTo(doc, 'touchend', this.handleMouseUp);
            this.removeAttribute('tabindex');
            this.addClass('disabled');
            if (this.playerEvent) {
                this.unlistenTo(this.player_, this.playerEvent, this.update);
            }
            this.enabled_ = false;
        }
        createEl(type, props = {}, attributes = {}) {
            props.className = props.className + ' vjs-slider';
            props = obj.assign({ tabIndex: 0 }, props);
            attributes = obj.assign({
                'role': 'slider',
                'aria-valuenow': 0,
                'aria-valuemin': 0,
                'aria-valuemax': 100,
                'tabIndex': 0
            }, attributes);
            return super.createEl(type, props, attributes);
        }
        handleMouseDown(event) {
            const doc = this.bar.el_.ownerDocument;
            if (event.type === 'mousedown') {
                event.preventDefault();
            }
            if (event.type === 'touchstart' && !browser.IS_CHROME) {
                event.preventDefault();
            }
            Dom.blockTextSelection();
            this.addClass('vjs-sliding');
            this.trigger('slideractive');
            this.listenTo(doc, 'mousemove', this.handleMouseMove);
            this.listenTo(doc, 'mouseup', this.handleMouseUp);
            this.listenTo(doc, 'touchmove', this.handleMouseMove);
            this.listenTo(doc, 'touchend', this.handleMouseUp);
            this.handleMouseMove(event);
        }
        handleMouseMove(event) {
        }
        handleMouseUp() {
            const doc = this.bar.el_.ownerDocument;
            Dom.unblockTextSelection();
            this.removeClass('vjs-sliding');
            this.trigger('sliderinactive');
            this.unlistenTo(doc, 'mousemove', this.handleMouseMove);
            this.unlistenTo(doc, 'mouseup', this.handleMouseUp);
            this.unlistenTo(doc, 'touchmove', this.handleMouseMove);
            this.unlistenTo(doc, 'touchend', this.handleMouseUp);
            this.update();
        }
        update() {
            if (!this.el_ || !this.bar) {
                return;
            }
            const progress = this.getProgress();
            if (progress === this.progress_) {
                return progress;
            }
            this.progress_ = progress;
            this.requestNamedAnimationFrame('Slider#update', () => {
                const sizeKey = this.vertical() ? 'height' : 'width';
                this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + '%';
            });
            return progress;
        }
        getProgress() {
            return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
        }
        calculateDistance(event) {
            const position = Dom.getPointerPosition(this.el_, event);
            if (this.vertical()) {
                return position.y;
            }
            return position.x;
        }
        handleKeyDown(event) {
            if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {
                event.preventDefault();
                event.stopPropagation();
                this.stepBack();
            } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {
                event.preventDefault();
                event.stopPropagation();
                this.stepForward();
            } else {
                super.handleKeyDown(event);
            }
        }
        handleClick(event) {
            event.stopPropagation();
            event.preventDefault();
        }
        vertical(bool) {
            if (bool === undefined) {
                return this.vertical_ || false;
            }
            this.vertical_ = !!bool;
            if (this.vertical_) {
                this.addClass('vjs-slider-vertical');
            } else {
                this.addClass('vjs-slider-horizontal');
            }
        }
    }
    Component.registerComponent('Slider', Slider);
    return Slider;
});
define('skylark-videojs/control-bar/progress-control/load-progress-bar',[
    'skylark-langx-globals/document',
    '../../component',
    '../../utils/dom',
    '../../utils/clamp'
], function (document,Component, Dom, clamp) {
    'use strict';
    const percentify = (time, end) => clamp(time / end * 100, 0, 100).toFixed(2) + '%';
    class LoadProgressBar extends Component {
        constructor(player, options) {
            super(player, options);
            this.partEls_ = [];
            this.listenTo(player, 'progress', this.update);
        }
        createEl() {
            const el = super.createEl('div', { className: 'vjs-load-progress' });
            const wrapper = Dom.createEl('span', { className: 'vjs-control-text' });
            const loadedText = Dom.createEl('span', { textContent: this.localize('Loaded') });
            const separator = document.createTextNode(': ');
            this.percentageEl_ = Dom.createEl('span', {
                className: 'vjs-control-text-loaded-percentage',
                textContent: '0%'
            });
            el.appendChild(wrapper);
            wrapper.appendChild(loadedText);
            wrapper.appendChild(separator);
            wrapper.appendChild(this.percentageEl_);
            return el;
        }
        dispose() {
            this.partEls_ = null;
            this.percentageEl_ = null;
            super.dispose();
        }
        update(event) {
            this.requestNamedAnimationFrame('LoadProgressBar#update', () => {
                const liveTracker = this.player_.liveTracker;
                const buffered = this.player_.buffered();
                const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
                const bufferedEnd = this.player_.bufferedEnd();
                const children = this.partEls_;
                const percent = percentify(bufferedEnd, duration);
                if (this.percent_ !== percent) {
                    this.el_.style.width = percent;
                    Dom.textContent(this.percentageEl_, percent);
                    this.percent_ = percent;
                }
                for (let i = 0; i < buffered.length; i++) {
                    const start = buffered.start(i);
                    const end = buffered.end(i);
                    let part = children[i];
                    if (!part) {
                        part = this.el_.appendChild(Dom.createEl());
                        children[i] = part;
                    }
                    if (part.dataset.start === start && part.dataset.end === end) {
                        continue;
                    }
                    part.dataset.start = start;
                    part.dataset.end = end;
                    part.style.left = percentify(start, bufferedEnd);
                    part.style.width = percentify(end - start, bufferedEnd);
                }
                for (let i = children.length; i > buffered.length; i--) {
                    this.el_.removeChild(children[i - 1]);
                }
                children.length = buffered.length;
            });
        }
    }
    Component.registerComponent('LoadProgressBar', LoadProgressBar);
    return LoadProgressBar;
});
define('skylark-videojs/control-bar/progress-control/time-tooltip',[
    '../../component',
    '../../utils/dom',
    '../../utils/format-time',
    '../../utils/fn'
], function (Component, Dom, formatTime, Fn) {
    'use strict';
    class TimeTooltip extends Component {
        constructor(player, options) {
            super(player, options);
            this.update = Fn.throttle(Fn.bind(this, this.update), Fn.UPDATE_REFRESH_INTERVAL);
        }
        createEl() {
            return super.createEl('div', { className: 'vjs-time-tooltip' }, { 'aria-hidden': 'true' });
        }
        update(seekBarRect, seekBarPoint, content) {
            const tooltipRect = Dom.findPosition(this.el_);
            const playerRect = Dom.getBoundingClientRect(this.player_.el());
            const seekBarPointPx = seekBarRect.width * seekBarPoint;
            if (!playerRect || !tooltipRect) {
                return;
            }
            const spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
            const spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
            let pullTooltipBy = tooltipRect.width / 2;
            if (spaceLeftOfPoint < pullTooltipBy) {
                pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
            } else if (spaceRightOfPoint < pullTooltipBy) {
                pullTooltipBy = spaceRightOfPoint;
            }
            if (pullTooltipBy < 0) {
                pullTooltipBy = 0;
            } else if (pullTooltipBy > tooltipRect.width) {
                pullTooltipBy = tooltipRect.width;
            }
            pullTooltipBy = Math.round(pullTooltipBy);
            this.el_.style.right = `-${ pullTooltipBy }px`;
            this.write(content);
        }
        write(content) {
            Dom.textContent(this.el_, content);
        }
        updateTime(seekBarRect, seekBarPoint, time, cb) {
            this.requestNamedAnimationFrame('TimeTooltip#updateTime', () => {
                let content;
                const duration = this.player_.duration();
                if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
                    const liveWindow = this.player_.liveTracker.liveWindow();
                    const secondsBehind = liveWindow - seekBarPoint * liveWindow;
                    content = (secondsBehind < 1 ? '' : '-') + formatTime(secondsBehind, liveWindow);
                } else {
                    content = formatTime(time, duration);
                }
                this.update(seekBarRect, seekBarPoint, content);
                if (cb) {
                    cb();
                }
            });
        }
    }
    Component.registerComponent('TimeTooltip', TimeTooltip);
    return TimeTooltip;
});
define('skylark-videojs/control-bar/progress-control/play-progress-bar',[
    '../../component',
    '../../utils/browser',
    '../../utils/fn',
    './time-tooltip'
], function (Component, browser, Fn) {
    'use strict';
    class PlayProgressBar extends Component {
        constructor(player, options) {
            super(player, options);
            this.update = Fn.throttle(Fn.bind(this, this.update), Fn.UPDATE_REFRESH_INTERVAL);
        }
        createEl() {
            return super.createEl('div', { className: 'vjs-play-progress vjs-slider-bar' }, { 'aria-hidden': 'true' });
        }
        update(seekBarRect, seekBarPoint) {
            const timeTooltip = this.getChild('timeTooltip');
            if (!timeTooltip) {
                return;
            }
            const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
            timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
        }
    }
    PlayProgressBar.prototype.options_ = { children: [] };
    if (!browser.IS_IOS && !browser.IS_ANDROID) {
        PlayProgressBar.prototype.options_.children.push('timeTooltip');
    }
    Component.registerComponent('PlayProgressBar', PlayProgressBar);
    return PlayProgressBar;
});
define('skylark-videojs/control-bar/progress-control/mouse-time-display',[
    '../../component',
    '../../utils/fn',
    './time-tooltip'
], function (Component, Fn) {
    'use strict';
    class MouseTimeDisplay extends Component {
        constructor(player, options) {
            super(player, options);
            this.update = Fn.throttle(Fn.bind(this, this.update), Fn.UPDATE_REFRESH_INTERVAL);
        }
        createEl() {
            return super.createEl('div', { className: 'vjs-mouse-display' });
        }
        update(seekBarRect, seekBarPoint) {
            const time = seekBarPoint * this.player_.duration();
            this.getChild('timeTooltip').updateTime(seekBarRect, seekBarPoint, time, () => {
                this.el_.style.left = `${ seekBarRect.width * seekBarPoint }px`;
            });
        }
    }
    MouseTimeDisplay.prototype.options_ = { children: ['timeTooltip'] };
    Component.registerComponent('MouseTimeDisplay', MouseTimeDisplay);
    return MouseTimeDisplay;
});
define('skylark-videojs/control-bar/progress-control/seek-bar',[
    'skylark-langx-globals/document',
    '../../slider/slider',
    '../../component',
    '../../utils/browser',
    '../../utils/dom',
    '../../utils/fn',
    '../../utils/format-time',
    '../../utils/promise',
    '../../utils/keycode',
    './load-progress-bar',
    './play-progress-bar',
    './mouse-time-display'
], function (document,Slider, Component, browser, Dom, Fn, formatTime, promise, keycode) {
    'use strict';
    const STEP_SECONDS = 5;
    const PAGE_KEY_MULTIPLIER = 12;
    class SeekBar extends Slider {
        constructor(player, options) {
            super(player, options);
            this.setEventHandlers_();
        }
        setEventHandlers_() {
            this.update_ = Fn.bind(this, this.update);
            this.update = Fn.throttle(this.update_, Fn.UPDATE_REFRESH_INTERVAL);
            this.listenTo(this.player_, [
                'ended',
                'durationchange',
                'timeupdate'
            ], this.update);
            if (this.player_.liveTracker) {
                this.listenTo(this.player_.liveTracker, 'liveedgechange', this.update);
            }
            this.updateInterval = null;
            this.listenTo(this.player_, ['playing'], this.enableInterval_);
            this.listenTo(this.player_, [
                'ended',
                'pause',
                'waiting'
            ], this.disableInterval_);
            if ('hidden' in document && 'visibilityState' in document) {
                this.listenTo(document, 'visibilitychange', this.toggleVisibility_);
            }
        }
        toggleVisibility_(e) {
            if (document.hidden) {
                this.disableInterval_(e);
            } else {
                this.enableInterval_();
                this.update();
            }
        }
        enableInterval_() {
            if (this.updateInterval) {
                return;
            }
            this.updateInterval = this.setInterval(this.update, Fn.UPDATE_REFRESH_INTERVAL);
        }
        disableInterval_(e) {
            if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== 'ended') {
                return;
            }
            if (!this.updateInterval) {
                return;
            }
            this.clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
        createEl() {
            return super.createEl('div', { className: 'vjs-progress-holder' }, { 'aria-label': this.localize('Progress Bar') });
        }
        update(event) {
            const percent = super.update();
            this.requestNamedAnimationFrame('SeekBar#update', () => {
                const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();
                const liveTracker = this.player_.liveTracker;
                let duration = this.player_.duration();
                if (liveTracker && liveTracker.isLive()) {
                    duration = this.player_.liveTracker.liveCurrentTime();
                }
                if (this.percent_ !== percent) {
                    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));
                    this.percent_ = percent;
                }
                if (this.currentTime_ !== currentTime || this.duration_ !== duration) {
                    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [
                        formatTime(currentTime, duration),
                        formatTime(duration, duration)
                    ], '{1} of {2}'));
                    this.currentTime_ = currentTime;
                    this.duration_ = duration;
                }
                if (this.bar) {
                    this.bar.update(Dom.getBoundingClientRect(this.el()), this.getProgress());
                }
            });
            return percent;
        }
        getCurrentTime_() {
            return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
        }
        getPercent() {
            const currentTime = this.getCurrentTime_();
            let percent;
            const liveTracker = this.player_.liveTracker;
            if (liveTracker && liveTracker.isLive()) {
                percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
                if (liveTracker.atLiveEdge()) {
                    percent = 1;
                }
            } else {
                percent = currentTime / this.player_.duration();
            }
            return percent;
        }
        handleMouseDown(event) {
            if (!Dom.isSingleLeftClick(event)) {
                return;
            }
            event.stopPropagation();
            this.player_.scrubbing(true);
            this.videoWasPlaying = !this.player_.paused();
            this.player_.pause();
            super.handleMouseDown(event);
        }
        handleMouseMove(event) {
            if (!Dom.isSingleLeftClick(event)) {
                return;
            }
            let newTime;
            const distance = this.calculateDistance(event);
            const liveTracker = this.player_.liveTracker;
            if (!liveTracker || !liveTracker.isLive()) {
                newTime = distance * this.player_.duration();
                if (newTime === this.player_.duration()) {
                    newTime = newTime - 0.1;
                }
            } else {
                if (distance >= 0.99) {
                    liveTracker.seekToLiveEdge();
                    return;
                }
                const seekableStart = liveTracker.seekableStart();
                const seekableEnd = liveTracker.liveCurrentTime();
                newTime = seekableStart + distance * liveTracker.liveWindow();
                if (newTime >= seekableEnd) {
                    newTime = seekableEnd;
                }
                if (newTime <= seekableStart) {
                    newTime = seekableStart + 0.1;
                }
                if (newTime === Infinity) {
                    return;
                }
            }
            this.player_.currentTime(newTime);
        }
        enable() {
            super.enable();
            const mouseTimeDisplay = this.getChild('mouseTimeDisplay');
            if (!mouseTimeDisplay) {
                return;
            }
            mouseTimeDisplay.show();
        }
        disable() {
            super.disable();
            const mouseTimeDisplay = this.getChild('mouseTimeDisplay');
            if (!mouseTimeDisplay) {
                return;
            }
            mouseTimeDisplay.hide();
        }
        handleMouseUp(event) {
            super.handleMouseUp(event);
            if (event) {
                event.stopPropagation();
            }
            this.player_.scrubbing(false);
            this.player_.trigger({
                type: 'timeupdate',
                target: this,
                manuallyTriggered: true
            });
            if (this.videoWasPlaying) {
                promise.silencePromise(this.player_.play());
            } else {
                this.update_();
            }
        }
        stepForward() {
            this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);
        }
        stepBack() {
            this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);
        }
        handleAction(event) {
            if (this.player_.paused()) {
                this.player_.play();
            } else {
                this.player_.pause();
            }
        }
        handleKeyDown(event) {
            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {
                event.preventDefault();
                event.stopPropagation();
                this.handleAction(event);
            } else if (keycode.isEventKey(event, 'Home')) {
                event.preventDefault();
                event.stopPropagation();
                this.player_.currentTime(0);
            } else if (keycode.isEventKey(event, 'End')) {
                event.preventDefault();
                event.stopPropagation();
                this.player_.currentTime(this.player_.duration());
            } else if (/^[0-9]$/.test(keycode(event))) {
                event.preventDefault();
                event.stopPropagation();
                const gotoFraction = (keycode.codes[keycode(event)] - keycode.codes['0']) * 10 / 100;
                this.player_.currentTime(this.player_.duration() * gotoFraction);
            } else if (keycode.isEventKey(event, 'PgDn')) {
                event.preventDefault();
                event.stopPropagation();
                this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
            } else if (keycode.isEventKey(event, 'PgUp')) {
                event.preventDefault();
                event.stopPropagation();
                this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
            } else {
                super.handleKeyDown(event);
            }
        }
        dispose() {
            this.disableInterval_();
            thisunlistenTo(this.player_, [
                'ended',
                'durationchange',
                'timeupdate'
            ], this.update);
            if (this.player_.liveTracker) {
                this.listenTo(this.player_.liveTracker, 'liveedgechange', this.update);
            }
            this.unlistenTo(this.player_, ['playing'], this.enableInterval_);
            this.unlistenTo(this.player_, [
                'ended',
                'pause',
                'waiting'
            ], this.disableInterval_);
            if ('hidden' in document && 'visibilityState' in document) {
                this.unlistenTo(document, 'visibilitychange', this.toggleVisibility_);
            }
            super.dispose();
        }
    }
    SeekBar.prototype.options_ = {
        children: [
            'loadProgressBar',
            'playProgressBar'
        ],
        barName: 'playProgressBar'
    };
    if (!browser.IS_IOS && !browser.IS_ANDROID) {
        SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');
    }
    Component.registerComponent('SeekBar', SeekBar);
    return SeekBar;
});
define('skylark-videojs/control-bar/progress-control/progress-control',[
    '../../component',
    '../../utils/dom',
    '../../utils/clamp',
    '../../utils/fn',
    './seek-bar'
], function (Component, Dom, clamp, Fn) {
    'use strict';
    class ProgressControl extends Component {
        constructor(player, options) {
            super(player, options);
            this.handleMouseMove = Fn.throttle(Fn.bind(this, this.handleMouseMove), Fn.UPDATE_REFRESH_INTERVAL);
            this.throttledHandleMouseSeek = Fn.throttle(Fn.bind(this, this.handleMouseSeek), Fn.UPDATE_REFRESH_INTERVAL);
            this.enable();
        }
        createEl() {
            return super.createEl('div', { className: 'vjs-progress-control vjs-control' });
        }
        handleMouseMove(event) {
            const seekBar = this.getChild('seekBar');
            if (!seekBar) {
                return;
            }
            const playProgressBar = seekBar.getChild('playProgressBar');
            const mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');
            if (!playProgressBar && !mouseTimeDisplay) {
                return;
            }
            const seekBarEl = seekBar.el();
            const seekBarRect = Dom.findPosition(seekBarEl);
            let seekBarPoint = Dom.getPointerPosition(seekBarEl, event).x;
            seekBarPoint = clamp(seekBarPoint, 0, 1);
            if (mouseTimeDisplay) {
                mouseTimeDisplay.update(seekBarRect, seekBarPoint);
            }
            if (playProgressBar) {
                playProgressBar.update(seekBarRect, seekBar.getProgress());
            }
        }
        handleMouseSeek(event) {
            const seekBar = this.getChild('seekBar');
            if (seekBar) {
                seekBar.handleMouseMove(event);
            }
        }
        enabled() {
            return this.enabled_;
        }
        disable() {
            this.children().forEach(child => child.disable && child.disable());
            if (!this.enabled()) {
                return;
            }
            this.unlistenTo([
                'mousedown',
                'touchstart'
            ], this.handleMouseDown);
            this.unlistenTo(this.el_, 'mousemove', this.handleMouseMove);
            this.handleMouseUp();
            this.addClass('disabled');
            this.enabled_ = false;
        }
        enable() {
            this.children().forEach(child => child.enable && child.enable());
            if (this.enabled()) {
                return;
            }
            this.listenTo([
                'mousedown',
                'touchstart'
            ], this.handleMouseDown);
            this.listenTo(this.el_, 'mousemove', this.handleMouseMove);
            this.removeClass('disabled');
            this.enabled_ = true;
        }
        handleMouseDown(event) {
            const doc = this.el_.ownerDocument;
            const seekBar = this.getChild('seekBar');
            if (seekBar) {
                seekBar.handleMouseDown(event);
            }
            this.listenTo(doc, 'mousemove', this.throttledHandleMouseSeek);
            this.listenTo(doc, 'touchmove', this.throttledHandleMouseSeek);
            this.listenTo(doc, 'mouseup', this.handleMouseUp);
            this.listenTo(doc, 'touchend', this.handleMouseUp);
        }
        handleMouseUp(event) {
            const doc = this.el_.ownerDocument;
            const seekBar = this.getChild('seekBar');
            if (seekBar) {
                seekBar.handleMouseUp(event);
            }
            this.unlistenTo(doc, 'mousemove', this.throttledHandleMouseSeek);
            this.unlistenTo(doc, 'touchmove', this.throttledHandleMouseSeek);
            this.unlistenTo(doc, 'mouseup', this.handleMouseUp);
            this.unlistenTo(doc, 'touchend', this.handleMouseUp);
        }
    }
    ProgressControl.prototype.options_ = { children: ['seekBar'] };
    Component.registerComponent('ProgressControl', ProgressControl);
    return ProgressControl;
});
define('skylark-videojs/control-bar/picture-in-picture-toggle',[
    'skylark-langx-globals/document',
    '../button',
    '../component'
], function (document,Button, Component) {
    'use strict';
    class PictureInPictureToggle extends Button {
        constructor(player, options) {
            super(player, options);
            this.listenTo(player, [
                'enterpictureinpicture',
                'leavepictureinpicture'
            ], this.handlePictureInPictureChange);
            this.listenTo(player, [
                'disablepictureinpicturechanged',
                'loadedmetadata'
            ], this.handlePictureInPictureEnabledChange);
            this.disable();
        }
        buildCSSClass() {
            return `vjs-picture-in-picture-control ${ super.buildCSSClass() }`;
        }
        handlePictureInPictureEnabledChange() {
            if (document.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {
                this.enable();
            } else {
                this.disable();
            }
        }
        handlePictureInPictureChange(event) {
            if (this.player_.isInPictureInPicture()) {
                this.controlText('Exit Picture-in-Picture');
            } else {
                this.controlText('Picture-in-Picture');
            }
            this.handlePictureInPictureEnabledChange();
        }
        handleClick(event) {
            if (!this.player_.isInPictureInPicture()) {
                this.player_.requestPictureInPicture();
            } else {
                this.player_.exitPictureInPicture();
            }
        }
    }
    PictureInPictureToggle.prototype.controlText_ = 'Picture-in-Picture';
    Component.registerComponent('PictureInPictureToggle', PictureInPictureToggle);
    return PictureInPictureToggle;
});
define('skylark-videojs/control-bar/fullscreen-toggle',[
    'skylark-langx-globals/document',
    '../button',
    '../component',
], function (document,Button, Component) {
    'use strict';
    class FullscreenToggle extends Button {
        constructor(player, options) {
            super(player, options);
            this.listenTo(player, 'fullscreenchange', this.handleFullscreenChange);
            if (document[player.fsApi_.fullscreenEnabled] === false) {
                this.disable();
            }
        }
        buildCSSClass() {
            return `vjs-fullscreen-control ${ super.buildCSSClass() }`;
        }
        handleFullscreenChange(event) {
            if (this.player_.isFullscreen()) {
                this.controlText('Non-Fullscreen');
            } else {
                this.controlText('Fullscreen');
            }
        }
        handleClick(event) {
            if (!this.player_.isFullscreen()) {
                this.player_.requestFullscreen();
            } else {
                this.player_.exitFullscreen();
            }
        }
    }
    FullscreenToggle.prototype.controlText_ = 'Fullscreen';
    Component.registerComponent('FullscreenToggle', FullscreenToggle);
    return FullscreenToggle;
});
define('skylark-videojs/control-bar/volume-control/check-volume-support',[],function () {
    'use strict';
    const checkVolumeSupport = function (self, player) {
        if (player.tech_ && !player.tech_.featuresVolumeControl) {
            self.addClass('vjs-hidden');
        }
        self.listenTo(player, 'loadstart', function () {
            if (!player.tech_.featuresVolumeControl) {
                self.addClass('vjs-hidden');
            } else {
                self.removeClass('vjs-hidden');
            }
        });
    };
    return checkVolumeSupport;
});
define('skylark-videojs/control-bar/volume-control/volume-level',[
    '../../component'
], function (Component) {
    'use strict';
    class VolumeLevel extends Component {
        createEl() {
            return super.createEl('div', {
                className: 'vjs-volume-level',
                innerHTML: '<span class="vjs-control-text"></span>'
            });
        }
    }
    Component.registerComponent('VolumeLevel', VolumeLevel);
    return VolumeLevel;
});
define('skylark-videojs/control-bar/volume-control/volume-bar',[
    '../../slider/slider',
    '../../component',
    '../../utils/dom',
    './volume-level'
], function (Slider, Component, Dom) {
    'use strict';
    class VolumeBar extends Slider {
        constructor(player, options) {
            super(player, options);
            this.listenTo('slideractive', this.updateLastVolume_);
            this.listenTo(player, 'volumechange', this.updateARIAAttributes);
            player.ready(() => this.updateARIAAttributes());
        }
        createEl() {
            return super.createEl('div', { className: 'vjs-volume-bar vjs-slider-bar' }, {
                'aria-label': this.localize('Volume Level'),
                'aria-live': 'polite'
            });
        }
        handleMouseDown(event) {
            if (!Dom.isSingleLeftClick(event)) {
                return;
            }
            super.handleMouseDown(event);
        }
        handleMouseMove(event) {
            if (!Dom.isSingleLeftClick(event)) {
                return;
            }
            this.checkMuted();
            this.player_.volume(this.calculateDistance(event));
        }
        checkMuted() {
            if (this.player_.muted()) {
                this.player_.muted(false);
            }
        }
        getPercent() {
            if (this.player_.muted()) {
                return 0;
            }
            return this.player_.volume();
        }
        stepForward() {
            this.checkMuted();
            this.player_.volume(this.player_.volume() + 0.1);
        }
        stepBack() {
            this.checkMuted();
            this.player_.volume(this.player_.volume() - 0.1);
        }
        updateARIAAttributes(event) {
            const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
            this.el_.setAttribute('aria-valuenow', ariaValue);
            this.el_.setAttribute('aria-valuetext', ariaValue + '%');
        }
        volumeAsPercentage_() {
            return Math.round(this.player_.volume() * 100);
        }
        updateLastVolume_() {
            const volumeBeforeDrag = this.player_.volume();
            this.listenToOnce('sliderinactive', () => {
                if (this.player_.volume() === 0) {
                    this.player_.lastVolume_(volumeBeforeDrag);
                }
            });
        }
    }
    VolumeBar.prototype.options_ = {
        children: ['volumeLevel'],
        barName: 'volumeLevel'
    };
    VolumeBar.prototype.playerEvent = 'volumechange';
    Component.registerComponent('VolumeBar', VolumeBar);
    return VolumeBar;
});
define('skylark-videojs/control-bar/volume-control/volume-control',[
    '../../component',
    './check-volume-support',
    '../../utils/obj',
    '../../utils/fn',
    './volume-bar'
], function (Component, checkVolumeSupport, obj, Fn) {
    'use strict';
    class VolumeControl extends Component {
        constructor(player, options = {}) {
            options.vertical = options.vertical || false;
            if (typeof options.volumeBar === 'undefined' || obj.isPlain(options.volumeBar)) {
                options.volumeBar = options.volumeBar || {};
                options.volumeBar.vertical = options.vertical;
            }
            super(player, options);
            checkVolumeSupport(this, player);
            this.throttledHandleMouseMove = Fn.throttle(Fn.bind(this, this.handleMouseMove), Fn.UPDATE_REFRESH_INTERVAL);
            this.listenTo('mousedown', this.handleMouseDown);
            this.listenTo('touchstart', this.handleMouseDown);
            this.listenTo(this.volumeBar, [
                'focus',
                'slideractive'
            ], () => {
                this.volumeBar.addClass('vjs-slider-active');
                this.addClass('vjs-slider-active');
                this.trigger('slideractive');
            });
            this.listenTo(this.volumeBar, [
                'blur',
                'sliderinactive'
            ], () => {
                this.volumeBar.removeClass('vjs-slider-active');
                this.removeClass('vjs-slider-active');
                this.trigger('sliderinactive');
            });
        }
        createEl() {
            let orientationClass = 'vjs-volume-horizontal';
            if (this.options_.vertical) {
                orientationClass = 'vjs-volume-vertical';
            }
            return super.createEl('div', { className: `vjs-volume-control vjs-control ${ orientationClass }` });
        }
        handleMouseDown(event) {
            const doc = this.el_.ownerDocument;
            this.listenTo(doc, 'mousemove', this.throttledHandleMouseMove);
            this.listenTo(doc, 'touchmove', this.throttledHandleMouseMove);
            this.listenTo(doc, 'mouseup', this.handleMouseUp);
            this.listenTo(doc, 'touchend', this.handleMouseUp);
        }
        handleMouseUp(event) {
            const doc = this.el_.ownerDocument;
            this.unlistenTo(doc, 'mousemove', this.throttledHandleMouseMove);
            this.unlistenTo(doc, 'touchmove', this.throttledHandleMouseMove);
            this.unlistenTo(doc, 'mouseup', this.handleMouseUp);
            this.unlistenTo(doc, 'touchend', this.handleMouseUp);
        }
        handleMouseMove(event) {
            this.volumeBar.handleMouseMove(event);
        }
    }
    VolumeControl.prototype.options_ = { children: ['volumeBar'] };
    Component.registerComponent('VolumeControl', VolumeControl);
    return VolumeControl;
});
define('skylark-videojs/control-bar/volume-control/check-mute-support',[],function () {
    'use strict';
    const checkMuteSupport = function (self, player) {
        if (player.tech_ && !player.tech_.featuresMuteControl) {
            self.addClass('vjs-hidden');
        }
        self.listenTo(player, 'loadstart', function () {
            if (!player.tech_.featuresMuteControl) {
                self.addClass('vjs-hidden');
            } else {
                self.removeClass('vjs-hidden');
            }
        });
    };
    return checkMuteSupport;
});
define('skylark-videojs/control-bar/mute-toggle',[
    '../button',
    '../component',
    '../utils/dom',
    './volume-control/check-mute-support',
    '../utils/browser'
], function (Button, Component, Dom, checkMuteSupport, browser) {
    'use strict';
    class MuteToggle extends Button {
        constructor(player, options) {
            super(player, options);
            checkMuteSupport(this, player);
            this.listenTo(player, [
                'loadstart',
                'volumechange'
            ], this.update);
        }
        buildCSSClass() {
            return `vjs-mute-control ${ super.buildCSSClass() }`;
        }
        handleClick(event) {
            const vol = this.player_.volume();
            const lastVolume = this.player_.lastVolume_();
            if (vol === 0) {
                const volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
                this.player_.volume(volumeToSet);
                this.player_.muted(false);
            } else {
                this.player_.muted(this.player_.muted() ? false : true);
            }
        }
        update(event) {
            this.updateIcon_();
            this.updateControlText_();
        }
        updateIcon_() {
            const vol = this.player_.volume();
            let level = 3;
            if (browser.IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
                this.player_.muted(this.player_.tech_.el_.muted);
            }
            if (vol === 0 || this.player_.muted()) {
                level = 0;
            } else if (vol < 0.33) {
                level = 1;
            } else if (vol < 0.67) {
                level = 2;
            }
            for (let i = 0; i < 4; i++) {
                Dom.removeClass(this.el_, `vjs-vol-${ i }`);
            }
            Dom.addClass(this.el_, `vjs-vol-${ level }`);
        }
        updateControlText_() {
            const soundOff = this.player_.muted() || this.player_.volume() === 0;
            const text = soundOff ? 'Unmute' : 'Mute';
            if (this.controlText() !== text) {
                this.controlText(text);
            }
        }
    }
    MuteToggle.prototype.controlText_ = 'Mute';
    Component.registerComponent('MuteToggle', MuteToggle);
    return MuteToggle;
});
define('skylark-videojs/control-bar/volume-panel',[
    'skylark-langx-globals/document',
    '../component',
    '../utils/obj',
    '../utils/events',
    '../utils/fn',
    '../utils/keycode',
    './volume-control/volume-control',
    './mute-toggle'
], function (document, Component, obj, Events, Fn, keycode) {
    'use strict';
    class VolumePanel extends Component {
        constructor(player, options = {}) {
            if (typeof options.inline !== 'undefined') {
                options.inline = options.inline;
            } else {
                options.inline = true;
            }
            if (typeof options.volumeControl === 'undefined' || obj.isPlain(options.volumeControl)) {
                options.volumeControl = options.volumeControl || {};
                options.volumeControl.vertical = !options.inline;
            }
            super(player, options);
            this.listenTo(player, ['loadstart'], this.volumePanelState_);
            this.listenTo(this.muteToggle, 'keyup', this.handleKeyPress);
            this.listenTo(this.volumeControl, 'keyup', this.handleVolumeControlKeyUp);
            this.listenTo('keydown', this.handleKeyPress);
            this.listenTo('mouseover', this.handleMouseOver);
            this.listenTo('mouseout', this.handleMouseOut);
            this.listenTo(this.volumeControl, ['slideractive'], this.sliderActive_);
            this.listenTo(this.volumeControl, ['sliderinactive'], this.sliderInactive_);
        }
        sliderActive_() {
            this.addClass('vjs-slider-active');
        }
        sliderInactive_() {
            this.removeClass('vjs-slider-active');
        }
        volumePanelState_() {
            if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {
                this.addClass('vjs-hidden');
            }
            if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {
                this.addClass('vjs-mute-toggle-only');
            }
        }
        createEl() {
            let orientationClass = 'vjs-volume-panel-horizontal';
            if (!this.options_.inline) {
                orientationClass = 'vjs-volume-panel-vertical';
            }
            return super.createEl('div', { className: `vjs-volume-panel vjs-control ${ orientationClass }` });
        }
        dispose() {
            this.handleMouseOut();
            super.dispose();
        }
        handleVolumeControlKeyUp(event) {
            if (keycode.isEventKey(event, 'Esc')) {
                this.muteToggle.focus();
            }
        }
        handleMouseOver(event) {
            this.addClass('vjs-hover');
            Events.on(document, 'keyup', Fn.bind(this, this.handleKeyPress));
        }
        handleMouseOut(event) {
            this.removeClass('vjs-hover');
            Events.off(document, 'keyup', Fn.bind(this, this.handleKeyPress));
        }
        handleKeyPress(event) {
            if (keycode.isEventKey(event, 'Esc')) {
                this.handleMouseOut();
            }
        }
    }
    VolumePanel.prototype.options_ = {
        children: [
            'muteToggle',
            'volumeControl'
        ]
    };
    Component.registerComponent('VolumePanel', VolumePanel);
    return VolumePanel;
});
define('skylark-videojs/menu/menu',[
    'skylark-langx-globals/document',
    '../component',
    '../utils/dom',
    '../utils/fn',
    '../utils/events',
    '../utils/keycode'
], function (document,Component, Dom, Fn, Events, keycode) {
    'use strict';
    class Menu extends Component {
        constructor(player, options) {
            super(player, options);
            if (options) {
                this.menuButton_ = options.menuButton;
            }
            this.focusedChild_ = -1;
            this.listenTo('keydown', this.handleKeyDown);
            this.boundHandleBlur_ = Fn.bind(this, this.handleBlur);
            this.boundHandleTapClick_ = Fn.bind(this, this.handleTapClick);
        }
        addEventListenerForItem(component) {
            if (!(component instanceof Component)) {
                return;
            }
            this.listenTo(component, 'blur', this.boundHandleBlur_);
            this.listenTo(component, [
                'tap',
                'click'
            ], this.boundHandleTapClick_);
        }
        removeEventListenerForItem(component) {
            if (!(component instanceof Component)) {
                return;
            }
            this.unlistenTo(component, 'blur', this.boundHandleBlur_);
            this.unlistenTo(component, [
                'tap',
                'click'
            ], this.boundHandleTapClick_);
        }
        removeChild(component) {
            if (typeof component === 'string') {
                component = this.getChild(component);
            }
            this.removeEventListenerForItem(component);
            super.removeChild(component);
        }
        addItem(component) {
            const childComponent = this.addChild(component);
            if (childComponent) {
                this.addEventListenerForItem(childComponent);
            }
        }
        createEl() {
            const contentElType = this.options_.contentElType || 'ul';
            this.contentEl_ = Dom.createEl(contentElType, { className: 'vjs-menu-content' });
            this.contentEl_.setAttribute('role', 'menu');
            const el = super.createEl('div', {
                append: this.contentEl_,
                className: 'vjs-menu'
            });
            el.appendChild(this.contentEl_);
            Events.on(el, 'click', function (event) {
                event.preventDefault();
                event.stopImmediatePropagation();
            });
            return el;
        }
        dispose() {
            this.contentEl_ = null;
            this.boundHandleBlur_ = null;
            this.boundHandleTapClick_ = null;
            super.dispose();
        }
        handleBlur(event) {
            const relatedTarget = event.relatedTarget || document.activeElement;
            if (!this.children().some(element => {
                    return element.el() === relatedTarget;
                })) {
                const btn = this.menuButton_;
                if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
                    btn.unpressButton();
                }
            }
        }
        handleTapClick(event) {
            if (this.menuButton_) {
                this.menuButton_.unpressButton();
                const childComponents = this.children();
                if (!Array.isArray(childComponents)) {
                    return;
                }
                const foundComponent = childComponents.filter(component => component.el() === event.target)[0];
                if (!foundComponent) {
                    return;
                }
                if (foundComponent.name() !== 'CaptionSettingsMenuItem') {
                    this.menuButton_.focus();
                }
            }
        }
        handleKeyDown(event) {
            if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {
                event.preventDefault();
                event.stopPropagation();
                this.stepForward();
            } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {
                event.preventDefault();
                event.stopPropagation();
                this.stepBack();
            }
        }
        stepForward() {
            let stepChild = 0;
            if (this.focusedChild_ !== undefined) {
                stepChild = this.focusedChild_ + 1;
            }
            this.focus(stepChild);
        }
        stepBack() {
            let stepChild = 0;
            if (this.focusedChild_ !== undefined) {
                stepChild = this.focusedChild_ - 1;
            }
            this.focus(stepChild);
        }
        focus(item = 0) {
            const children = this.children().slice();
            const haveTitle = children.length && children[0].hasClass('vjs-menu-title');
            if (haveTitle) {
                children.shift();
            }
            if (children.length > 0) {
                if (item < 0) {
                    item = 0;
                } else if (item >= children.length) {
                    item = children.length - 1;
                }
                this.focusedChild_ = item;
                children[item].el_.focus();
            }
        }
    }
    Component.registerComponent('Menu', Menu);
    return Menu;
});
define('skylark-videojs/menu/menu-button',[
    '../button',
    '../component',
    './menu',
    '../utils/dom',
    '../utils/fn',
    '../utils/events',
    '../utils/string-cases',
    '../utils/browser',
    '../utils/keycode'
], function (Button, Component, Menu, Dom, Fn, Events, stringCases, browser, keycode) {
    'use strict';
    class MenuButton extends Component {
        constructor(player, options = {}) {
            super(player, options);
            this.menuButton_ = new Button(player, options);
            this.menuButton_.controlText(this.controlText_);
            this.menuButton_.el_.setAttribute('aria-haspopup', 'true');
            const buttonClass = Button.prototype.buildCSSClass();
            this.menuButton_.el_.className = this.buildCSSClass() + ' ' + buttonClass;
            this.menuButton_.removeClass('vjs-control');
            this.addChild(this.menuButton_);
            this.update();
            this.enabled_ = true;
            this.listenTo(this.menuButton_, 'tap', this.handleClick);
            this.listenTo(this.menuButton_, 'click', this.handleClick);
            this.listenTo(this.menuButton_, 'keydown', this.handleKeyDown);
            this.listenTo(this.menuButton_, 'mouseenter', () => {
                this.addClass('vjs-hover');
                this.menu.show();
                Events.on(document, 'keyup', Fn.bind(this, this.handleMenuKeyUp));
            });
            this.listenTo('mouseleave', this.handleMouseLeave);
            this.listenTo('keydown', this.handleSubmenuKeyDown);
        }
        update() {
            const menu = this.createMenu();
            if (this.menu) {
                this.menu.dispose();
                this.removeChild(this.menu);
            }
            this.menu = menu;
            this.addChild(menu);
            this.buttonPressed_ = false;
            this.menuButton_.el_.setAttribute('aria-expanded', 'false');
            if (this.items && this.items.length <= this.hideThreshold_) {
                this.hide();
            } else {
                this.show();
            }
        }
        createMenu() {
            const menu = new Menu(this.player_, { menuButton: this });
            this.hideThreshold_ = 0;
            if (this.options_.title) {
                const titleEl = Dom.createEl('li', {
                    className: 'vjs-menu-title',
                    innerHTML: stringCases.toTitleCase(this.options_.title),
                    tabIndex: -1
                });
                this.hideThreshold_ += 1;
                const titleComponent = new Component(this.player_, { el: titleEl });
                menu.addItem(titleComponent);
            }
            this.items = this.createItems();
            if (this.items) {
                for (let i = 0; i < this.items.length; i++) {
                    menu.addItem(this.items[i]);
                }
            }
            return menu;
        }
        createItems() {
        }
        createEl() {
            return super.createEl('div', { className: this.buildWrapperCSSClass() }, {});
        }
        buildWrapperCSSClass() {
            let menuButtonClass = 'vjs-menu-button';
            if (this.options_.inline === true) {
                menuButtonClass += '-inline';
            } else {
                menuButtonClass += '-popup';
            }
            const buttonClass = Button.prototype.buildCSSClass();
            return `vjs-menu-button ${ menuButtonClass } ${ buttonClass } ${ super.buildCSSClass() }`;
        }
        buildCSSClass() {
            let menuButtonClass = 'vjs-menu-button';
            if (this.options_.inline === true) {
                menuButtonClass += '-inline';
            } else {
                menuButtonClass += '-popup';
            }
            return `vjs-menu-button ${ menuButtonClass } ${ super.buildCSSClass() }`;
        }
        controlText(text, el = this.menuButton_.el()) {
            return this.menuButton_.controlText(text, el);
        }
        dispose() {
            this.handleMouseLeave();
            super.dispose();
        }
        handleClick(event) {
            if (this.buttonPressed_) {
                this.unpressButton();
            } else {
                this.pressButton();
            }
        }
        handleMouseLeave(event) {
            this.removeClass('vjs-hover');
            Events.off(document, 'keyup', Fn.bind(this, this.handleMenuKeyUp));
        }
        focus() {
            this.menuButton_.focus();
        }
        blur() {
            this.menuButton_.blur();
        }
        handleKeyDown(event) {
            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {
                if (this.buttonPressed_) {
                    this.unpressButton();
                }
                if (!keycode.isEventKey(event, 'Tab')) {
                    event.preventDefault();
                    this.menuButton_.focus();
                }
            } else if (keycode.isEventKey(event, 'Up') || keycode.isEventKey(event, 'Down')) {
                if (!this.buttonPressed_) {
                    event.preventDefault();
                    this.pressButton();
                }
            }
        }
        handleMenuKeyUp(event) {
            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {
                this.removeClass('vjs-hover');
            }
        }
        handleSubmenuKeyPress(event) {
            this.handleSubmenuKeyDown(event);
        }
        handleSubmenuKeyDown(event) {
            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {
                if (this.buttonPressed_) {
                    this.unpressButton();
                }
                if (!keycode.isEventKey(event, 'Tab')) {
                    event.preventDefault();
                    this.menuButton_.focus();
                }
            } else {
            }
        }
        pressButton() {
            if (this.enabled_) {
                this.buttonPressed_ = true;
                this.menu.show();
                this.menu.lockShowing();
                this.menuButton_.el_.setAttribute('aria-expanded', 'true');
                if (browser.IS_IOS && Dom.isInFrame()) {
                    return;
                }
                this.menu.focus();
            }
        }
        unpressButton() {
            if (this.enabled_) {
                this.buttonPressed_ = false;
                this.menu.unlockShowing();
                this.menu.hide();
                this.menuButton_.el_.setAttribute('aria-expanded', 'false');
            }
        }
        disable() {
            this.unpressButton();
            this.enabled_ = false;
            this.addClass('vjs-disabled');
            this.menuButton_.disable();
        }
        enable() {
            this.enabled_ = true;
            this.removeClass('vjs-disabled');
            this.menuButton_.enable();
        }
    }
    Component.registerComponent('MenuButton', MenuButton);
    return MenuButton;
});
define('skylark-videojs/control-bar/track-button',[
    '../menu/menu-button',
    '../component',
    '../utils/fn'
], function (MenuButton, Component, Fn) {
    'use strict';
    class TrackButton extends MenuButton {
        constructor(player, options) {
            const tracks = options.tracks;
            super(player, options);
            if (this.items.length <= 1) {
                this.hide();
            }
            if (!tracks) {
                return;
            }
            const updateHandler = Fn.bind(this, this.update);
            tracks.addEventListener('removetrack', updateHandler);
            tracks.addEventListener('addtrack', updateHandler);
            tracks.addEventListener('labelchange', updateHandler);
            this.player_.on('ready', updateHandler);
            this.player_.on('dispose', function () {
                tracks.removeEventListener('removetrack', updateHandler);
                tracks.removeEventListener('addtrack', updateHandler);
                tracks.removeEventListener('labelchange', updateHandler);
            });
        }
    }
    Component.registerComponent('TrackButton', TrackButton);
    return TrackButton;
});
define('skylark-videojs/menu/menu-keys',[],function () {
    'use strict';
    const MenuKeys = [
        'Tab',
        'Esc',
        'Up',
        'Down',
        'Right',
        'Left'
    ];
    return MenuKeys;
});
define('skylark-videojs/menu/menu-item',[
    '../clickable-component',
    '../component',
    '../utils/obj',
    './menu-keys',
    '../utils/keycode'
], function (ClickableComponent, Component, obj, MenuKeys, keycode) {
    'use strict';
    class MenuItem extends ClickableComponent {
        constructor(player, options) {
            super(player, options);
            this.selectable = options.selectable;
            this.isSelected_ = options.selected || false;
            this.multiSelectable = options.multiSelectable;
            this.selected(this.isSelected_);
            if (this.selectable) {
                if (this.multiSelectable) {
                    this.el_.setAttribute('role', 'menuitemcheckbox');
                } else {
                    this.el_.setAttribute('role', 'menuitemradio');
                }
            } else {
                this.el_.setAttribute('role', 'menuitem');
            }
        }
        createEl(type, props, attrs) {
            this.nonIconControl = true;
            return super.createEl('li', obj.assign({
                className: 'vjs-menu-item',
                innerHTML: `<span class="vjs-menu-item-text">${ this.localize(this.options_.label) }</span>`,
                tabIndex: -1
            }, props), attrs);
        }
        handleKeyDown(event) {
            if (!MenuKeys.some(key => keycode.isEventKey(event, key))) {
                super.handleKeyDown(event);
            }
        }
        handleClick(event) {
            this.selected(true);
        }
        selected(selected) {
            if (this.selectable) {
                if (selected) {
                    this.addClass('vjs-selected');
                    this.el_.setAttribute('aria-checked', 'true');
                    this.controlText(', selected');
                    this.isSelected_ = true;
                } else {
                    this.removeClass('vjs-selected');
                    this.el_.setAttribute('aria-checked', 'false');
                    this.controlText('');
                    this.isSelected_ = false;
                }
            }
        }
    }
    Component.registerComponent('MenuItem', MenuItem);
    return MenuItem;
});
define('skylark-videojs/control-bar/text-track-controls/text-track-menu-item',[
    'skylark-langx-globals/document',
    '../../menu/menu-item',
    '../../component'
], function (document,MenuItem, Component) {
    'use strict';
    class TextTrackMenuItem extends MenuItem {
        constructor(player, options) {
            const track = options.track;
            const tracks = player.textTracks();
            options.label = track.label || track.language || 'Unknown';
            options.selected = track.mode === 'showing';
            super(player, options);
            this.track = track;
            this.kinds = (options.kinds || [options.kind || this.track.kind]).filter(Boolean);
            const changeHandler = (...args) => {
                this.handleTracksChange.apply(this, args);
            };
            const selectedLanguageChangeHandler = (...args) => {
                this.handleSelectedLanguageChange.apply(this, args);
            };
            player.on([
                'loadstart',
                'texttrackchange'
            ], changeHandler);
            tracks.addEventListener('change', changeHandler);
            tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
            this.listenTo('dispose', function () {
                player.off([
                    'loadstart',
                    'texttrackchange'
                ], changeHandler);
                tracks.removeEventListener('change', changeHandler);
                tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
            });
            if (tracks.onchange === undefined) {
                let event;
                this.listenTo([
                    'tap',
                    'click'
                ], function () {
                    if (typeof window.Event !== 'object') {
                        try {
                            event = new window.Event('change');
                        } catch (err) {
                        }
                    }
                    if (!event) {
                        event = document.createEvent('Event');
                        event.initEvent('change', true, true);
                    }
                    tracks.dispatchEvent(event);
                });
            }
            this.handleTracksChange();
        }
        handleClick(event) {
            const referenceTrack = this.track;
            const tracks = this.player_.textTracks();
            super.handleClick(event);
            if (!tracks) {
                return;
            }
            for (let i = 0; i < tracks.length; i++) {
                const track = tracks[i];
                if (this.kinds.indexOf(track.kind) === -1) {
                    continue;
                }
                if (track === referenceTrack) {
                    if (track.mode !== 'showing') {
                        track.mode = 'showing';
                    }
                } else if (track.mode !== 'disabled') {
                    track.mode = 'disabled';
                }
            }
        }
        handleTracksChange(event) {
            const shouldBeSelected = this.track.mode === 'showing';
            if (shouldBeSelected !== this.isSelected_) {
                this.selected(shouldBeSelected);
            }
        }
        handleSelectedLanguageChange(event) {
            if (this.track.mode === 'showing') {
                const selectedLanguage = this.player_.cache_.selectedLanguage;
                if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
                    return;
                }
                this.player_.cache_.selectedLanguage = {
                    enabled: true,
                    language: this.track.language,
                    kind: this.track.kind
                };
            }
        }
        dispose() {
            this.track = null;
            super.dispose();
        }
    }
    Component.registerComponent('TextTrackMenuItem', TextTrackMenuItem);
    return TextTrackMenuItem;
});
define('skylark-videojs/control-bar/text-track-controls/off-text-track-menu-item',[
    './text-track-menu-item',
    '../../component'
], function (TextTrackMenuItem, Component) {
    'use strict';
    class OffTextTrackMenuItem extends TextTrackMenuItem {
        constructor(player, options) {
            options.track = {
                player,
                kind: options.kind,
                kinds: options.kinds,
                default: false,
                mode: 'disabled'
            };
            if (!options.kinds) {
                options.kinds = [options.kind];
            }
            if (options.label) {
                options.track.label = options.label;
            } else {
                options.track.label = options.kinds.join(' and ') + ' off';
            }
            options.selectable = true;
            options.multiSelectable = false;
            super(player, options);
        }
        handleTracksChange(event) {
            const tracks = this.player().textTracks();
            let shouldBeSelected = true;
            for (let i = 0, l = tracks.length; i < l; i++) {
                const track = tracks[i];
                if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {
                    shouldBeSelected = false;
                    break;
                }
            }
            if (shouldBeSelected !== this.isSelected_) {
                this.selected(shouldBeSelected);
            }
        }
        handleSelectedLanguageChange(event) {
            const tracks = this.player().textTracks();
            let allHidden = true;
            for (let i = 0, l = tracks.length; i < l; i++) {
                const track = tracks[i];
                if ([
                        'captions',
                        'descriptions',
                        'subtitles'
                    ].indexOf(track.kind) > -1 && track.mode === 'showing') {
                    allHidden = false;
                    break;
                }
            }
            if (allHidden) {
                this.player_.cache_.selectedLanguage = { enabled: false };
            }
        }
    }
    Component.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);
    return OffTextTrackMenuItem;
});
define('skylark-videojs/control-bar/text-track-controls/text-track-button',[
    '../track-button',
    '../../component',
    './text-track-menu-item',
    './off-text-track-menu-item'
], function (TrackButton, Component, TextTrackMenuItem, OffTextTrackMenuItem) {
    'use strict';
    class TextTrackButton extends TrackButton {
        constructor(player, options = {}) {
            options.tracks = player.textTracks();
            super(player, options);
        }
        createItems(items = [], TrackMenuItem = TextTrackMenuItem) {
            let label;
            if (this.label_) {
                label = `${ this.label_ } off`;
            }
            items.push(new OffTextTrackMenuItem(this.player_, {
                kinds: this.kinds_,
                kind: this.kind_,
                label
            }));
            this.hideThreshold_ += 1;
            const tracks = this.player_.textTracks();
            if (!Array.isArray(this.kinds_)) {
                this.kinds_ = [this.kind_];
            }
            for (let i = 0; i < tracks.length; i++) {
                const track = tracks[i];
                if (this.kinds_.indexOf(track.kind) > -1) {
                    const item = new TrackMenuItem(this.player_, {
                        track,
                        kinds: this.kinds_,
                        kind: this.kind_,
                        selectable: true,
                        multiSelectable: false
                    });
                    item.addClass(`vjs-${ track.kind }-menu-item`);
                    items.push(item);
                }
            }
            return items;
        }
    }
    Component.registerComponent('TextTrackButton', TextTrackButton);
    return TextTrackButton;
});
define('skylark-videojs/control-bar/text-track-controls/chapters-track-menu-item',[
    '../../menu/menu-item',
    '../../component',
    '../../utils/fn'
], function (MenuItem, Component, Fn) {
    'use strict';
    class ChaptersTrackMenuItem extends MenuItem {
        constructor(player, options) {
            const track = options.track;
            const cue = options.cue;
            const currentTime = player.currentTime();
            options.selectable = true;
            options.multiSelectable = false;
            options.label = cue.text;
            options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
            super(player, options);
            this.track = track;
            this.cue = cue;
            track.addEventListener('cuechange', Fn.bind(this, this.update));
        }
        handleClick(event) {
            super.handleClick();
            this.player_.currentTime(this.cue.startTime);
            this.update(this.cue.startTime);
        }
        update(event) {
            const cue = this.cue;
            const currentTime = this.player_.currentTime();
            this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
        }
    }
    Component.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);
    return ChaptersTrackMenuItem;
});
define('skylark-videojs/control-bar/text-track-controls/chapters-button',[
    './text-track-button',
    '../../component',
    './chapters-track-menu-item',
    '../../utils/string-cases'
], function (TextTrackButton, Component, ChaptersTrackMenuItem, stringCases) {
    'use strict';
    class ChaptersButton extends TextTrackButton {
        constructor(player, options, ready) {
            super(player, options, ready);
        }
        buildCSSClass() {
            return `vjs-chapters-button ${ super.buildCSSClass() }`;
        }
        buildWrapperCSSClass() {
            return `vjs-chapters-button ${ super.buildWrapperCSSClass() }`;
        }
        update(event) {
            if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {
                this.setTrack(this.findChaptersTrack());
            }
            super.update();
        }
        setTrack(track) {
            if (this.track_ === track) {
                return;
            }
            if (!this.updateHandler_) {
                this.updateHandler_ = this.update.bind(this);
            }
            if (this.track_) {
                const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                if (remoteTextTrackEl) {
                    remoteTextTrackEl.removeEventListener('load', this.updateHandler_);
                }
                this.track_ = null;
            }
            this.track_ = track;
            if (this.track_) {
                this.track_.mode = 'hidden';
                const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                if (remoteTextTrackEl) {
                    remoteTextTrackEl.addEventListener('load', this.updateHandler_);
                }
            }
        }
        findChaptersTrack() {
            const tracks = this.player_.textTracks() || [];
            for (let i = tracks.length - 1; i >= 0; i--) {
                const track = tracks[i];
                if (track.kind === this.kind_) {
                    return track;
                }
            }
        }
        getMenuCaption() {
            if (this.track_ && this.track_.label) {
                return this.track_.label;
            }
            return this.localize(stringCases.toTitleCase(this.kind_));
        }
        createMenu() {
            this.options_.title = this.getMenuCaption();
            return super.createMenu();
        }
        createItems() {
            const items = [];
            if (!this.track_) {
                return items;
            }
            const cues = this.track_.cues;
            if (!cues) {
                return items;
            }
            for (let i = 0, l = cues.length; i < l; i++) {
                const cue = cues[i];
                const mi = new ChaptersTrackMenuItem(this.player_, {
                    track: this.track_,
                    cue
                });
                items.push(mi);
            }
            return items;
        }
    }
    ChaptersButton.prototype.kind_ = 'chapters';
    ChaptersButton.prototype.controlText_ = 'Chapters';
    Component.registerComponent('ChaptersButton', ChaptersButton);
    return ChaptersButton;
});
define('skylark-videojs/control-bar/text-track-controls/descriptions-button',[
    './text-track-button',
    '../../component',
    '../../utils/fn'
], function (TextTrackButton, Component, Fn) {
    'use strict';
    class DescriptionsButton extends TextTrackButton {
        constructor(player, options, ready) {
            super(player, options, ready);
            const tracks = player.textTracks();
            const changeHandler = Fn.bind(this, this.handleTracksChange);
            tracks.addEventListener('change', changeHandler);
            this.listenTo('dispose', function () {
                tracks.removeEventListener('change', changeHandler);
            });
        }
        handleTracksChange(event) {
            const tracks = this.player().textTracks();
            let disabled = false;
            for (let i = 0, l = tracks.length; i < l; i++) {
                const track = tracks[i];
                if (track.kind !== this.kind_ && track.mode === 'showing') {
                    disabled = true;
                    break;
                }
            }
            if (disabled) {
                this.disable();
            } else {
                this.enable();
            }
        }
        buildCSSClass() {
            return `vjs-descriptions-button ${ super.buildCSSClass() }`;
        }
        buildWrapperCSSClass() {
            return `vjs-descriptions-button ${ super.buildWrapperCSSClass() }`;
        }
    }
    DescriptionsButton.prototype.kind_ = 'descriptions';
    DescriptionsButton.prototype.controlText_ = 'Descriptions';
    Component.registerComponent('DescriptionsButton', DescriptionsButton);
    return DescriptionsButton;
});
define('skylark-videojs/control-bar/text-track-controls/subtitles-button',[
    './text-track-button',
    '../../component'
], function (TextTrackButton, Component) {
    'use strict';
    class SubtitlesButton extends TextTrackButton {
        constructor(player, options, ready) {
            super(player, options, ready);
        }
        buildCSSClass() {
            return `vjs-subtitles-button ${ super.buildCSSClass() }`;
        }
        buildWrapperCSSClass() {
            return `vjs-subtitles-button ${ super.buildWrapperCSSClass() }`;
        }
    }
    SubtitlesButton.prototype.kind_ = 'subtitles';
    SubtitlesButton.prototype.controlText_ = 'Subtitles';
    Component.registerComponent('SubtitlesButton', SubtitlesButton);
    return SubtitlesButton;
});
define('skylark-videojs/control-bar/text-track-controls/caption-settings-menu-item',[
    './text-track-menu-item',
    '../../component'
], function (TextTrackMenuItem, Component) {
    'use strict';
    class CaptionSettingsMenuItem extends TextTrackMenuItem {
        constructor(player, options) {
            options.track = {
                player,
                kind: options.kind,
                label: options.kind + ' settings',
                selectable: false,
                default: false,
                mode: 'disabled'
            };
            options.selectable = false;
            options.name = 'CaptionSettingsMenuItem';
            super(player, options);
            this.addClass('vjs-texttrack-settings');
            this.controlText(', opens ' + options.kind + ' settings dialog');
        }
        handleClick(event) {
            this.player().getChild('textTrackSettings').open();
        }
    }
    Component.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);
    return CaptionSettingsMenuItem;
});
define('skylark-videojs/control-bar/text-track-controls/captions-button',[
    './text-track-button',
    '../../component',
    './caption-settings-menu-item'
], function (TextTrackButton, Component, CaptionSettingsMenuItem) {
    'use strict';
    class CaptionsButton extends TextTrackButton {
        constructor(player, options, ready) {
            super(player, options, ready);
        }
        buildCSSClass() {
            return `vjs-captions-button ${ super.buildCSSClass() }`;
        }
        buildWrapperCSSClass() {
            return `vjs-captions-button ${ super.buildWrapperCSSClass() }`;
        }
        createItems() {
            const items = [];
            if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {
                items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));
                this.hideThreshold_ += 1;
            }
            return super.createItems(items);
        }
    }
    CaptionsButton.prototype.kind_ = 'captions';
    CaptionsButton.prototype.controlText_ = 'Captions';
    Component.registerComponent('CaptionsButton', CaptionsButton);
    return CaptionsButton;
});
define('skylark-videojs/control-bar/text-track-controls/subs-caps-menu-item',[
    './text-track-menu-item',
    '../../component',
    '../../utils/obj'
], function (TextTrackMenuItem, Component, obj) {
    'use strict';
    class SubsCapsMenuItem extends TextTrackMenuItem {
        createEl(type, props, attrs) {
            let innerHTML = `<span class="vjs-menu-item-text">${ this.localize(this.options_.label) }`;
            if (this.options_.track.kind === 'captions') {
                innerHTML += `
        <span aria-hidden="true" class="vjs-icon-placeholder"></span>
        <span class="vjs-control-text"> ${ this.localize('Captions') }</span>
      `;
            }
            innerHTML += '</span>';
            const el = super.createEl(type, obj.assign({ innerHTML }, props), attrs);
            return el;
        }
    }
    Component.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);
    return SubsCapsMenuItem;
});
define('skylark-videojs/control-bar/text-track-controls/subs-caps-button',[
    './text-track-button',
    '../../component',
    './caption-settings-menu-item',
    './subs-caps-menu-item',
    '../../utils/string-cases'
], function (TextTrackButton, Component, CaptionSettingsMenuItem, SubsCapsMenuItem, stringCases) {
    'use strict';
    class SubsCapsButton extends TextTrackButton {
        constructor(player, options = {}) {
            super(player, options);
            this.label_ = 'subtitles';
            if ([
                    'en',
                    'en-us',
                    'en-ca',
                    'fr-ca'
                ].indexOf(this.player_.language_) > -1) {
                this.label_ = 'captions';
            }
            this.menuButton_.controlText(stringCases.toTitleCase(this.label_));
        }
        buildCSSClass() {
            return `vjs-subs-caps-button ${ super.buildCSSClass() }`;
        }
        buildWrapperCSSClass() {
            return `vjs-subs-caps-button ${ super.buildWrapperCSSClass() }`;
        }
        createItems() {
            let items = [];
            if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {
                items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));
                this.hideThreshold_ += 1;
            }
            items = super.createItems(items, SubsCapsMenuItem);
            return items;
        }
    }
    SubsCapsButton.prototype.kinds_ = [
        'captions',
        'subtitles'
    ];
    SubsCapsButton.prototype.controlText_ = 'Subtitles';
    Component.registerComponent('SubsCapsButton', SubsCapsButton);
    return SubsCapsButton;
});
define('skylark-videojs/control-bar/audio-track-controls/audio-track-menu-item',[
    '../../menu/menu-item',
    '../../component',
    '../../utils/obj'
], function (MenuItem, Component, obj) {
    'use strict';
    class AudioTrackMenuItem extends MenuItem {
        constructor(player, options) {
            const track = options.track;
            const tracks = player.audioTracks();
            options.label = track.label || track.language || 'Unknown';
            options.selected = track.enabled;
            super(player, options);
            this.track = track;
            this.addClass(`vjs-${ track.kind }-menu-item`);
            const changeHandler = (...args) => {
                this.handleTracksChange.apply(this, args);
            };
            tracks.addEventListener('change', changeHandler);
            this.listenTo('dispose', () => {
                tracks.removeEventListener('change', changeHandler);
            });
        }
        createEl(type, props, attrs) {
            let innerHTML = `<span class="vjs-menu-item-text">${ this.localize(this.options_.label) }`;
            if (this.options_.track.kind === 'main-desc') {
                innerHTML += `
        <span aria-hidden="true" class="vjs-icon-placeholder"></span>
        <span class="vjs-control-text"> ${ this.localize('Descriptions') }</span>
      `;
            }
            innerHTML += '</span>';
            const el = super.createEl(type, obj.assign({ innerHTML }, props), attrs);
            return el;
        }
        handleClick(event) {
            const tracks = this.player_.audioTracks();
            super.handleClick(event);
            for (let i = 0; i < tracks.length; i++) {
                const track = tracks[i];
                track.enabled = track === this.track;
            }
        }
        handleTracksChange(event) {
            this.selected(this.track.enabled);
        }
    }
    Component.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);
    return AudioTrackMenuItem;
});
define('skylark-videojs/control-bar/audio-track-controls/audio-track-button',[
    '../track-button',
    '../../component',
    './audio-track-menu-item'
], function (TrackButton, Component, AudioTrackMenuItem) {
    'use strict';
    class AudioTrackButton extends TrackButton {
        constructor(player, options = {}) {
            options.tracks = player.audioTracks();
            super(player, options);
        }
        buildCSSClass() {
            return `vjs-audio-button ${ super.buildCSSClass() }`;
        }
        buildWrapperCSSClass() {
            return `vjs-audio-button ${ super.buildWrapperCSSClass() }`;
        }
        createItems(items = []) {
            this.hideThreshold_ = 1;
            const tracks = this.player_.audioTracks();
            for (let i = 0; i < tracks.length; i++) {
                const track = tracks[i];
                items.push(new AudioTrackMenuItem(this.player_, {
                    track,
                    selectable: true,
                    multiSelectable: false
                }));
            }
            return items;
        }
    }
    AudioTrackButton.prototype.controlText_ = 'Audio Track';
    Component.registerComponent('AudioTrackButton', AudioTrackButton);
    return AudioTrackButton;
});
define('skylark-videojs/control-bar/playback-rate-menu/playback-rate-menu-item',[
    '../../menu/menu-item',
    '../../component'
], function (MenuItem, Component) {
    'use strict';
    class PlaybackRateMenuItem extends MenuItem {
        constructor(player, options) {
            const label = options.rate;
            const rate = parseFloat(label, 10);
            options.label = label;
            options.selected = rate === 1;
            options.selectable = true;
            options.multiSelectable = false;
            super(player, options);
            this.label = label;
            this.rate = rate;
            this.listenTo(player, 'ratechange', this.update);
        }
        handleClick(event) {
            super.handleClick();
            this.player().playbackRate(this.rate);
        }
        update(event) {
            this.selected(this.player().playbackRate() === this.rate);
        }
    }
    PlaybackRateMenuItem.prototype.contentElType = 'button';
    Component.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);
    return PlaybackRateMenuItem;
});
define('skylark-videojs/control-bar/playback-rate-menu/playback-rate-menu-button',[
    '../../menu/menu-button',
    '../../menu/menu',
    './playback-rate-menu-item',
    '../../component',
    '../../utils/dom'
], function (MenuButton, Menu, PlaybackRateMenuItem, Component, Dom) {
    'use strict';
    class PlaybackRateMenuButton extends MenuButton {
        constructor(player, options) {
            super(player, options);
            this.updateVisibility();
            this.updateLabel();
            this.listenTo(player, 'loadstart', this.updateVisibility);
            this.listenTo(player, 'ratechange', this.updateLabel);
        }
        createEl() {
            const el = super.createEl();
            this.labelEl_ = Dom.createEl('div', {
                className: 'vjs-playback-rate-value',
                innerHTML: '1x'
            });
            el.appendChild(this.labelEl_);
            return el;
        }
        dispose() {
            this.labelEl_ = null;
            super.dispose();
        }
        buildCSSClass() {
            return `vjs-playback-rate ${ super.buildCSSClass() }`;
        }
        buildWrapperCSSClass() {
            return `vjs-playback-rate ${ super.buildWrapperCSSClass() }`;
        }
        createMenu() {
            const menu = new Menu(this.player());
            const rates = this.playbackRates();
            if (rates) {
                for (let i = rates.length - 1; i >= 0; i--) {
                    menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));
                }
            }
            return menu;
        }
        updateARIAAttributes() {
            this.el().setAttribute('aria-valuenow', this.player().playbackRate());
        }
        handleClick(event) {
            const currentRate = this.player().playbackRate();
            const rates = this.playbackRates();
            let newRate = rates[0];
            for (let i = 0; i < rates.length; i++) {
                if (rates[i] > currentRate) {
                    newRate = rates[i];
                    break;
                }
            }
            this.player().playbackRate(newRate);
        }
        playbackRates() {
            return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;
        }
        playbackRateSupported() {
            return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
        }
        updateVisibility(event) {
            if (this.playbackRateSupported()) {
                this.removeClass('vjs-hidden');
            } else {
                this.addClass('vjs-hidden');
            }
        }
        updateLabel(event) {
            if (this.playbackRateSupported()) {
                this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
            }
        }
    }
    PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';
    Component.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);
    return PlaybackRateMenuButton;
});
define('skylark-videojs/control-bar/spacer-controls/spacer',[
    '../../component'
], function (Component) {
    'use strict';
    class Spacer extends Component {
        buildCSSClass() {
            return `vjs-spacer ${ super.buildCSSClass() }`;
        }
        createEl() {
            return super.createEl('div', { className: this.buildCSSClass() });
        }
    }
    Component.registerComponent('Spacer', Spacer);
    return Spacer;
});
define('skylark-videojs/control-bar/spacer-controls/custom-control-spacer',[
    './spacer',
    '../../component'
], function (Spacer, Component) {
    'use strict';
    class CustomControlSpacer extends Spacer {
        buildCSSClass() {
            return `vjs-custom-control-spacer ${ super.buildCSSClass() }`;
        }
        createEl() {
            const el = super.createEl({ className: this.buildCSSClass() });
            el.innerHTML = '\xA0';
            return el;
        }
    }
    Component.registerComponent('CustomControlSpacer', CustomControlSpacer);
    return CustomControlSpacer;
});
define('skylark-videojs/control-bar/control-bar',[
    'skylark-langx-globals/document',
    '../component',
    './play-toggle',
    './time-controls/current-time-display',
    './time-controls/duration-display',
    './time-controls/time-divider',
    './time-controls/remaining-time-display',
    './live-display',
    './seek-to-live',
    './progress-control/progress-control',
    './picture-in-picture-toggle',
    './fullscreen-toggle',
    './volume-panel',
    './text-track-controls/chapters-button',
    './text-track-controls/descriptions-button',
    './text-track-controls/subtitles-button',
    './text-track-controls/captions-button',
    './text-track-controls/subs-caps-button',
    './audio-track-controls/audio-track-button',
    './playback-rate-menu/playback-rate-menu-button',
    './spacer-controls/custom-control-spacer'
], function (document,Component) {
    'use strict';
    class ControlBar extends Component {
        createEl() {
            return super.createEl('div', {
                className: 'vjs-control-bar',
                dir: 'ltr'
            });
        }
    }
    ControlBar.prototype.options_ = {
        children: [
            'playToggle',
            'volumePanel',
            'currentTimeDisplay',
            'timeDivider',
            'durationDisplay',
            'progressControl',
            'liveDisplay',
            'seekToLive',
            'remainingTimeDisplay',
            'customControlSpacer',
            'playbackRateMenuButton',
            'chaptersButton',
            'descriptionsButton',
            'subsCapsButton',
            'audioTrackButton',
            'fullscreenToggle'
        ]
    };
    if ('exitPictureInPicture' in document) {
        ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, 'pictureInPictureToggle');
    }
    Component.registerComponent('ControlBar', ControlBar);
    return ControlBar;
});
define('skylark-videojs/error-display',[
    './component',
    './modal-dialog'
], function (Component, ModalDialog) {
    'use strict';
    class ErrorDisplay extends ModalDialog {
        constructor(player, options) {
            super(player, options);
            this.listenTo(player, 'error', this.open);
        }
        buildCSSClass() {
            return `vjs-error-display ${ super.buildCSSClass() }`;
        }
        content() {
            const error = this.player().error();
            return error ? this.localize(error.message) : '';
        }
    }
    ErrorDisplay.prototype.options_ = Object.assign({}, ModalDialog.prototype.options_, {
        pauseOnOpen: false,
        fillAlways: true,
        temporary: false,
        uncloseable: true
    });
    Component.registerComponent('ErrorDisplay', ErrorDisplay);
    return ErrorDisplay;
});
define('skylark-videojs/tracks/text-track-settings',[
    '../component',
    '../modal-dialog',
    '../utils/dom',
    '../utils/fn',
    '../utils/obj',
    '../utils/log'
], function (Component, ModalDialog, Dom, Fn, Obj, log) {
    'use strict';
    const LOCAL_STORAGE_KEY = 'vjs-text-track-settings';
    const COLOR_BLACK = [
        '#000',
        'Black'
    ];
    const COLOR_BLUE = [
        '#00F',
        'Blue'
    ];
    const COLOR_CYAN = [
        '#0FF',
        'Cyan'
    ];
    const COLOR_GREEN = [
        '#0F0',
        'Green'
    ];
    const COLOR_MAGENTA = [
        '#F0F',
        'Magenta'
    ];
    const COLOR_RED = [
        '#F00',
        'Red'
    ];
    const COLOR_WHITE = [
        '#FFF',
        'White'
    ];
    const COLOR_YELLOW = [
        '#FF0',
        'Yellow'
    ];
    const OPACITY_OPAQUE = [
        '1',
        'Opaque'
    ];
    const OPACITY_SEMI = [
        '0.5',
        'Semi-Transparent'
    ];
    const OPACITY_TRANS = [
        '0',
        'Transparent'
    ];
    const selectConfigs = {
        backgroundColor: {
            selector: '.vjs-bg-color > select',
            id: 'captions-background-color-%s',
            label: 'Color',
            options: [
                COLOR_BLACK,
                COLOR_WHITE,
                COLOR_RED,
                COLOR_GREEN,
                COLOR_BLUE,
                COLOR_YELLOW,
                COLOR_MAGENTA,
                COLOR_CYAN
            ]
        },
        backgroundOpacity: {
            selector: '.vjs-bg-opacity > select',
            id: 'captions-background-opacity-%s',
            label: 'Transparency',
            options: [
                OPACITY_OPAQUE,
                OPACITY_SEMI,
                OPACITY_TRANS
            ]
        },
        color: {
            selector: '.vjs-fg-color > select',
            id: 'captions-foreground-color-%s',
            label: 'Color',
            options: [
                COLOR_WHITE,
                COLOR_BLACK,
                COLOR_RED,
                COLOR_GREEN,
                COLOR_BLUE,
                COLOR_YELLOW,
                COLOR_MAGENTA,
                COLOR_CYAN
            ]
        },
        edgeStyle: {
            selector: '.vjs-edge-style > select',
            id: '%s',
            label: 'Text Edge Style',
            options: [
                [
                    'none',
                    'None'
                ],
                [
                    'raised',
                    'Raised'
                ],
                [
                    'depressed',
                    'Depressed'
                ],
                [
                    'uniform',
                    'Uniform'
                ],
                [
                    'dropshadow',
                    'Dropshadow'
                ]
            ]
        },
        fontFamily: {
            selector: '.vjs-font-family > select',
            id: 'captions-font-family-%s',
            label: 'Font Family',
            options: [
                [
                    'proportionalSansSerif',
                    'Proportional Sans-Serif'
                ],
                [
                    'monospaceSansSerif',
                    'Monospace Sans-Serif'
                ],
                [
                    'proportionalSerif',
                    'Proportional Serif'
                ],
                [
                    'monospaceSerif',
                    'Monospace Serif'
                ],
                [
                    'casual',
                    'Casual'
                ],
                [
                    'script',
                    'Script'
                ],
                [
                    'small-caps',
                    'Small Caps'
                ]
            ]
        },
        fontPercent: {
            selector: '.vjs-font-percent > select',
            id: 'captions-font-size-%s',
            label: 'Font Size',
            options: [
                [
                    '0.50',
                    '50%'
                ],
                [
                    '0.75',
                    '75%'
                ],
                [
                    '1.00',
                    '100%'
                ],
                [
                    '1.25',
                    '125%'
                ],
                [
                    '1.50',
                    '150%'
                ],
                [
                    '1.75',
                    '175%'
                ],
                [
                    '2.00',
                    '200%'
                ],
                [
                    '3.00',
                    '300%'
                ],
                [
                    '4.00',
                    '400%'
                ]
            ],
            default: 2,
            parser: v => v === '1.00' ? null : Number(v)
        },
        textOpacity: {
            selector: '.vjs-text-opacity > select',
            id: 'captions-foreground-opacity-%s',
            label: 'Transparency',
            options: [
                OPACITY_OPAQUE,
                OPACITY_SEMI
            ]
        },
        windowColor: {
            selector: '.vjs-window-color > select',
            id: 'captions-window-color-%s',
            label: 'Color'
        },
        windowOpacity: {
            selector: '.vjs-window-opacity > select',
            id: 'captions-window-opacity-%s',
            label: 'Transparency',
            options: [
                OPACITY_TRANS,
                OPACITY_SEMI,
                OPACITY_OPAQUE
            ]
        }
    };
    selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
    function parseOptionValue(value, parser) {
        if (parser) {
            value = parser(value);
        }
        if (value && value !== 'none') {
            return value;
        }
    }
    function getSelectedOptionValue(el, parser) {
        const value = el.options[el.options.selectedIndex].value;
        return parseOptionValue(value, parser);
    }
    function setSelectedOption(el, value, parser) {
        if (!value) {
            return;
        }
        for (let i = 0; i < el.options.length; i++) {
            if (parseOptionValue(el.options[i].value, parser) === value) {
                el.selectedIndex = i;
                break;
            }
        }
    }
    class TextTrackSettings extends ModalDialog {
        constructor(player, options) {
            options.temporary = false;
            super(player, options);
            this.updateDisplay = Fn.bind(this, this.updateDisplay);
            this.fill();
            this.hasBeenOpened_ = this.hasBeenFilled_ = true;
            this.endDialog = Dom.createEl('p', {
                className: 'vjs-control-text',
                textContent: this.localize('End of dialog window.')
            });
            this.el().appendChild(this.endDialog);
            this.setDefaults();
            if (options.persistTextTrackSettings === undefined) {
                this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;
            }
            this.listenTo(this.$('.vjs-done-button'), 'click', () => {
                this.saveSettings();
                this.close();
            });
            this.listenTo(this.$('.vjs-default-button'), 'click', () => {
                this.setDefaults();
                this.updateDisplay();
            });
            Obj.each(selectConfigs, config => {
                this.listenTo(this.$(config.selector), 'change', this.updateDisplay);
            });
            if (this.options_.persistTextTrackSettings) {
                this.restoreSettings();
            }
        }
        dispose() {
            this.endDialog = null;
            super.dispose();
        }
        createElSelect_(key, legendId = '', type = 'label') {
            const config = selectConfigs[key];
            const id = config.id.replace('%s', this.id_);
            const selectLabelledbyIds = [
                legendId,
                id
            ].join(' ').trim();
            return [
                `<${ type } id="${ id }" class="${ type === 'label' ? 'vjs-label' : '' }">`,
                this.localize(config.label),
                `</${ type }>`,
                `<select aria-labelledby="${ selectLabelledbyIds }">`
            ].concat(config.options.map(o => {
                const optionId = id + '-' + o[1].replace(/\W+/g, '');
                return [
                    `<option id="${ optionId }" value="${ o[0] }" `,
                    `aria-labelledby="${ selectLabelledbyIds } ${ optionId }">`,
                    this.localize(o[1]),
                    '</option>'
                ].join('');
            })).concat('</select>').join('');
        }
        createElFgColor_() {
            const legendId = `captions-text-legend-${ this.id_ }`;
            return [
                '<fieldset class="vjs-fg-color vjs-track-setting">',
                `<legend id="${ legendId }">`,
                this.localize('Text'),
                '</legend>',
                this.createElSelect_('color', legendId),
                '<span class="vjs-text-opacity vjs-opacity">',
                this.createElSelect_('textOpacity', legendId),
                '</span>',
                '</fieldset>'
            ].join('');
        }
        createElBgColor_() {
            const legendId = `captions-background-${ this.id_ }`;
            return [
                '<fieldset class="vjs-bg-color vjs-track-setting">',
                `<legend id="${ legendId }">`,
                this.localize('Background'),
                '</legend>',
                this.createElSelect_('backgroundColor', legendId),
                '<span class="vjs-bg-opacity vjs-opacity">',
                this.createElSelect_('backgroundOpacity', legendId),
                '</span>',
                '</fieldset>'
            ].join('');
        }
        createElWinColor_() {
            const legendId = `captions-window-${ this.id_ }`;
            return [
                '<fieldset class="vjs-window-color vjs-track-setting">',
                `<legend id="${ legendId }">`,
                this.localize('Window'),
                '</legend>',
                this.createElSelect_('windowColor', legendId),
                '<span class="vjs-window-opacity vjs-opacity">',
                this.createElSelect_('windowOpacity', legendId),
                '</span>',
                '</fieldset>'
            ].join('');
        }
        createElColors_() {
            return Dom.createEl('div', {
                className: 'vjs-track-settings-colors',
                innerHTML: [
                    this.createElFgColor_(),
                    this.createElBgColor_(),
                    this.createElWinColor_()
                ].join('')
            });
        }
        createElFont_() {
            return Dom.createEl('div', {
                className: 'vjs-track-settings-font',
                innerHTML: [
                    '<fieldset class="vjs-font-percent vjs-track-setting">',
                    this.createElSelect_('fontPercent', '', 'legend'),
                    '</fieldset>',
                    '<fieldset class="vjs-edge-style vjs-track-setting">',
                    this.createElSelect_('edgeStyle', '', 'legend'),
                    '</fieldset>',
                    '<fieldset class="vjs-font-family vjs-track-setting">',
                    this.createElSelect_('fontFamily', '', 'legend'),
                    '</fieldset>'
                ].join('')
            });
        }
        createElControls_() {
            const defaultsDescription = this.localize('restore all settings to the default values');
            return Dom.createEl('div', {
                className: 'vjs-track-settings-controls',
                innerHTML: [
                    `<button type="button" class="vjs-default-button" title="${ defaultsDescription }">`,
                    this.localize('Reset'),
                    `<span class="vjs-control-text"> ${ defaultsDescription }</span>`,
                    '</button>',
                    `<button type="button" class="vjs-done-button">${ this.localize('Done') }</button>`
                ].join('')
            });
        }
        content() {
            return [
                this.createElColors_(),
                this.createElFont_(),
                this.createElControls_()
            ];
        }
        label() {
            return this.localize('Caption Settings Dialog');
        }
        description() {
            return this.localize('Beginning of dialog window. Escape will cancel and close the window.');
        }
        buildCSSClass() {
            return super.buildCSSClass() + ' vjs-text-track-settings';
        }
        getValues() {
            return Obj.reduce(selectConfigs, (accum, config, key) => {
                const value = getSelectedOptionValue(this.$(config.selector), config.parser);
                if (value !== undefined) {
                    accum[key] = value;
                }
                return accum;
            }, {});
        }
        setValues(values) {
            Obj.each(selectConfigs, (config, key) => {
                setSelectedOption(this.$(config.selector), values[key], config.parser);
            });
        }
        setDefaults() {
            Obj.each(selectConfigs, config => {
                const index = config.hasOwnProperty('default') ? config.default : 0;
                this.$(config.selector).selectedIndex = index;
            });
        }
        restoreSettings() {
            let values;
            try {
                values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY));
            } catch (err) {
                log.warn(err);
            }
            if (values) {
                this.setValues(values);
            }
        }
        saveSettings() {
            if (!this.options_.persistTextTrackSettings) {
                return;
            }
            const values = this.getValues();
            try {
                if (Object.keys(values).length) {
                    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));
                } else {
                    window.localStorage.removeItem(LOCAL_STORAGE_KEY);
                }
            } catch (err) {
                log.warn(err);
            }
        }
        updateDisplay() {
            const ttDisplay = this.player_.getChild('textTrackDisplay');
            if (ttDisplay) {
                ttDisplay.updateDisplay();
            }
        }
        conditionalBlur_() {
            this.previouslyActiveEl_ = null;
            const cb = this.player_.controlBar;
            const subsCapsBtn = cb && cb.subsCapsButton;
            const ccBtn = cb && cb.captionsButton;
            if (subsCapsBtn) {
                subsCapsBtn.focus();
            } else if (ccBtn) {
                ccBtn.focus();
            }
        }
    }
    Component.registerComponent('TextTrackSettings', TextTrackSettings);
    return TextTrackSettings;
});
define('skylark-videojs/resize-manager',[
    './utils/fn',
    './utils/events',
    './utils/merge-options',
    './component'
], function ( Fn, Events, mergeOptions, Component) {
    'use strict';
    class ResizeManager extends Component {
        constructor(player, options) {
            let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window.ResizeObserver;
            if (options.ResizeObserver === null) {
                RESIZE_OBSERVER_AVAILABLE = false;
            }
            const options_ = mergeOptions({
                createEl: !RESIZE_OBSERVER_AVAILABLE,
                reportTouchActivity: false
            }, options);
            super(player, options_);
            this.ResizeObserver = options.ResizeObserver || window.ResizeObserver;
            this.loadListener_ = null;
            this.resizeObserver_ = null;
            this.debouncedHandler_ = Fn.debounce(() => {
                this.resizeHandler();
            }, 100, false, this);
            if (RESIZE_OBSERVER_AVAILABLE) {
                this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);
                this.resizeObserver_.observe(player.el());
            } else {
                this.loadListener_ = () => {
                    if (!this.el_ || !this.el_.contentWindow) {
                        return;
                    }
                    const debouncedHandler_ = this.debouncedHandler_;
                    let unloadListener_ = this.unloadListener_ = function () {
                        Events.off(this, 'resize', debouncedHandler_);
                        Events.off(this, 'unload', unloadListener_);
                        unloadListener_ = null;
                    };
                    Events.on(this.el_.contentWindow, 'unload', unloadListener_);
                    Events.on(this.el_.contentWindow, 'resize', debouncedHandler_);
                };
                this.listenToOnce('load', this.loadListener_);
            }
        }
        createEl() {
            return super.createEl('iframe', {
                className: 'vjs-resize-manager',
                tabIndex: -1
            }, { 'aria-hidden': 'true' });
        }
        resizeHandler() {
            if (!this.player_ || !this.player_.trigger) {
                return;
            }
            this.player_.trigger('playerresize');
        }
        dispose() {
            if (this.debouncedHandler_) {
                this.debouncedHandler_.cancel();
            }
            if (this.resizeObserver_) {
                if (this.player_.el()) {
                    this.resizeObserver_.unobserve(this.player_.el());
                }
                this.resizeObserver_.disconnect();
            }
            if (this.loadListener_) {
                this.unlistenTo('load', this.loadListener_);
            }
            if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
                this.unloadListener_.call(this.el_.contentWindow);
            }
            this.ResizeObserver = null;
            this.resizeObserver = null;
            this.debouncedHandler_ = null;
            this.loadListener_ = null;
            super.dispose();
        }
    }
    Component.registerComponent('ResizeManager', ResizeManager);
    return ResizeManager;
});
define('skylark-videojs/live-tracker',[
    './component',
    './utils/merge-options',
    './utils/browser',
    './utils/fn'
], function (Component, mergeOptions, browser,  Fn) {
    'use strict';
    const defaults = {
        trackingThreshold: 30,
        liveTolerance: 15
    };
    class LiveTracker extends Component {
        constructor(player, options) {
            const options_ = mergeOptions(defaults, options, { createEl: false });
            super(player, options_);
            this.reset_();
            this.listenTo(this.player_, 'durationchange', this.handleDurationchange);
            if (browser.IE_VERSION && 'hidden' in document && 'visibilityState' in document) {
                this.listenTo(document, 'visibilitychange', this.handleVisibilityChange);
            }
        }
        handleVisibilityChange() {
            if (this.player_.duration() !== Infinity) {
                return;
            }
            if (document.hidden) {
                this.stopTracking();
            } else {
                this.startTracking();
            }
        }
        trackLive_() {
            const seekable = this.player_.seekable();
            if (!seekable || !seekable.length) {
                return;
            }
            const newTime = Number(window.performance.now().toFixed(4));
            const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1000;
            this.lastTime_ = newTime;
            this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
            const liveCurrentTime = this.liveCurrentTime();
            const currentTime = this.player_.currentTime();
            let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
            if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
                isBehind = false;
            }
            if (isBehind !== this.behindLiveEdge_) {
                this.behindLiveEdge_ = isBehind;
                this.trigger('liveedgechange');
            }
        }
        handleDurationchange() {
            if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
                if (this.player_.options_.liveui) {
                    this.player_.addClass('vjs-liveui');
                }
                this.startTracking();
            } else {
                this.player_.removeClass('vjs-liveui');
                this.stopTracking();
            }
        }
        startTracking() {
            if (this.isTracking()) {
                return;
            }
            if (!this.timeupdateSeen_) {
                this.timeupdateSeen_ = this.player_.hasStarted();
            }
            this.trackingInterval_ = this.setInterval(this.trackLive_, Fn.UPDATE_REFRESH_INTERVAL);
            this.trackLive_();
            this.listenTo(this.player_, [
                'play',
                'pause'
            ], this.trackLive_);
            if (!this.timeupdateSeen_) {
                this.listenToOnce(this.player_, 'play', this.handlePlay);
                this.listenToOnce(this.player_, 'timeupdate', this.handleFirstTimeupdate);
            } else {
                this.listenTo(this.player_, 'seeked', this.handleSeeked);
            }
        }
        handleFirstTimeupdate() {
            this.timeupdateSeen_ = true;
            this.listenTo(this.player_, 'seeked', this.handleSeeked);
        }
        handleSeeked() {
            const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
            this.seekedBehindLive_ = this.skipNextSeeked_ ? false : timeDiff > 2;
            this.skipNextSeeked_ = false;
            this.trackLive_();
        }
        handlePlay() {
            this.listenToOnce(this.player_, 'timeupdate', this.seekToLiveEdge);
        }
        reset_() {
            this.lastTime_ = -1;
            this.pastSeekEnd_ = 0;
            this.lastSeekEnd_ = -1;
            this.behindLiveEdge_ = true;
            this.timeupdateSeen_ = false;
            this.seekedBehindLive_ = false;
            this.skipNextSeeked_ = false;
            this.clearInterval(this.trackingInterval_);
            this.trackingInterval_ = null;

            /*
            this.unlistenTo(this.player_, [
                'play',
                'pause'
            ], this.trackLive_);
            this.unlistenTo(this.player_, 'seeked', this.handleSeeked);
            this.unlistenTo(this.player_, 'play', this.handlePlay);
            this.unlistenTo(this.player_, 'timeupdate', this.handleFirstTimeupdate);
            this.unlistenTo(this.player_, 'timeupdate', this.seekToLiveEdge);
            */
            this.unlistenTo(this.player_, [
                'play',
                'pause'
            ], this.trackLive_);
            this.unlistenTo(this.player_, 'seeked', this.handleSeeked);
            this.unlistenTo(this.player_, 'play', this.handlePlay);
            this.unlistenTo(this.player_, 'timeupdate', this.handleFirstTimeupdate);
            this.unlistenTo(this.player_, 'timeupdate', this.seekToLiveEdge);
        }
        stopTracking() {
            if (!this.isTracking()) {
                return;
            }
            this.reset_();
            this.trigger('liveedgechange');
        }
        seekableEnd() {
            const seekable = this.player_.seekable();
            const seekableEnds = [];
            let i = seekable ? seekable.length : 0;
            while (i--) {
                seekableEnds.push(seekable.end(i));
            }
            return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
        }
        seekableStart() {
            const seekable = this.player_.seekable();
            const seekableStarts = [];
            let i = seekable ? seekable.length : 0;
            while (i--) {
                seekableStarts.push(seekable.start(i));
            }
            return seekableStarts.length ? seekableStarts.sort()[0] : 0;
        }
        liveWindow() {
            const liveCurrentTime = this.liveCurrentTime();
            if (liveCurrentTime === Infinity) {
                return 0;
            }
            return liveCurrentTime - this.seekableStart();
        }
        isLive() {
            return this.isTracking();
        }
        atLiveEdge() {
            return !this.behindLiveEdge();
        }
        liveCurrentTime() {
            return this.pastSeekEnd() + this.seekableEnd();
        }
        pastSeekEnd() {
            const seekableEnd = this.seekableEnd();
            if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
                this.pastSeekEnd_ = 0;
            }
            this.lastSeekEnd_ = seekableEnd;
            return this.pastSeekEnd_;
        }
        behindLiveEdge() {
            return this.behindLiveEdge_;
        }
        isTracking() {
            return typeof this.trackingInterval_ === 'number';
        }
        seekToLiveEdge() {
            this.seekedBehindLive_ = false;
            if (this.atLiveEdge()) {
                return;
            }
            this.skipNextSeeked_ = true;
            this.player_.currentTime(this.liveCurrentTime());
        }
        dispose() {
            this.unlistenTo(document, 'visibilitychange', this.handleVisibilityChange);
            this.stopTracking();
            super.dispose();
        }
    }
    Component.registerComponent('LiveTracker', LiveTracker);
    return LiveTracker;
});
define('skylark-videojs/tech/setup-sourceset',[
    'skylark-langx-globals/document',
    '../utils/merge-options',
    '../utils/url'
], function (document,mergeOptions, url) {
    'use strict';
    const sourcesetLoad = tech => {
        const el = tech.el();
        if (el.hasAttribute('src')) {
            tech.triggerSourceset(el.src);
            return true;
        }
        const sources = tech.$$('source');
        const srcUrls = [];
        let src = '';
        if (!sources.length) {
            return false;
        }
        for (let i = 0; i < sources.length; i++) {
            const url = sources[i].src;
            if (url && srcUrls.indexOf(url) === -1) {
                srcUrls.push(url);
            }
        }
        if (!srcUrls.length) {
            return false;
        }
        if (srcUrls.length === 1) {
            src = srcUrls[0];
        }
        tech.triggerSourceset(src);
        return true;
    };
    const innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {
        get() {
            return this.cloneNode(true).innerHTML;
        },
        set(v) {
            const dummy = document.createElement(this.nodeName.toLowerCase());
            dummy.innerHTML = v;
            const docFrag = document.createDocumentFragment();
            while (dummy.childNodes.length) {
                docFrag.appendChild(dummy.childNodes[0]);
            }
            this.innerText = '';
            window.Element.prototype.appendChild.call(this, docFrag);
            return this.innerHTML;
        }
    });
    const getDescriptor = (priority, prop) => {
        let descriptor = {};
        for (let i = 0; i < priority.length; i++) {
            descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
            if (descriptor && descriptor.set && descriptor.get) {
                break;
            }
        }
        descriptor.enumerable = true;
        descriptor.configurable = true;
        return descriptor;
    };
    const getInnerHTMLDescriptor = tech => getDescriptor([
        tech.el(),
        window.HTMLMediaElement.prototype,
        window.Element.prototype,
        innerHTMLDescriptorPolyfill
    ], 'innerHTML');
    const firstSourceWatch = function (tech) {
        const el = tech.el();
        if (el.resetSourceWatch_) {
            return;
        }
        const old = {};
        const innerDescriptor = getInnerHTMLDescriptor(tech);
        const appendWrapper = appendFn => (...args) => {
            const retval = appendFn.apply(el, args);
            sourcesetLoad(tech);
            return retval;
        };
        [
            'append',
            'appendChild',
            'insertAdjacentHTML'
        ].forEach(k => {
            if (!el[k]) {
                return;
            }
            old[k] = el[k];
            el[k] = appendWrapper(old[k]);
        });
        Object.defineProperty(el, 'innerHTML', mergeOptions(innerDescriptor, { set: appendWrapper(innerDescriptor.set) }));
        el.resetSourceWatch_ = () => {
            el.resetSourceWatch_ = null;
            Object.keys(old).forEach(k => {
                el[k] = old[k];
            });
            Object.defineProperty(el, 'innerHTML', innerDescriptor);
        };
        tech.one('sourceset', el.resetSourceWatch_);
    };
    const srcDescriptorPolyfill = Object.defineProperty({}, 'src', {
        get() {
            if (this.hasAttribute('src')) {
                return url.getAbsoluteURL(window.Element.prototype.getAttribute.call(this, 'src'));
            }
            return '';
        },
        set(v) {
            window.Element.prototype.setAttribute.call(this, 'src', v);
            return v;
        }
    });
    const getSrcDescriptor = tech => getDescriptor([
        tech.el(),
        window.HTMLMediaElement.prototype,
        srcDescriptorPolyfill
    ], 'src');
    const setupSourceset = function (tech) {
        if (!tech.featuresSourceset) {
            return;
        }
        const el = tech.el();
        if (el.resetSourceset_) {
            return;
        }
        const srcDescriptor = getSrcDescriptor(tech);
        const oldSetAttribute = el.setAttribute;
        const oldLoad = el.load;
        Object.defineProperty(el, 'src', mergeOptions(srcDescriptor, {
            set: v => {
                const retval = srcDescriptor.set.call(el, v);
                tech.triggerSourceset(el.src);
                return retval;
            }
        }));
        el.setAttribute = (n, v) => {
            const retval = oldSetAttribute.call(el, n, v);
            if (/src/i.test(n)) {
                tech.triggerSourceset(el.src);
            }
            return retval;
        };
        el.load = () => {
            const retval = oldLoad.call(el);
            if (!sourcesetLoad(tech)) {
                tech.triggerSourceset('');
                firstSourceWatch(tech);
            }
            return retval;
        };
        if (el.currentSrc) {
            tech.triggerSourceset(el.currentSrc);
        } else if (!sourcesetLoad(tech)) {
            firstSourceWatch(tech);
        }
        el.resetSourceset_ = () => {
            el.resetSourceset_ = null;
            el.load = oldLoad;
            el.setAttribute = oldSetAttribute;
            Object.defineProperty(el, 'src', srcDescriptor);
            if (el.resetSourceWatch_) {
                el.resetSourceWatch_();
            }
        };
    };
    return setupSourceset;
});
define('skylark-videojs/utils/define-lazy-property',[],function () {
    'use strict';
    const defineLazyProperty = function (obj, key, getValue, setter = true) {
        const set = value => Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            writable: true
        });
        const options = {
            configurable: true,
            enumerable: true,
            get() {
                const value = getValue();
                set(value);
                return value;
            }
        };
        if (setter) {
            options.set = set;
        }
        return Object.defineProperty(obj, key, options);
    };
    return defineLazyProperty;
});
define('skylark-videojs/tech/html5',[
    "skylark-langx",
    'skylark-langx-globals/document',
    "skylark-domx-noder",
    './tech',
    '../utils/dom',
    '../utils/url',
    '../utils/log',
    '../utils/browser',
    '../utils/obj',
    '../utils/merge-options',
    '../utils/string-cases',
    '../tracks/track-types',
    './setup-sourceset',
    '../utils/define-lazy-property',
    '../utils/promise'
], function (
    langx,
    document,
    noder,
    Tech, 
    Dom, 
    Url, 
    log, 
    browser,  
    obj, 
    mergeOptions, 
    stringCases, 
    TRACK_TYPES, 
    setupSourceset, 
    defineLazyProperty, 
    promise
) {
    'use strict';
    const NORMAL = TRACK_TYPES.NORMAL,
          REMOTE = TRACK_TYPES.REMOTE;

    const NativeEvents = {
            'abort' : 3,
            'canplay' : 3,
            'canplaythrough' : 3,
            'disablepictureinpicturechanged':3,
            'durationchange':3,
            'emptied' : 3,
            'ended':3,
            'enterpictureinpicture':3,
            'error' : 3,
            'leavepictureinpicture':3,
            'loadeddata' : 3,
            'loadstart' : 3,
            'loadedmetadata':3,
            'pause' : 3,
            'play':3,
            'playing' : 3,
            'posterchange':3,
            'progress' : 3,
            'ratechange':3,
            'seeking' : 3,
            'seeked' : 3,
            'sourceset':3,
            'stalled' : 3,
            'suspend':3,
            'textdata':3,
            'texttrackchange':3,
            'timeupdate':3,
            'volumechange':3,
            'waiting' : 3,

    };
    class Html5 extends Tech {

        isNativeEvent(events) {
            var ret  = super.isNativeEvent(events);
            if (ret) {
                return true;
            }
            if (langx.isString(events)) {
                return !!NativeEvents[events];
            } else if (langx.isArray(events)) {
                for (var i=0; i<events.length; i++) {
                    if (NativeEvents[events[i]]) {
                        return true;
                    }
                }
                return false;
            }            

        } 

        constructor(options, ready) {
            super(options, ready);
            const source = options.source;
            let crossoriginTracks = false;
            if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
                this.setSource(source);
            } else {
                this.handleLateInit_(this.el_);
            }
            if (options.enableSourceset) {
                this.setupSourcesetHandling_();
            }
            this.isScrubbing_ = false;
            if (this.el_.hasChildNodes()) {
                const nodes = this.el_.childNodes;
                let nodesLength = nodes.length;
                const removeNodes = [];
                while (nodesLength--) {
                    const node = nodes[nodesLength];
                    const nodeName = node.nodeName.toLowerCase();
                    if (nodeName === 'track') {
                        if (!this.featuresNativeTextTracks) {
                            removeNodes.push(node);
                        } else {
                            this.remoteTextTrackEls().addTrackElement_(node);
                            this.remoteTextTracks().addTrack(node.track);
                            this.textTracks().addTrack(node.track);
                            if (!crossoriginTracks && !this.el_.hasAttribute('crossorigin') && Url.isCrossOrigin(node.src)) {
                                crossoriginTracks = true;
                            }
                        }
                    }
                }
                for (let i = 0; i < removeNodes.length; i++) {
                    this.el_.removeChild(removeNodes[i]);
                }
            }
            this.proxyNativeTracks_();
            if (this.featuresNativeTextTracks && crossoriginTracks) {
                log.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\n" + 'This may prevent text tracks from loading.');
            }
            this.restoreMetadataTracksInIOSNativePlayer_();
            if ((browser.TOUCH_ENABLED || browser.IS_IPHONE || browser.IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
                this.setControls(true);
            }
            this.proxyWebkitFullscreen_();
            this.triggerReady();
        }
        dispose() {
            if (this.el_ && this.el_.resetSourceset_) {
                this.el_.resetSourceset_();
            }
            Html5.disposeMediaElement(this.el_);
            this.options_ = null;
            super.dispose();
        }
        setupSourcesetHandling_() {
            setupSourceset(this);
        }
        restoreMetadataTracksInIOSNativePlayer_() {
            const textTracks = this.textTracks();
            let metadataTracksPreFullscreenState;
            const takeMetadataTrackSnapshot = () => {
                metadataTracksPreFullscreenState = [];
                for (let i = 0; i < textTracks.length; i++) {
                    const track = textTracks[i];
                    if (track.kind === 'metadata') {
                        metadataTracksPreFullscreenState.push({
                            track,
                            storedMode: track.mode
                        });
                    }
                }
            };
            takeMetadataTrackSnapshot();
            textTracks.addEventListener('change', takeMetadataTrackSnapshot);
            this.listenTo('dispose', () => textTracks.removeEventListener('change', takeMetadataTrackSnapshot));
            const restoreTrackMode = () => {
                for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {
                    const storedTrack = metadataTracksPreFullscreenState[i];
                    if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {
                        storedTrack.track.mode = storedTrack.storedMode;
                    }
                }
                textTracks.removeEventListener('change', restoreTrackMode);
            };
            this.listenTo('webkitbeginfullscreen', () => {
                textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
                textTracks.removeEventListener('change', restoreTrackMode);
                textTracks.addEventListener('change', restoreTrackMode);
            });
            this.listenTo('webkitendfullscreen', () => {
                textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
                textTracks.addEventListener('change', takeMetadataTrackSnapshot);
                textTracks.removeEventListener('change', restoreTrackMode);
            });
        }
        overrideNative_(type, override) {
            if (override !== this[`featuresNative${ type }Tracks`]) {
                return;
            }
            const lowerCaseType = type.toLowerCase();
            if (this[`${ lowerCaseType }TracksListeners_`]) {
                Object.keys(this[`${ lowerCaseType }TracksListeners_`]).forEach(eventName => {
                    const elTracks = this.el()[`${ lowerCaseType }Tracks`];
                    elTracks.removeEventListener(eventName, this[`${ lowerCaseType }TracksListeners_`][eventName]);
                });
            }
            this[`featuresNative${ type }Tracks`] = !override;
            this[`${ lowerCaseType }TracksListeners_`] = null;
            this.proxyNativeTracksForType_(lowerCaseType);
        }
        overrideNativeAudioTracks(override) {
            this.overrideNative_('Audio', override);
        }
        overrideNativeVideoTracks(override) {
            this.overrideNative_('Video', override);
        }
        proxyNativeTracksForType_(name) {
            const props = NORMAL[name];
            const elTracks = this.el()[props.getterName];
            const techTracks = this[props.getterName]();
            if (!this[`featuresNative${ props.capitalName }Tracks`] || !elTracks || !elTracks.addEventListener) {
                return;
            }
            const listeners = {
                change: e => {
                    const event = {
                        type: 'change',
                        target: techTracks,
                        currentTarget: techTracks,
                        srcElement: techTracks
                    };
                    techTracks.trigger(event);
                    if (name === 'text') {
                        this[REMOTE.remoteText.getterName]().trigger(event);
                    }
                },
                addtrack(e) {
                    techTracks.addTrack(e.track);
                },
                removetrack(e) {
                    techTracks.removeTrack(e.track);
                }
            };
            const removeOldTracks = function () {
                const removeTracks = [];
                for (let i = 0; i < techTracks.length; i++) {
                    let found = false;
                    for (let j = 0; j < elTracks.length; j++) {
                        if (elTracks[j] === techTracks[i]) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        removeTracks.push(techTracks[i]);
                    }
                }
                while (removeTracks.length) {
                    techTracks.removeTrack(removeTracks.shift());
                }
            };
            this[props.getterName + 'Listeners_'] = listeners;
            Object.keys(listeners).forEach(eventName => {
                const listener = listeners[eventName];
                elTracks.addEventListener(eventName, listener);
                this.listenTo('dispose', e => elTracks.removeEventListener(eventName, listener));
            });
            this.listenTo('loadstart', removeOldTracks);
            this.listenTo('dispose', e => this.unlistenTo('loadstart', removeOldTracks));
        }
        proxyNativeTracks_() {
            NORMAL.names.forEach(name => {
                this.proxyNativeTracksForType_(name);
            });
        }
        createEl() {
            let el = this.options_.tag;
            if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
                if (el) {
                    const clone = el.cloneNode(true);
                    if (el.parentNode) {
                        el.parentNode.insertBefore(clone, el);
                    }
                    Html5.disposeMediaElement(el);
                    el = clone;
                } else {
                    el = document.createElement('video');
                    const tagAttributes = this.options_.tag && Dom.getAttributes(this.options_.tag);
                    const attributes = mergeOptions({}, tagAttributes);
                    if (!browser.TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
                        delete attributes.controls;
                    }
                    Dom.setAttributes(el, obj.assign(attributes, {
                        id: this.options_.techId,
                        class: 'vjs-tech'
                    }));
                }
                el.playerId = this.options_.playerId;
            }
            if (typeof this.options_.preload !== 'undefined') {
                Dom.setAttribute(el, 'preload', this.options_.preload);
            }
            if (this.options_.disablePictureInPicture !== undefined) {
                el.disablePictureInPicture = this.options_.disablePictureInPicture;
            }
            const settingsAttrs = [
                'loop',
                'muted',
                'playsinline',
                'autoplay'
            ];
            for (let i = 0; i < settingsAttrs.length; i++) {
                const attr = settingsAttrs[i];
                const value = this.options_[attr];
                if (typeof value !== 'undefined') {
                    if (value) {
                        Dom.setAttribute(el, attr, attr);
                    } else {
                        Dom.removeAttribute(el, attr);
                    }
                    el[attr] = value;
                }
            }
            return el;
        }
        handleLateInit_(el) {
            if (el.networkState === 0 || el.networkState === 3) {
                return;
            }
            if (el.readyState === 0) {
                let loadstartFired = false;
                const setLoadstartFired = function () {
                    loadstartFired = true;
                };
                this.listenTo('loadstart', setLoadstartFired);
                const triggerLoadstart = function () {
                    if (!loadstartFired) {
                        this.trigger('loadstart');
                    }
                };
                this.listenTo('loadedmetadata', triggerLoadstart);
                this.ready(function () {
                    this.unlistenTo('loadstart', setLoadstartFired);
                    this.unlistenTo('loadedmetadata', triggerLoadstart);
                    if (!loadstartFired) {
                        this.trigger('loadstart');
                    }
                });
                return;
            }
            const eventsToTrigger = ['loadstart'];
            eventsToTrigger.push('loadedmetadata');
            if (el.readyState >= 2) {
                eventsToTrigger.push('loadeddata');
            }
            if (el.readyState >= 3) {
                eventsToTrigger.push('canplay');
            }
            if (el.readyState >= 4) {
                eventsToTrigger.push('canplaythrough');
            }
            this.ready(function () {
                eventsToTrigger.forEach(function (type) {
                    this.trigger(type);
                }, this);
            });
        }
        setScrubbing(isScrubbing) {
            this.isScrubbing_ = isScrubbing;
        }
        scrubbing() {
            return this.isScrubbing_;
        }
        setCurrentTime(seconds) {
            try {
                if (this.isScrubbing_ && this.el_.fastSeek && browser.IS_ANY_SAFARI) {
                    this.el_.fastSeek(seconds);
                } else {
                    this.el_.currentTime = seconds;
                }
            } catch (e) {
                log(e, 'Video is not ready. (Video.js)');
            }
        }
        duration() {
            if (this.el_.duration === Infinity && browser.IS_ANDROID && browser.IS_CHROME && this.el_.currentTime === 0) {
                const checkProgress = () => {
                    if (this.el_.currentTime > 0) {
                        if (this.el_.duration === Infinity) {
                            this.trigger('durationchange');
                        }
                        this.unlistenTo('timeupdate', checkProgress);
                    }
                };
                this.listenTo('timeupdate', checkProgress);
                return NaN;
            }
            return this.el_.duration || NaN;
        }
        width() {
            return this.el_.offsetWidth;
        }
        height() {
            return this.el_.offsetHeight;
        }
        proxyWebkitFullscreen_() {
            if (!('webkitDisplayingFullscreen' in this.el_)) {
                return;
            }
            const endFn = function () {
                this.trigger('fullscreenchange', { isFullscreen: false });
            };
            const beginFn = function () {
                if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {
                    this.listenToOnce('webkitendfullscreen', endFn);
                    this.trigger('fullscreenchange', {
                        isFullscreen: true,
                        nativeIOSFullscreen: true
                    });
                }
            };
            this.listenTo('webkitbeginfullscreen', beginFn);
            this.listenTo('dispose', () => {
                this.unlistenTo('webkitbeginfullscreen', beginFn);
                this.unlistenTo('webkitendfullscreen', endFn);
            });
        }
        supportsFullScreen() {
            if (typeof this.el_.webkitEnterFullScreen === 'function') {
                const userAgent = window.navigator && window.navigator.userAgent || '';
                if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
                    return true;
                }
            }
            return false;
        }
        enterFullScreen() {
            const video = this.el_;
            if (video.paused && video.networkState <= video.HAVE_METADATA) {
                promise.silencePromise(this.el_.play());
                this.setTimeout(function () {
                    video.pause();
                    try {
                        video.webkitEnterFullScreen();
                    } catch (e) {
                        this.trigger('fullscreenerror', e);
                    }
                }, 0);
            } else {
                try {
                    video.webkitEnterFullScreen();
                } catch (e) {
                    this.trigger('fullscreenerror', e);
                }
            }
        }
        exitFullScreen() {
            if (!this.el_.webkitDisplayingFullscreen) {
                this.trigger('fullscreenerror', new Error('The video is not fullscreen'));
                return;
            }
            //this.el_.webkitExitFullScreen();
            noder.fullscreen(false);
        }
        requestPictureInPicture() {
            return this.el_.requestPictureInPicture();
        }
        src(src) {
            if (src === undefined) {
                return this.el_.src;
            }
            this.setSrc(src);
        }
        reset() {
            Html5.resetMediaElement(this.el_);
        }
        currentSrc() {
            if (this.currentSource_) {
                return this.currentSource_.src;
            }
            return this.el_.currentSrc;
        }
        setControls(val) {
            this.el_.controls = !!val;
        }
        addTextTrack(kind, label, language) {
            if (!this.featuresNativeTextTracks) {
                return super.addTextTrack(kind, label, language);
            }
            return this.el_.addTextTrack(kind, label, language);
        }
        createRemoteTextTrack(options) {
            if (!this.featuresNativeTextTracks) {
                return super.createRemoteTextTrack(options);
            }
            const htmlTrackElement = document.createElement('track');
            if (options.kind) {
                htmlTrackElement.kind = options.kind;
            }
            if (options.label) {
                htmlTrackElement.label = options.label;
            }
            if (options.language || options.srclang) {
                htmlTrackElement.srclang = options.language || options.srclang;
            }
            if (options.default) {
                htmlTrackElement.default = options.default;
            }
            if (options.id) {
                htmlTrackElement.id = options.id;
            }
            if (options.src) {
                htmlTrackElement.src = options.src;
            }
            return htmlTrackElement;
        }
        addRemoteTextTrack(options, manualCleanup) {
            const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);
            if (this.featuresNativeTextTracks) {
                this.el().appendChild(htmlTrackElement);
            }
            return htmlTrackElement;
        }
        removeRemoteTextTrack(track) {
            super.removeRemoteTextTrack(track);
            if (this.featuresNativeTextTracks) {
                const tracks = this.$$('track');
                let i = tracks.length;
                while (i--) {
                    if (track === tracks[i] || track === tracks[i].track) {
                        this.el().removeChild(tracks[i]);
                    }
                }
            }
        }
        getVideoPlaybackQuality() {
            if (typeof this.el().getVideoPlaybackQuality === 'function') {
                return this.el().getVideoPlaybackQuality();
            }
            const videoPlaybackQuality = {};
            if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {
                videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
                videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
            }
            if (window.performance && typeof window.performance.now === 'function') {
                videoPlaybackQuality.creationTime = window.performance.now();
            } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {
                videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;
            }
            return videoPlaybackQuality;
        }
    }
    defineLazyProperty(Html5, 'TEST_VID', function () {
        if (!Dom.isReal()) {
            return;
        }
        const video = document.createElement('video');
        const track = document.createElement('track');
        track.kind = 'captions';
        track.srclang = 'en';
        track.label = 'English';
        video.appendChild(track);
        return video;
    });
    Html5.isSupported = function () {
        try {
            Html5.TEST_VID.volume = 0.5;
        } catch (e) {
            return false;
        }
        return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
    };
    Html5.canPlayType = function (type) {
        return Html5.TEST_VID.canPlayType(type);
    };
    Html5.canPlaySource = function (srcObj, options) {
        return Html5.canPlayType(srcObj.type);
    };
    Html5.canControlVolume = function () {
        try {
            const volume = Html5.TEST_VID.volume;
            Html5.TEST_VID.volume = volume / 2 + 0.1;
            return volume !== Html5.TEST_VID.volume;
        } catch (e) {
            return false;
        }
    };
    Html5.canMuteVolume = function () {
        try {
            const muted = Html5.TEST_VID.muted;
            Html5.TEST_VID.muted = !muted;
            if (Html5.TEST_VID.muted) {
                Dom.setAttribute(Html5.TEST_VID, 'muted', 'muted');
            } else {
                Dom.removeAttribute(Html5.TEST_VID, 'muted', 'muted');
            }
            return muted !== Html5.TEST_VID.muted;
        } catch (e) {
            return false;
        }
    };
    Html5.canControlPlaybackRate = function () {
        if (browser.IS_ANDROID && browser.IS_CHROME && browser.CHROME_VERSION < 58) {
            return false;
        }
        try {
            const playbackRate = Html5.TEST_VID.playbackRate;
            Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
            return playbackRate !== Html5.TEST_VID.playbackRate;
        } catch (e) {
            return false;
        }
    };
    Html5.canOverrideAttributes = function () {
        try {
            const noop = () => {
            };
            Object.defineProperty(document.createElement('video'), 'src', {
                get: noop,
                set: noop
            });
            Object.defineProperty(document.createElement('audio'), 'src', {
                get: noop,
                set: noop
            });
            Object.defineProperty(document.createElement('video'), 'innerHTML', {
                get: noop,
                set: noop
            });
            Object.defineProperty(document.createElement('audio'), 'innerHTML', {
                get: noop,
                set: noop
            });
        } catch (e) {
            return false;
        }
        return true;
    };
    Html5.supportsNativeTextTracks = function () {
        return browser.IS_ANY_SAFARI || browser.IS_IOS && browser.IS_CHROME;
    };
    Html5.supportsNativeVideoTracks = function () {
        return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
    };
    Html5.supportsNativeAudioTracks = function () {
        return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
    };
    Html5.Events = [
        'loadstart',
        'suspend',
        'abort',
        'error',
        'emptied',
        'stalled',
        'loadedmetadata',
        'loadeddata',
        'canplay',
        'canplaythrough',
        'playing',
        'waiting',
        'seeking',
        'seeked',
        'ended',
        'durationchange',
        'timeupdate',
        'progress',
        'play',
        'pause',
        'ratechange',
        'resize',
        'volumechange'
    ];
    [
        [
            'featuresVolumeControl',
            'canControlVolume'
        ],
        [
            'featuresMuteControl',
            'canMuteVolume'
        ],
        [
            'featuresPlaybackRate',
            'canControlPlaybackRate'
        ],
        [
            'featuresSourceset',
            'canOverrideAttributes'
        ],
        [
            'featuresNativeTextTracks',
            'supportsNativeTextTracks'
        ],
        [
            'featuresNativeVideoTracks',
            'supportsNativeVideoTracks'
        ],
        [
            'featuresNativeAudioTracks',
            'supportsNativeAudioTracks'
        ]
    ].forEach(function ([key, fn]) {
        defineLazyProperty(Html5.prototype, key, () => Html5[fn](), true);
    });
    Html5.prototype.movingMediaElementInDOM = !browser.IS_IOS;
    Html5.prototype.featuresFullscreenResize = true;
    Html5.prototype.featuresProgressEvents = true;
    Html5.prototype.featuresTimeupdateEvents = true;
    let canPlayType;
    Html5.patchCanPlayType = function () {
        if (browser.ANDROID_VERSION >= 4 && !browser.IS_FIREFOX && !browser.IS_CHROME) {
            canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
            Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
                const mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
                if (type && mpegurlRE.test(type)) {
                    return 'maybe';
                }
                return canPlayType.call(this, type);
            };
        }
    };
    Html5.unpatchCanPlayType = function () {
        const r = Html5.TEST_VID.constructor.prototype.canPlayType;
        if (canPlayType) {
            Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
        }
        return r;
    };
    Html5.patchCanPlayType();
    Html5.disposeMediaElement = function (el) {
        if (!el) {
            return;
        }
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
        while (el.hasChildNodes()) {
            el.removeChild(el.firstChild);
        }
        el.removeAttribute('src');
        if (typeof el.load === 'function') {
            (function () {
                try {
                    el.load();
                } catch (e) {
                }
            }());
        }
    };
    Html5.resetMediaElement = function (el) {
        if (!el) {
            return;
        }
        const sources = el.querySelectorAll('source');
        let i = sources.length;
        while (i--) {
            el.removeChild(sources[i]);
        }
        el.removeAttribute('src');
        if (typeof el.load === 'function') {
            (function () {
                try {
                    el.load();
                } catch (e) {
                }
            }());
        }
    };
    [
        'muted',
        'defaultMuted',
        'autoplay',
        'controls',
        'loop',
        'playsinline'
    ].forEach(function (prop) {
        Html5.prototype[prop] = function () {
            return this.el_[prop] || this.el_.hasAttribute(prop);
        };
    });
    [
        'muted',
        'defaultMuted',
        'autoplay',
        'loop',
        'playsinline'
    ].forEach(function (prop) {
        Html5.prototype['set' + stringCases.toTitleCase(prop)] = function (v) {
            this.el_[prop] = v;
            if (v) {
                this.el_.setAttribute(prop, prop);
            } else {
                this.el_.removeAttribute(prop);
            }
        };
    });
    [
        'paused',
        'currentTime',
        'buffered',
        'volume',
        'poster',
        'preload',
        'error',
        'seeking',
        'seekable',
        'ended',
        'playbackRate',
        'defaultPlaybackRate',
        'disablePictureInPicture',
        'played',
        'networkState',
        'readyState',
        'videoWidth',
        'videoHeight',
        'crossOrigin'
    ].forEach(function (prop) {
        Html5.prototype[prop] = function () {
            return this.el_[prop];
        };
    });
    [
        'volume',
        'src',
        'poster',
        'preload',
        'playbackRate',
        'defaultPlaybackRate',
        'disablePictureInPicture',
        'crossOrigin'
    ].forEach(function (prop) {
        Html5.prototype['set' + stringCases.toTitleCase(prop)] = function (v) {
            this.el_[prop] = v;
        };
    });
    [
        'pause',
        'load',
        'play'
    ].forEach(function (prop) {
        Html5.prototype[prop] = function () {
            return this.el_[prop]();
        };
    });
    Tech.withSourceHandlers(Html5);
    Html5.nativeSourceHandler = {};
    Html5.nativeSourceHandler.canPlayType = function (type) {
        try {
            return Html5.TEST_VID.canPlayType(type);
        } catch (e) {
            return '';
        }
    };
    Html5.nativeSourceHandler.canHandleSource = function (source, options) {
        if (source.type) {
            return Html5.nativeSourceHandler.canPlayType(source.type);
        } else if (source.src) {
            const ext = Url.getFileExtension(source.src);
            return Html5.nativeSourceHandler.canPlayType(`video/${ ext }`);
        }
        return '';
    };
    Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
        tech.setSrc(source.src);
    };
    Html5.nativeSourceHandler.dispose = function () {
    };
    Html5.registerSourceHandler(Html5.nativeSourceHandler);
    Tech.registerTech('Html5', Html5);
    return Html5;
});
define('skylark-videojs/player',[
    'skylark-langx-globals/document',
    'skylark-domx',
    './component',
    ///'./mixins/evented',
    './utils/events',
    './utils/dom',
    './utils/fn',
    './utils/guid',
    './utils/browser',
    './utils/log',
    './utils/string-cases',
    './utils/time-ranges',
    './utils/buffer',
    './utils/stylesheet',
    './fullscreen-api',
    './media-error',
    './utils/safeParseTuple',
    './utils/obj',
    './utils/merge-options',
    './utils/promise',
    './tracks/text-track-list-converter',
    './modal-dialog',
    './tech/tech',
    './tech/middleware',
    './tracks/track-types',
    './utils/filter-source',
    './utils/mimetypes',
    './utils/keycode',
    './tech/loader',
    './poster-image',
    './tracks/text-track-display',
    './loading-spinner',
    './big-play-button',
    './close-button',
    './control-bar/control-bar',
    './error-display',
    './tracks/text-track-settings',
    './resize-manager',
    './live-tracker',
    './tech/html5'
], function (
    document,
    domx,
    Component,
    Events, 
    Dom, 
    Fn, 
    Guid, 
    browser, 
    log, 
    stringCases, 
    timeRages, 
    buffer, 
    stylesheet, 
    FullscreenApi, 
    MediaError, 
    safeParseTuple, 
    obj, 
    mergeOptions, 
    promise, 
    textTrackConverter, 
    ModalDialog, 
    Tech, 
    middleware, 
    TRACK_TYPES, 
    filterSource, 
    mimetypes, 
    keycode
) {
    'use strict';
    const TECH_EVENTS_RETRIGGER = [
        'progress',
        'abort',
        'suspend',
        'emptied',
        'stalled',
        'loadedmetadata',
        'loadeddata',
        'timeupdate',
        'resize',
        'volumechange',
        'texttrackchange'
    ];
    const TECH_EVENTS_QUEUE = {
        canplay: 'CanPlay',
        canplaythrough: 'CanPlayThrough',
        playing: 'Playing',
        seeked: 'Seeked'
    };
    const BREAKPOINT_ORDER = [
        'tiny',
        'xsmall',
        'small',
        'medium',
        'large',
        'xlarge',
        'huge'
    ];
    const BREAKPOINT_CLASSES = {};
    BREAKPOINT_ORDER.forEach(k => {
        const v = k.charAt(0) === 'x' ? `x-${ k.substring(1) }` : k;
        BREAKPOINT_CLASSES[k] = `vjs-layout-${ v }`;
    });
    const DEFAULT_BREAKPOINTS = {
        tiny: 210,
        xsmall: 320,
        small: 425,
        medium: 768,
        large: 1440,
        xlarge: 2560,
        huge: Infinity
    };
    class Player extends Component {
        _construct(tag, options, ready) {
            tag.id = tag.id || options.id || `vjs_video_${ Guid.newGUID() }`;
            options = obj.assign(Player.getTagSettings(tag), options);
            options.initChildren = false;
            ///options.createEl = false;
            options.evented = false;
            options.reportTouchActivity = false;
            if (!options.language) {
                if (typeof tag.closest === 'function') {
                    const closest = tag.closest('[lang]');
                    if (closest && closest.getAttribute) {
                        options.language = closest.getAttribute('lang');
                    }
                } else {
                    let element = tag;
                    while (element && element.nodeType === 1) {
                        if (Dom.getAttributes(element).hasOwnProperty('lang')) {
                            options.language = element.getAttribute('lang');
                            break;
                        }
                        element = element.parentNode;
                    }
                }
            }

            this.tag = tag;
            this.tagAttributes = tag && Dom.getAttributes(tag);

            super._construct(null, options, ready);

            this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e);
            this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e);
            this.isFullscreen_ = false;
            this.log = log.createLogger(this.id_);
            this.fsApi_ = FullscreenApi;
            this.isPosterFromTech_ = false;
            this.queuedCallbacks_ = [];
            this.isReady_ = false;
            this.hasStarted_ = false;
            this.userActive_ = false;
            this.debugEnabled_ = false;
            if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {
                throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
            }
            this.language(this.options_.language);
            if (options.languages) {
                const languagesToLower = {};
                Object.getOwnPropertyNames(options.languages).forEach(function (name) {
                    languagesToLower[name.toLowerCase()] = options.languages[name];
                });
                this.languages_ = languagesToLower;
            } else {
                this.languages_ = Player.prototype.options_.languages;
            }
            this.resetCache_();
            this.poster_ = options.poster || '';
            this.controls_ = !!options.controls;
            tag.controls = false;
            tag.removeAttribute('controls');
            this.changingSrc_ = false;
            this.playCallbacks_ = [];
            this.playTerminatedQueue_ = [];
            if (tag.hasAttribute('autoplay')) {
                this.autoplay(true);
            } else {
                this.autoplay(this.options_.autoplay);
            }
            if (options.plugins) {
                Object.keys(options.plugins).forEach(name => {
                    if (typeof this[name] !== 'function') {
                        throw new Error(`plugin "${ name }" does not exist`);
                    }
                });
            }
            this.scrubbing_ = false;
            ///this.el_ = this.createEl();
            //evented(this, { eventBusKey: 'el_' });
            if (this.fsApi_.requestFullscreen) {
                Events.on(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
                this.listenTo(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
            }
            if (this.fluid_) {
                this.listenTo([
                    'playerreset',
                    'resize'
                ], this.updateStyleEl_);
            }
            const playerOptionsCopy = mergeOptions(this.options_);
            if (options.plugins) {
                Object.keys(options.plugins).forEach(name => {
                    this[name](options.plugins[name]);
                });
            }
            if (options.debug) {
                this.debug(true);
            }
            this.options_.playerOptions = playerOptionsCopy;
            this.middleware_ = [];
            this.initChildren();
            this.isAudio(tag.nodeName.toLowerCase() === 'audio');
            if (this.controls()) {
                this.addClass('vjs-controls-enabled');
            } else {
                this.addClass('vjs-controls-disabled');
            }
            this.el_.setAttribute('role', 'region');
            if (this.isAudio()) {
                this.el_.setAttribute('aria-label', this.localize('Audio Player'));
            } else {
                this.el_.setAttribute('aria-label', this.localize('Video Player'));
            }
            if (this.isAudio()) {
                this.addClass('vjs-audio');
            }
            if (this.flexNotSupported_()) {
                this.addClass('vjs-no-flex');
            }
            if (browser.TOUCH_ENABLED) {
                this.addClass('vjs-touch-enabled');
            }
            if (!browser.IS_IOS) {
                this.addClass('vjs-workinghover');
            }
            Player.players[this.id_] = this;
            const majorVersion = "7";
            this.addClass(`vjs-v${ majorVersion }`);
            this.userActive(true);
            this.reportUserActivity();
            this.listenToOnce('play', this.listenForUserActivity_);
            this.listenTo('stageclick', this.handleStageClick_);
            this.listenTo('keydown', this.handleKeyDown);
            this.listenTo('languagechange', this.handleLanguagechange);
            this.breakpoints(this.options_.breakpoints);
            this.responsive(this.options_.responsive);

            log.info("The player is created.");
        }

        _init() {
            super._init();

            this.children_.unshift(this.tag);

            this.addClass('vjs-paused');

            if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
                this.styleEl_ = stylesheet.createStyleElement('vjs-styles-dimensions');
                const defaultsStyleEl = Dom.$('.vjs-styles-defaults');
                const head = Dom.$('head');
                head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
            }
            this.fill_ = false;
            this.fluid_ = false;
            this.width(this.options_.width);
            this.height(this.options_.height);
            this.fill(this.options_.fill);
            this.fluid(this.options_.fluid);
            this.aspectRatio(this.options_.aspectRatio);
            this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);

        }
        dispose() {
            this.trigger('dispose');
            this.unlistenTo('dispose');
            Events.off(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
            Events.off(document, 'keydown', this.boundFullWindowOnEscKey_);
            if (this.styleEl_ && this.styleEl_.parentNode) {
                this.styleEl_.parentNode.removeChild(this.styleEl_);
                this.styleEl_ = null;
            }
            Player.players[this.id_] = null;
            if (this.tag && this.tag.player) {
                this.tag.player = null;
            }
            if (this.el_ && this.el_.player) {
                this.el_.player = null;
            }
            if (this.tech_) {
                this.tech_.dispose();
                this.isPosterFromTech_ = false;
                this.poster_ = '';
            }
            if (this.playerElIngest_) {
                this.playerElIngest_ = null;
            }
            if (this.tag) {
                this.tag = null;
            }
            middleware.clearCacheForPlayer(this);
            TRACK_TYPES.ALL.names.forEach(name => {
                const props = TRACK_TYPES[name];
                const list = this[props.getterName]();
                if (list && list.off) {
                    list.off();
                }
            });
            super.dispose();
        }
        createEl() {
            let tag = this.tag;
            let el;
            let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');
            const divEmbed = this.tag.tagName.toLowerCase() === 'video-js';
            if (playerElIngest) {
                el = this.el_ = tag.parentNode;
            } else if (!divEmbed) {
                el = this.el_ = super.createEl('div');
            }
            const attrs = Dom.getAttributes(tag);
            if (divEmbed) {
                el = this.el_ = tag;
                tag = this.tag = document.createElement('video');
                while (el.children.length) {
                    tag.appendChild(el.firstChild);
                }
                if (!Dom.hasClass(el, 'video-js')) {
                    Dom.addClass(el, 'video-js');
                }
                el.appendChild(tag);
                playerElIngest = this.playerElIngest_ = el;
                Object.keys(el).forEach(k => {
                    try {
                        tag[k] = el[k];
                    } catch (e) {
                    }
                });
            }
            tag.setAttribute('tabindex', '-1');
            attrs.tabindex = '-1';
            if (browser.IE_VERSION || browser.IS_CHROME && browser.IS_WINDOWS) {
                tag.setAttribute('role', 'application');
                attrs.role = 'application';
            }
            tag.removeAttribute('width');
            tag.removeAttribute('height');
            if ('width' in attrs) {
                delete attrs.width;
            }
            if ('height' in attrs) {
                delete attrs.height;
            }
            Object.getOwnPropertyNames(attrs).forEach(function (attr) {
                if (!(divEmbed && attr === 'class')) {
                    el.setAttribute(attr, attrs[attr]);
                }
                if (divEmbed) {
                    tag.setAttribute(attr, attrs[attr]);
                }
            });
            tag.playerId = tag.id;
            tag.id += '_html5_api';
            tag.className = 'vjs-tech';
            tag.player = el.player = this;

            const links = tag.getElementsByTagName('a');
            for (let i = 0; i < links.length; i++) {
                const linkEl = links.item(i);
                Dom.addClass(linkEl, 'vjs-hidden');
                linkEl.setAttribute('hidden', 'hidden');
            }
            tag.initNetworkState_ = tag.networkState;
            if (tag.parentNode && !playerElIngest) {
                tag.parentNode.insertBefore(el, tag);
            }
            Dom.prependTo(tag, el);
            this.el_.setAttribute('lang', this.language_);
            this.el_ = el;
            return el;
        }
        crossOrigin(value) {
            if (!value) {
                return this.techGet_('crossOrigin');
            }
            if (value !== 'anonymous' && value !== 'use-credentials') {
                log.warn(`crossOrigin must be "anonymous" or "use-credentials", given "${ value }"`);
                return;
            }
            this.techCall_('setCrossOrigin', value);
            return;
        }
        width(value) {
            return this.dimension('width', value);
        }
        height(value) {
            return this.dimension('height', value);
        }
        dimension(dimension, value) {
            const privDimension = dimension + '_';
            if (value === undefined) {
                return this[privDimension] || 0;
            }
            if (value === '' || value === 'auto') {
                this[privDimension] = undefined;
                this.updateStyleEl_();
                return;
            }
            const parsedVal = parseFloat(value);
            if (isNaN(parsedVal)) {
                log.error(`Improper value "${ value }" supplied for for ${ dimension }`);
                return;
            }
            this[privDimension] = parsedVal;
            this.updateStyleEl_();
        }
        fluid(bool) {
            if (bool === undefined) {
                return !!this.fluid_;
            }
            this.fluid_ = !!bool;
            ///if (evented.isEvented(this)) {
                this.unlistenTo([
                    'playerreset',
                    'resize'
                ], this.updateStyleEl_);
            ///}
            if (bool) {
                this.addClass('vjs-fluid');
                this.fill(false);
                ///evented.addEventedCallback(this, () => {
                ///    this.listenTo([
                ///        'playerreset',
                ///        'resize'
                ///    ], this.updateStyleEl_);
                ///});
            } else {
                this.removeClass('vjs-fluid');
            }
            this.updateStyleEl_();
        }
        fill(bool) {
            if (bool === undefined) {
                return !!this.fill_;
            }
            this.fill_ = !!bool;
            if (bool) {
                this.addClass('vjs-fill');
                this.fluid(false);
            } else {
                this.removeClass('vjs-fill');
            }
        }
        aspectRatio(ratio) {
            if (ratio === undefined) {
                return this.aspectRatio_;
            }
            if (!/^\d+\:\d+$/.test(ratio)) {
                throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
            }
            this.aspectRatio_ = ratio;
            this.fluid(true);
            this.updateStyleEl_();
        }
        updateStyleEl_() {
            if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {
                const width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
                const height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
                const techEl = this.tech_ && this.tech_.el();
                if (techEl) {
                    if (width >= 0) {
                        techEl.width = width;
                    }
                    if (height >= 0) {
                        techEl.height = height;
                    }
                }
                return;
            }
            let width;
            let height;
            let aspectRatio;
            let idClass;
            if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
                aspectRatio = this.aspectRatio_;
            } else if (this.videoWidth() > 0) {
                aspectRatio = this.videoWidth() + ':' + this.videoHeight();
            } else {
                aspectRatio = '16:9';
            }
            const ratioParts = aspectRatio.split(':');
            const ratioMultiplier = ratioParts[1] / ratioParts[0];
            if (this.width_ !== undefined) {
                width = this.width_;
            } else if (this.height_ !== undefined) {
                width = this.height_ / ratioMultiplier;
            } else {
                width = this.videoWidth() || 300;
            }
            if (this.height_ !== undefined) {
                height = this.height_;
            } else {
                height = width * ratioMultiplier;
            }
            if (/^[^a-zA-Z]/.test(this.id())) {
                idClass = 'dimensions-' + this.id();
            } else {
                idClass = this.id() + '-dimensions';
            }
            this.addClass(idClass);
            stylesheet.setTextContent(this.styleEl_, `
      .${ idClass } {
        width: ${ width }px;
        height: ${ height }px;
      }

      .${ idClass }.vjs-fluid {
        padding-top: ${ ratioMultiplier * 100 }%;
      }
    `);
        }
        loadTech_(techName, source) {
            if (this.tech_) {
                this.unloadTech_();
            }
            const titleTechName = stringCases.toTitleCase(techName);
            const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
            if (titleTechName !== 'Html5' && this.tag) {
                Tech.getTech('Html5').disposeMediaElement(this.tag);
                this.tag.player = null;
                this.tag = null;
            }
            this.techName_ = titleTechName;
            this.isReady_ = false;
            const autoplay = typeof this.autoplay() === 'string' ? false : this.autoplay();
            const techOptions = {
                source,
                autoplay,
                'nativeControlsForTouch': this.options_.nativeControlsForTouch,
                'playerId': this.id(),
                'techId': `${ this.id() }_${ camelTechName }_api`,
                'playsinline': this.options_.playsinline,
                'preload': this.options_.preload,
                'loop': this.options_.loop,
                'disablePictureInPicture': this.options_.disablePictureInPicture,
                'muted': this.options_.muted,
                'poster': this.poster(),
                'language': this.language(),
                'playerElIngest': this.playerElIngest_ || false,
                'vtt.js': this.options_['vtt.js'],
                'canOverridePoster': !!this.options_.techCanOverridePoster,
                'enableSourceset': this.options_.enableSourceset,
                'Promise': this.options_.Promise
            };
            TRACK_TYPES.ALL.names.forEach(name => {
                const props = TRACK_TYPES.ALL[name];
                techOptions[props.getterName] = this[props.privateName];
            });
            obj.assign(techOptions, this.options_[titleTechName]);
            obj.assign(techOptions, this.options_[camelTechName]);
            obj.assign(techOptions, this.options_[techName.toLowerCase()]);
            if (this.tag) {
                techOptions.tag = this.tag;
            }
            if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
                techOptions.startTime = this.cache_.currentTime;
            }
            const TechClass = Tech.getTech(techName);
            if (!TechClass) {
                throw new Error(`No Tech named '${ titleTechName }' exists! '${ titleTechName }' should be registered using videojs.registerTech()'`);
            }
            this.tech_ = new TechClass(techOptions);
            this.tech_.ready(Fn.bind(this, this.handleTechReady_), true);
            textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
            TECH_EVENTS_RETRIGGER.forEach(event => {
                this.listenTo(this.tech_, event, this[`handleTech${ stringCases.toTitleCase(event) }_`]);
            });
            Object.keys(TECH_EVENTS_QUEUE).forEach(event => {
                this.listenTo(this.tech_, event, eventObj => {
                    if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
                        this.queuedCallbacks_.push({
                            callback: this[`handleTech${ TECH_EVENTS_QUEUE[event] }_`].bind(this),
                            event: eventObj
                        });
                        return;
                    }
                    this[`handleTech${ TECH_EVENTS_QUEUE[event] }_`](eventObj);
                });
            });
            this.listenTo(this.tech_, 'loadstart', this.handleTechLoadStart_);
            this.listenTo(this.tech_, 'sourceset', this.handleTechSourceset_);
            this.listenTo(this.tech_, 'waiting', this.handleTechWaiting_);
            this.listenTo(this.tech_, 'ended', this.handleTechEnded_);
            this.listenTo(this.tech_, 'seeking', this.handleTechSeeking_);
            this.listenTo(this.tech_, 'play', this.handleTechPlay_);
            this.listenTo(this.tech_, 'firstplay', this.handleTechFirstPlay_);
            this.listenTo(this.tech_, 'pause', this.handleTechPause_);
            this.listenTo(this.tech_, 'durationchange', this.handleTechDurationChange_);
            this.listenTo(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);
            this.listenTo(this.tech_, 'fullscreenerror', this.handleTechFullscreenError_);
            this.listenTo(this.tech_, 'enterpictureinpicture', this.handleTechEnterPictureInPicture_);
            this.listenTo(this.tech_, 'leavepictureinpicture', this.handleTechLeavePictureInPicture_);
            this.listenTo(this.tech_, 'error', this.handleTechError_);
            this.listenTo(this.tech_, 'loadedmetadata', this.updateStyleEl_);
            this.listenTo(this.tech_, 'posterchange', this.handleTechPosterChange_);
            this.listenTo(this.tech_, 'textdata', this.handleTechTextData_);
            this.listenTo(this.tech_, 'ratechange', this.handleTechRateChange_);
            this.usingNativeControls(this.techGet_('controls'));
            if (this.controls() && !this.usingNativeControls()) {
                this.addTechControlsListeners_();
            }
            if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {
                Dom.prependTo(this.tech_.el(), this.el());
            }
            if (this.tag) {
                this.tag.player = null;
                this.tag = null;
            }
        }
        unloadTech_() {
            TRACK_TYPES.ALL.names.forEach(name => {
                const props = TRACK_TYPES.ALL[name];
                this[props.privateName] = this[props.getterName]();
            });
            this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
            this.isReady_ = false;
            this.tech_.dispose();
            this.tech_ = false;
            if (this.isPosterFromTech_) {
                this.poster_ = '';
                this.trigger('posterchange');
            }
            this.isPosterFromTech_ = false;
        }
        tech(safety) {
            if (safety === undefined) {
                log.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\n" + 'See https://github.com/videojs/video.js/issues/2617 for more info.\n');
            }
            return this.tech_;
        }
        addTechControlsListeners_() {
            this.removeTechControlsListeners_();
            this.listenTo(this.tech_, 'mouseup', this.handleTechClick_);
            this.listenTo(this.tech_, 'dblclick', this.handleTechDoubleClick_);
            this.listenTo(this.tech_, 'touchstart', this.handleTechTouchStart_);
            this.listenTo(this.tech_, 'touchmove', this.handleTechTouchMove_);
            this.listenTo(this.tech_, 'touchend', this.handleTechTouchEnd_);
            this.listenTo(this.tech_, 'tap', this.handleTechTap_);
        }
        removeTechControlsListeners_() {
            this.unlistenTo(this.tech_, 'tap', this.handleTechTap_);
            this.unlistenTo(this.tech_, 'touchstart', this.handleTechTouchStart_);
            this.unlistenTo(this.tech_, 'touchmove', this.handleTechTouchMove_);
            this.unlistenTo(this.tech_, 'touchend', this.handleTechTouchEnd_);
            this.unlistenTo(this.tech_, 'mouseup', this.handleTechClick_);
            this.unlistenTo(this.tech_, 'dblclick', this.handleTechDoubleClick_);
        }
        handleTechReady_() {
            this.triggerReady();
            if (this.cache_.volume) {
                this.techCall_('setVolume', this.cache_.volume);
            }
            this.handleTechPosterChange_();
            this.handleTechDurationChange_();
        }
        handleTechLoadStart_() {
            this.removeClass('vjs-ended');
            this.removeClass('vjs-seeking');
            this.error(null);
            this.handleTechDurationChange_();
            if (!this.paused()) {
                this.trigger('loadstart');
                this.trigger('firstplay');
            } else {
                this.hasStarted(false);
                this.trigger('loadstart');
            }
            this.manualAutoplay_(this.autoplay());
        }
        manualAutoplay_(type) {
            if (!this.tech_ || typeof type !== 'string') {
                return;
            }
            const muted = () => {
                const previouslyMuted = this.muted();
                this.muted(true);
                const restoreMuted = () => {
                    this.muted(previouslyMuted);
                };
                this.playTerminatedQueue_.push(restoreMuted);
                const mutedPromise = this.play();
                if (!promise.isPromise(mutedPromise)) {
                    return;
                }
                return mutedPromise.catch(restoreMuted);
            };
            let promise;
            if (type === 'any' && this.muted() !== true) {
                promise = this.play();
                if (promise.isPromise(promise)) {
                    promise = promise.catch(muted);
                }
            } else if (type === 'muted' && this.muted() !== true) {
                promise = muted();
            } else {
                promise = this.play();
            }
            if (!promise.isPromise(promise)) {
                return;
            }
            return promise.then(() => {
                this.trigger({
                    type: 'autoplay-success',
                    autoplay: type
                });
            }).catch(e => {
                this.trigger({
                    type: 'autoplay-failure',
                    autoplay: type
                });
            });
        }
        updateSourceCaches_(srcObj = '') {
            let src = srcObj;
            let type = '';
            if (typeof src !== 'string') {
                src = srcObj.src;
                type = srcObj.type;
            }
            this.cache_.source = this.cache_.source || {};
            this.cache_.sources = this.cache_.sources || [];
            if (src && !type) {
                type = mimetypes.findMimetype(this, src);
            }
            this.cache_.source = mergeOptions({}, srcObj, {
                src,
                type
            });
            const matchingSources = this.cache_.sources.filter(s => s.src && s.src === src);
            const sourceElSources = [];
            const sourceEls = this.$$('source');
            const matchingSourceEls = [];
            for (let i = 0; i < sourceEls.length; i++) {
                const sourceObj = Dom.getAttributes(sourceEls[i]);
                sourceElSources.push(sourceObj);
                if (sourceObj.src && sourceObj.src === src) {
                    matchingSourceEls.push(sourceObj.src);
                }
            }
            if (matchingSourceEls.length && !matchingSources.length) {
                this.cache_.sources = sourceElSources;
            } else if (!matchingSources.length) {
                this.cache_.sources = [this.cache_.source];
            }
            this.cache_.src = src;
        }
        handleTechSourceset_(event) {
            if (!this.changingSrc_) {
                let updateSourceCaches = src => this.updateSourceCaches_(src);
                const playerSrc = this.currentSource().src;
                const eventSrc = event.src;
                if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
                    if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
                        updateSourceCaches = () => {
                        };
                    }
                }
                updateSourceCaches(eventSrc);
                if (!event.src) {
                    this.tech_.any([
                        'sourceset',
                        'loadstart'
                    ], e => {
                        if (e.type === 'sourceset') {
                            return;
                        }
                        const techSrc = this.techGet('currentSrc');
                        this.lastSource_.tech = techSrc;
                        this.updateSourceCaches_(techSrc);
                    });
                }
            }
            this.lastSource_ = {
                player: this.currentSource().src,
                tech: event.src
            };
            this.trigger({
                src: event.src,
                type: 'sourceset'
            });
        }
        hasStarted(request) {
            if (request === undefined) {
                return this.hasStarted_;
            }
            if (request === this.hasStarted_) {
                return;
            }
            this.hasStarted_ = request;
            if (this.hasStarted_) {
                this.addClass('vjs-has-started');
                this.trigger('firstplay');
            } else {
                this.removeClass('vjs-has-started');
            }
        }
        handleTechPlay_() {
            this.removeClass('vjs-ended');
            this.removeClass('vjs-paused');
            this.addClass('vjs-playing');
            this.hasStarted(true);
            this.trigger('play');
        }
        handleTechRateChange_() {
            if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
                this.queuedCallbacks_.forEach(queued => queued.callback(queued.event));
                this.queuedCallbacks_ = [];
            }
            this.cache_.lastPlaybackRate = this.tech_.playbackRate();
            this.trigger('ratechange');
        }
        handleTechWaiting_() {
            this.addClass('vjs-waiting');
            this.trigger('waiting');
            const timeWhenWaiting = this.currentTime();
            const timeUpdateListener = () => {
                if (timeWhenWaiting !== this.currentTime()) {
                    this.removeClass('vjs-waiting');
                    this.unlistenTo('timeupdate', timeUpdateListener);
                }
            };
            this.listenTo('timeupdate', timeUpdateListener);
        }
        handleTechCanPlay_() {
            this.removeClass('vjs-waiting');
            this.trigger('canplay');
        }
        handleTechCanPlayThrough_() {
            this.removeClass('vjs-waiting');
            this.trigger('canplaythrough');
        }
        handleTechPlaying_() {
            this.removeClass('vjs-waiting');
            this.trigger('playing');
        }
        handleTechSeeking_() {
            this.addClass('vjs-seeking');
            this.trigger('seeking');
        }
        handleTechSeeked_() {
            this.removeClass('vjs-seeking');
            this.removeClass('vjs-ended');
            this.trigger('seeked');
        }
        handleTechFirstPlay_() {
            if (this.options_.starttime) {
                log.warn('Passing the `starttime` option to the player will be deprecated in 6.0');
                this.currentTime(this.options_.starttime);
            }
            this.addClass('vjs-has-started');
            this.trigger('firstplay');
        }
        handleTechPause_() {
            this.removeClass('vjs-playing');
            this.addClass('vjs-paused');
            this.trigger('pause');
        }
        handleTechEnded_() {
            this.addClass('vjs-ended');
            if (this.options_.loop) {
                this.currentTime(0);
                this.play();
            } else if (!this.paused()) {
                this.pause();
            }
            this.trigger('ended');
        }
        handleTechDurationChange_() {
            this.duration(this.techGet_('duration'));
        }
        handleTechClick_(event) {
            if (!Dom.isSingleLeftClick(event)) {
                return;
            }
            if (!this.controls_) {
                return;
            }
            if (this.paused()) {
                promise.silencePromise(this.play());
            } else {
                this.pause();
            }
        }
        handleTechDoubleClick_(event) {
            if (!this.controls_) {
                return;
            }
            const inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), el => el.contains(event.target));
            if (!inAllowedEls) {
                if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.doubleClick === undefined || this.options_.userActions.doubleClick !== false) {
                    if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.doubleClick === 'function') {
                        this.options_.userActions.doubleClick.call(this, event);
                    } else if (this.isFullscreen()) {
                        this.exitFullscreen();
                    } else {
                        this.requestFullscreen();
                    }
                }
            }
        }
        handleTechTap_() {
            this.userActive(!this.userActive());
        }
        handleTechTouchStart_() {
            this.userWasActive = this.userActive();
        }
        handleTechTouchMove_() {
            if (this.userWasActive) {
                this.reportUserActivity();
            }
        }
        handleTechTouchEnd_(event) {
            if (event.cancelable) {
                event.preventDefault();
            }
        }
        handleStageClick_() {
            this.reportUserActivity();
        }
        toggleFullscreenClass_() {
            if (this.isFullscreen()) {
                this.addClass('vjs-fullscreen');
            } else {
                this.removeClass('vjs-fullscreen');
            }
        }
        documentFullscreenChange_(e) {
            const targetPlayer = e.target.player;
            if (targetPlayer && targetPlayer !== this) {
                return;
            }
            const el = this.el();
            let isFs = document[this.fsApi_.fullscreenElement] === el;
            if (!isFs && el.matches) {
                isFs = el.matches(':' + this.fsApi_.fullscreen);
            } else if (!isFs && el.msMatchesSelector) {
                isFs = el.msMatchesSelector(':' + this.fsApi_.fullscreen);
            }
            this.isFullscreen(isFs);
        }
        handleTechFullscreenChange_(event, data) {
            if (data) {
                if (data.nativeIOSFullscreen) {
                    this.toggleClass('vjs-ios-native-fs');
                }
                this.isFullscreen(data.isFullscreen);
            }
        }
        handleTechFullscreenError_(event, err) {
            this.trigger('fullscreenerror', err);
        }
        togglePictureInPictureClass_() {
            if (this.isInPictureInPicture()) {
                this.addClass('vjs-picture-in-picture');
            } else {
                this.removeClass('vjs-picture-in-picture');
            }
        }
        handleTechEnterPictureInPicture_(event) {
            this.isInPictureInPicture(true);
        }
        handleTechLeavePictureInPicture_(event) {
            this.isInPictureInPicture(false);
        }
        handleTechError_() {
            const error = this.tech_.error();
            this.error(error);
        }
        handleTechTextData_() {
            let data = null;
            if (arguments.length > 1) {
                data = arguments[1];
            }
            this.trigger('textdata', data);
        }
        getCache() {
            return this.cache_;
        }
        resetCache_() {
            this.cache_ = {
                currentTime: 0,
                initTime: 0,
                inactivityTimeout: this.options_.inactivityTimeout,
                duration: NaN,
                lastVolume: 1,
                lastPlaybackRate: this.defaultPlaybackRate(),
                media: null,
                src: '',
                source: {},
                sources: [],
                volume: 1
            };
        }
        techCall_(method, arg) {
            this.ready(function () {
                if (method in middleware.allowedSetters) {
                    return middleware.set(this.middleware_, this.tech_, method, arg);
                } else if (method in middleware.allowedMediators) {
                    return middleware.mediate(this.middleware_, this.tech_, method, arg);
                }
                try {
                    if (this.tech_) {
                        this.tech_[method](arg);
                    }
                } catch (e) {
                    log.error(e);
                    throw e;
                }
            }, true);
        }
        techGet_(method) {
            if (!this.tech_ || !this.tech_.isReady_) {
                return;
            }
            if (method in middleware.allowedGetters) {
                return middleware.get(this.middleware_, this.tech_, method);
            } else if (method in middleware.allowedMediators) {
                return middleware.mediate(this.middleware_, this.tech_, method);
            }
            try {
                return this.tech_[method]();
            } catch (e) {
                if (this.tech_[method] === undefined) {
                    log.warn(`Video.js: ${ method } method not defined for ${ this.techName_ } playback technology.`, e);
                    throw e;
                }
                if (e.name === 'TypeError') {
                    log.warn(`Video.js: ${ method } unavailable on ${ this.techName_ } playback technology element.`, e);
                    this.tech_.isReady_ = false;
                    throw e;
                }
                log.error(e);
                throw e;
            }
        }
        play() {
            const PromiseClass = this.options_.Promise || window.Promise;
            if (PromiseClass) {
                return new PromiseClass(resolve => {
                    this.play_(resolve);
                });
            }
            return this.play_();
        }
        play_(callback = promise.silencePromise) {
            this.playCallbacks_.push(callback);
            const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
            if (this.waitToPlay_) {
                this.unlistenTo([
                    'ready',
                    'loadstart'
                ], this.waitToPlay_);
                this.waitToPlay_ = null;
            }
            if (!this.isReady_ || !isSrcReady) {
                this.waitToPlay_ = e => {
                    this.play_();
                };
                this.listenToOnce([
                    'ready',
                    'loadstart'
                ], this.waitToPlay_);
                if (!isSrcReady && (browser.IS_ANY_SAFARI || browser.IS_IOS)) {
                    this.load();
                }
                return;
            }
            const val = this.techGet_('play');
            if (val === null) {
                this.runPlayTerminatedQueue_();
            } else {
                this.runPlayCallbacks_(val);
            }
        }
        runPlayTerminatedQueue_() {
            const queue = this.playTerminatedQueue_.slice(0);
            this.playTerminatedQueue_ = [];
            queue.forEach(function (q) {
                q();
            });
        }
        runPlayCallbacks_(val) {
            const callbacks = this.playCallbacks_.slice(0);
            this.playCallbacks_ = [];
            this.playTerminatedQueue_ = [];
            callbacks.forEach(function (cb) {
                cb(val);
            });
        }
        pause() {
            this.techCall_('pause');
        }
        paused() {
            return this.techGet_('paused') === false ? false : true;
        }
        played() {
            return this.techGet_('played') || timeRages.createTimeRange(0, 0);
        }
        scrubbing(isScrubbing) {
            if (typeof isScrubbing === 'undefined') {
                return this.scrubbing_;
            }
            this.scrubbing_ = !!isScrubbing;
            this.techCall_('setScrubbing', this.scrubbing_);
            if (isScrubbing) {
                this.addClass('vjs-scrubbing');
            } else {
                this.removeClass('vjs-scrubbing');
            }
        }
        currentTime(seconds) {
            if (typeof seconds !== 'undefined') {
                if (seconds < 0) {
                    seconds = 0;
                }
                if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
                    this.cache_.initTime = seconds;
                    this.unlistenTo('canplay', this.applyInitTime_);
                    this.listenToOnce('canplay', this.applyInitTime_);
                    return;
                }
                this.techCall_('setCurrentTime', seconds);
                this.cache_.initTime = 0;
                return;
            }
            this.cache_.currentTime = this.techGet_('currentTime') || 0;
            return this.cache_.currentTime;
        }
        applyInitTime_() {
            this.currentTime(this.cache_.initTime);
        }
        duration(seconds) {
            if (seconds === undefined) {
                return this.cache_.duration !== undefined ? this.cache_.duration : NaN;
            }
            seconds = parseFloat(seconds);
            if (seconds < 0) {
                seconds = Infinity;
            }
            if (seconds !== this.cache_.duration) {
                this.cache_.duration = seconds;
                if (seconds === Infinity) {
                    this.addClass('vjs-live');
                } else {
                    this.removeClass('vjs-live');
                }
                if (!isNaN(seconds)) {
                    this.trigger('durationchange');
                }
            }
        }
        remainingTime() {
            return this.duration() - this.currentTime();
        }
        remainingTimeDisplay() {
            return Math.floor(this.duration()) - Math.floor(this.currentTime());
        }
        buffered() {
            let buffered = this.techGet_('buffered');
            if (!buffered || !buffered.length) {
                buffered = timeRages.createTimeRange(0, 0);
            }
            return buffered;
        }
        bufferedPercent() {
            return buffer.bufferedPercent(this.buffered(), this.duration());
        }
        bufferedEnd() {
            const buffered = this.buffered();
            const duration = this.duration();
            let end = buffered.end(buffered.length - 1);
            if (end > duration) {
                end = duration;
            }
            return end;
        }
        volume(percentAsDecimal) {
            let vol;
            if (percentAsDecimal !== undefined) {
                vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
                this.cache_.volume = vol;
                this.techCall_('setVolume', vol);
                if (vol > 0) {
                    this.lastVolume_(vol);
                }
                return;
            }
            vol = parseFloat(this.techGet_('volume'));
            return isNaN(vol) ? 1 : vol;
        }
        muted(muted) {
            if (muted !== undefined) {
                this.techCall_('setMuted', muted);
                return;
            }
            return this.techGet_('muted') || false;
        }
        defaultMuted(defaultMuted) {
            if (defaultMuted !== undefined) {
                return this.techCall_('setDefaultMuted', defaultMuted);
            }
            return this.techGet_('defaultMuted') || false;
        }
        lastVolume_(percentAsDecimal) {
            if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {
                this.cache_.lastVolume = percentAsDecimal;
                return;
            }
            return this.cache_.lastVolume;
        }
        supportsFullScreen() {
            return this.techGet_('supportsFullScreen') || false;
        }
        isFullscreen(isFS) {
            if (isFS !== undefined) {
                const oldValue = this.isFullscreen_;
                this.isFullscreen_ = Boolean(isFS);
                if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
                    this.trigger('fullscreenchange');
                }
                this.toggleFullscreenClass_();
                return;
            }
            return this.isFullscreen_;
        }
        requestFullscreen(fullscreenOptions) {
            const PromiseClass = this.options_.Promise || window.Promise;
            if (PromiseClass) {
                const self = this;
                return new PromiseClass((resolve, reject) => {
                    function offHandler() {
                        self.off('fullscreenerror', errorHandler);
                        self.off('fullscreenchange', changeHandler);
                    }
                    function changeHandler() {
                        offHandler();
                        resolve();
                    }
                    function errorHandler(e, err) {
                        offHandler();
                        reject(err);
                    }
                    self.one('fullscreenchange', changeHandler);
                    self.one('fullscreenerror', errorHandler);
                    const promise = self.requestFullscreenHelper_(fullscreenOptions);
                    if (promise) {
                        promise.then(offHandler, offHandler);
                        return promise;
                    }
                });
            }
            return this.requestFullscreenHelper_();
        }
        requestFullscreenHelper_(fullscreenOptions) {
            let fsOptions;
            if (!this.fsApi_.prefixed) {
                fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
                if (fullscreenOptions !== undefined) {
                    fsOptions = fullscreenOptions;
                }
            }
//            if (this.fsApi_.requestFullscreen) {
//                const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
            if (domx.browser.support.fullscreen) {
                const promise = domx.noder.fullscreen(this.el_);
                if (promise) {
                    promise.then(() => this.isFullscreen(true), () => this.isFullscreen(false));
                }
                return promise;
            } else if (this.tech_.supportsFullScreen()) {
                this.techCall_('enterFullScreen');
            } else {
                this.enterFullWindow();
            }
        }
        exitFullscreen() {
            const PromiseClass = this.options_.Promise || window.Promise;
            if (PromiseClass) {
                const self = this;
                return new PromiseClass((resolve, reject) => {
                    function offHandler() {
                        self.off('fullscreenerror', errorHandler);
                        self.off('fullscreenchange', changeHandler);
                    }
                    function changeHandler() {
                        offHandler();
                        resolve();
                    }
                    function errorHandler(e, err) {
                        offHandler();
                        reject(err);
                    }
                    self.one('fullscreenchange', changeHandler);
                    self.one('fullscreenerror', errorHandler);
                    const promise = self.exitFullscreenHelper_();
                    if (promise) {
                        promise.then(offHandler, offHandler);
                        return promise;
                    }
                });
            }
            return this.exitFullscreenHelper_();
        }
        exitFullscreenHelper_() {
            if (this.fsApi_.requestFullscreen) {
                //const promise = document[this.fsApi_.exitFullscreen]();
                const promise = domx.noder.fullscreen(false);
                if (promise) {
                    promise.then(() => this.isFullscreen(false));
                }
                return promise;
            } else if (this.tech_.supportsFullScreen()) {
                this.techCall_('exitFullScreen');
            } else {
                this.exitFullWindow();
            }
        }
        enterFullWindow() {
            this.isFullscreen(true);
            this.isFullWindow = true;
            this.docOrigOverflow = document.documentElement.style.overflow;
            Events.on(document, 'keydown', this.boundFullWindowOnEscKey_);
            document.documentElement.style.overflow = 'hidden';
            Dom.addClass(document.body, 'vjs-full-window');
            this.trigger('enterFullWindow');
        }
        fullWindowOnEscKey(event) {
            if (keycode.isEventKey(event, 'Esc')) {
                if (this.isFullscreen() === true) {
                    this.exitFullscreen();
                } else {
                    this.exitFullWindow();
                }
            }
        }
        exitFullWindow() {
            this.isFullscreen(false);
            this.isFullWindow = false;
            Events.off(document, 'keydown', this.boundFullWindowOnEscKey_);
            document.documentElement.style.overflow = this.docOrigOverflow;
            Dom.removeClass(document.body, 'vjs-full-window');
            this.trigger('exitFullWindow');
        }
        disablePictureInPicture(value) {
            if (value === undefined) {
                return this.techGet_('disablePictureInPicture');
            }
            this.techCall_('setDisablePictureInPicture', value);
            this.options_.disablePictureInPicture = value;
            this.trigger('disablepictureinpicturechanged');
        }
        isInPictureInPicture(isPiP) {
            if (isPiP !== undefined) {
                this.isInPictureInPicture_ = !!isPiP;
                this.togglePictureInPictureClass_();
                return;
            }
            return !!this.isInPictureInPicture_;
        }
        requestPictureInPicture() {
            if ('pictureInPictureEnabled' in document && this.disablePictureInPicture() === false) {
                return this.techGet_('requestPictureInPicture');
            }
        }
        exitPictureInPicture() {
            if ('pictureInPictureEnabled' in document) {
                return document.exitPictureInPicture();
            }
        }
        handleKeyDown(event) {
            const {userActions} = this.options_;
            if (!userActions || !userActions.hotkeys) {
                return;
            }
            const excludeElement = el => {
                const tagName = el.tagName.toLowerCase();
                if (el.isContentEditable) {
                    return true;
                }
                const allowedInputTypes = [
                    'button',
                    'checkbox',
                    'hidden',
                    'radio',
                    'reset',
                    'submit'
                ];
                if (tagName === 'input') {
                    return allowedInputTypes.indexOf(el.type) === -1;
                }
                const excludedTags = ['textarea'];
                return excludedTags.indexOf(tagName) !== -1;
            };
            if (excludeElement(this.el_.ownerDocument.activeElement)) {
                return;
            }
            if (typeof userActions.hotkeys === 'function') {
                userActions.hotkeys.call(this, event);
            } else {
                this.handleHotkeys(event);
            }
        }
        handleHotkeys(event) {
            const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
            const {fullscreenKey = keydownEvent => keycode.isEventKey(keydownEvent, 'f'), muteKey = keydownEvent => keycode.isEventKey(keydownEvent, 'm'), playPauseKey = keydownEvent => keycode.isEventKey(keydownEvent, 'k') || keycode.isEventKey(keydownEvent, 'Space')} = hotkeys;
            if (fullscreenKey.call(this, event)) {
                event.preventDefault();
                event.stopPropagation();
                const FSToggle = Component.getComponent('FullscreenToggle');
                if (document[this.fsApi_.fullscreenEnabled] !== false) {
                    FSToggle.prototype.handleClick.call(this, event);
                }
            } else if (muteKey.call(this, event)) {
                event.preventDefault();
                event.stopPropagation();
                const MuteToggle = Component.getComponent('MuteToggle');
                MuteToggle.prototype.handleClick.call(this, event);
            } else if (playPauseKey.call(this, event)) {
                event.preventDefault();
                event.stopPropagation();
                const PlayToggle = Component.getComponent('PlayToggle');
                PlayToggle.prototype.handleClick.call(this, event);
            }
        }
        canPlayType(type) {
            let can;
            for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {
                const techName = j[i];
                let tech = Tech.getTech(techName);
                if (!tech) {
                    tech = Component.getComponent(techName);
                }
                if (!tech) {
                    log.error(`The "${ techName }" tech is undefined. Skipped browser support check for that tech.`);
                    continue;
                }
                if (tech.isSupported()) {
                    can = tech.canPlayType(type);
                    if (can) {
                        return can;
                    }
                }
            }
            return '';
        }
        selectSource(sources) {
            const techs = this.options_.techOrder.map(techName => {
                return [
                    techName,
                    Tech.getTech(techName)
                ];
            }).filter(([techName, tech]) => {
                if (tech) {
                    return tech.isSupported();
                }
                log.error(`The "${ techName }" tech is undefined. Skipped browser support check for that tech.`);
                return false;
            });
            const findFirstPassingTechSourcePair = function (outerArray, innerArray, tester) {
                let found;
                outerArray.some(outerChoice => {
                    return innerArray.some(innerChoice => {
                        found = tester(outerChoice, innerChoice);
                        if (found) {
                            return true;
                        }
                    });
                });
                return found;
            };
            let foundSourceAndTech;
            const flip = fn => (a, b) => fn(b, a);
            const finder = ([techName, tech], source) => {
                if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) {
                    return {
                        source,
                        tech: techName
                    };
                }
            };
            if (this.options_.sourceOrder) {
                foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
            } else {
                foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
            }
            return foundSourceAndTech || false;
        }
        src(source) {
            if (typeof source === 'undefined') {
                return this.cache_.src || '';
            }
            const sources = filterSource(source);
            if (!sources.length) {
                this.setTimeout(function () {
                    this.error({
                        code: 4,
                        message: this.localize(this.options_.notSupportedMessage)
                    });
                }, 0);
                return;
            }
            this.changingSrc_ = true;
            this.cache_.sources = sources;
            this.updateSourceCaches_(sources[0]);
            middleware.setSource(this, sources[0], (middlewareSource, mws) => {
                this.middleware_ = mws;
                this.cache_.sources = sources;
                this.updateSourceCaches_(middlewareSource);
                const err = this.src_(middlewareSource);
                if (err) {
                    if (sources.length > 1) {
                        return this.src(sources.slice(1));
                    }
                    this.changingSrc_ = false;
                    this.setTimeout(function () {
                        this.error({
                            code: 4,
                            message: this.localize(this.options_.notSupportedMessage)
                        });
                    }, 0);
                    this.triggerReady();
                    return;
                }
                middleware.setTech(mws, this.tech_);
            });
        }
        src_(source) {
            const sourceTech = this.selectSource([source]);
            if (!sourceTech) {
                return true;
            }
            if (!stringCases.titleCaseEquals(sourceTech.tech, this.techName_)) {
                this.changingSrc_ = true;
                this.loadTech_(sourceTech.tech, sourceTech.source);
                this.tech_.ready(() => {
                    this.changingSrc_ = false;
                });
                return false;
            }
            this.ready(function () {
                if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {
                    this.techCall_('setSource', source);
                } else {
                    this.techCall_('src', source.src);
                }
                this.changingSrc_ = false;
            }, true);
            return false;
        }
        load() {
            this.techCall_('load');
        }
        reset() {
            const PromiseClass = this.options_.Promise || window.Promise;
            if (this.paused() || !PromiseClass) {
                this.doReset_();
            } else {
                const playPromise = this.play();
                promise.silencePromise(playPromise.then(() => this.doReset_()));
            }
        }
        doReset_() {
            if (this.tech_) {
                this.tech_.clearTracks('text');
            }
            this.resetCache_();
            this.poster('');
            this.loadTech_(this.options_.techOrder[0], null);
            this.techCall_('reset');
            this.resetControlBarUI_();
            ///if (evented.isEvented(this)) {
                this.trigger('playerreset');
            ///}
        }
        resetControlBarUI_() {
            this.resetProgressBar_();
            this.resetPlaybackRate_();
            this.resetVolumeBar_();
        }
        resetProgressBar_() {
            this.currentTime(0);
            const {durationDisplay, remainingTimeDisplay} = this.controlBar;
            if (durationDisplay) {
                durationDisplay.updateContent();
            }
            if (remainingTimeDisplay) {
                remainingTimeDisplay.updateContent();
            }
        }
        resetPlaybackRate_() {
            this.playbackRate(this.defaultPlaybackRate());
            this.handleTechRateChange_();
        }
        resetVolumeBar_() {
            this.volume(1);
            this.trigger('volumechange');
        }
        currentSources() {
            const source = this.currentSource();
            const sources = [];
            if (Object.keys(source).length !== 0) {
                sources.push(source);
            }
            return this.cache_.sources || sources;
        }
        currentSource() {
            return this.cache_.source || {};
        }
        currentSrc() {
            return this.currentSource() && this.currentSource().src || '';
        }
        currentType() {
            return this.currentSource() && this.currentSource().type || '';
        }
        preload(value) {
            if (value !== undefined) {
                this.techCall_('setPreload', value);
                this.options_.preload = value;
                return;
            }
            return this.techGet_('preload');
        }
        autoplay(value) {
            if (value === undefined) {
                return this.options_.autoplay || false;
            }
            let techAutoplay;
            if (typeof value === 'string' && /(any|play|muted)/.test(value)) {
                this.options_.autoplay = value;
                this.manualAutoplay_(value);
                techAutoplay = false;
            } else if (!value) {
                this.options_.autoplay = false;
            } else {
                this.options_.autoplay = true;
            }
            techAutoplay = typeof techAutoplay === 'undefined' ? this.options_.autoplay : techAutoplay;
            if (this.tech_) {
                this.techCall_('setAutoplay', techAutoplay);
            }
        }
        playsinline(value) {
            if (value !== undefined) {
                this.techCall_('setPlaysinline', value);
                this.options_.playsinline = value;
                return this;
            }
            return this.techGet_('playsinline');
        }
        loop(value) {
            if (value !== undefined) {
                this.techCall_('setLoop', value);
                this.options_.loop = value;
                return;
            }
            return this.techGet_('loop');
        }
        poster(src) {
            if (src === undefined) {
                return this.poster_;
            }
            if (!src) {
                src = '';
            }
            if (src === this.poster_) {
                return;
            }
            this.poster_ = src;
            this.techCall_('setPoster', src);
            this.isPosterFromTech_ = false;
            this.trigger('posterchange');
        }
        handleTechPosterChange_() {
            if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
                const newPoster = this.tech_.poster() || '';
                if (newPoster !== this.poster_) {
                    this.poster_ = newPoster;
                    this.isPosterFromTech_ = true;
                    this.trigger('posterchange');
                }
            }
        }
        controls(bool) {
            if (bool === undefined) {
                return !!this.controls_;
            }
            bool = !!bool;
            if (this.controls_ === bool) {
                return;
            }
            this.controls_ = bool;
            if (this.usingNativeControls()) {
                this.techCall_('setControls', bool);
            }
            if (this.controls_) {
                this.removeClass('vjs-controls-disabled');
                this.addClass('vjs-controls-enabled');
                this.trigger('controlsenabled');
                if (!this.usingNativeControls()) {
                    this.addTechControlsListeners_();
                }
            } else {
                this.removeClass('vjs-controls-enabled');
                this.addClass('vjs-controls-disabled');
                this.trigger('controlsdisabled');
                if (!this.usingNativeControls()) {
                    this.removeTechControlsListeners_();
                }
            }
        }
        usingNativeControls(bool) {
            if (bool === undefined) {
                return !!this.usingNativeControls_;
            }
            bool = !!bool;
            if (this.usingNativeControls_ === bool) {
                return;
            }
            this.usingNativeControls_ = bool;
            if (this.usingNativeControls_) {
                this.addClass('vjs-using-native-controls');
                this.trigger('usingnativecontrols');
            } else {
                this.removeClass('vjs-using-native-controls');
                this.trigger('usingcustomcontrols');
            }
        }
        error(err) {
            if (err === undefined) {
                return this.error_ || null;
            }
            if (this.options_.suppressNotSupportedError && err && err.code === 4) {
                const triggerSuppressedError = function () {
                    this.error(err);
                };
                this.options_.suppressNotSupportedError = false;
                this.any([
                    'click',
                    'touchstart'
                ], triggerSuppressedError);
                this.listenToOnce('loadstart', function () {
                    this.unlistenTo([
                        'click',
                        'touchstart'
                    ], triggerSuppressedError);
                });
                return;
            }
            if (err === null) {
                this.error_ = err;
                this.removeClass('vjs-error');
                if (this.errorDisplay) {
                    this.errorDisplay.close();
                }
                return;
            }
            this.error_ = new MediaError(err);
            this.addClass('vjs-error');
            log.error(`(CODE:${ this.error_.code } ${ MediaError.errorTypes[this.error_.code] })`, this.error_.message, this.error_);
            this.trigger('error');
            return;
        }
        reportUserActivity(event) {
            this.userActivity_ = true;
        }
        userActive(bool) {
            if (bool === undefined) {
                return this.userActive_;
            }
            bool = !!bool;
            if (bool === this.userActive_) {
                return;
            }
            this.userActive_ = bool;
            if (this.userActive_) {
                this.userActivity_ = true;
                this.removeClass('vjs-user-inactive');
                this.addClass('vjs-user-active');
                this.trigger('useractive');
                return;
            }
            if (this.tech_) {
                this.tech_.one('mousemove', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                });
            }
            this.userActivity_ = false;
            this.removeClass('vjs-user-active');
            this.addClass('vjs-user-inactive');
            this.trigger('userinactive');
        }
        listenForUserActivity_() {
            let mouseInProgress;
            let lastMoveX;
            let lastMoveY;
            const handleActivity = Fn.bind(this, this.reportUserActivity);
            const handleMouseMove = function (e) {
                if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
                    lastMoveX = e.screenX;
                    lastMoveY = e.screenY;
                    handleActivity();
                }
            };
            const handleMouseDown = function () {
                handleActivity();
                this.clearInterval(mouseInProgress);
                mouseInProgress = this.setInterval(handleActivity, 250);
            };
            const handleMouseUpAndMouseLeave = function (event) {
                handleActivity();
                this.clearInterval(mouseInProgress);
            };
            this.listenTo('mousedown', handleMouseDown);
            this.listenTo('mousemove', handleMouseMove);
            this.listenTo('mouseup', handleMouseUpAndMouseLeave);
            this.listenTo('mouseleave', handleMouseUpAndMouseLeave);
            const controlBar = this.getChild('controlBar');
            if (controlBar && !browser.IS_IOS && !browser.IS_ANDROID) {
                this.listenTo(controlBar,'mouseenter', function (event) {
                    this.cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
                    this.options_.inactivityTimeout = 0;
                });
                this.listenTo(controlBar,'mouseleave', function (event) {
                    this.options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
                });
            }
            this.listenTo('keydown', handleActivity);
            this.listenTo('keyup', handleActivity);
            let inactivityTimeout;
            this.setInterval(function () {
                if (!this.userActivity_) {
                    return;
                }
                this.userActivity_ = false;
                this.userActive(true);
                this.clearTimeout(inactivityTimeout);
                const timeout = this.options_.inactivityTimeout;
                if (timeout <= 0) {
                    return;
                }
                inactivityTimeout = this.setTimeout(function () {
                    if (!this.userActivity_) {
                        this.userActive(false);
                    }
                }, timeout);
            }, 250);
        }
        playbackRate(rate) {
            if (rate !== undefined) {
                this.techCall_('setPlaybackRate', rate);
                return;
            }
            if (this.tech_ && this.tech_.featuresPlaybackRate) {
                return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');
            }
            return 1;
        }
        defaultPlaybackRate(rate) {
            if (rate !== undefined) {
                return this.techCall_('setDefaultPlaybackRate', rate);
            }
            if (this.tech_ && this.tech_.featuresPlaybackRate) {
                return this.techGet_('defaultPlaybackRate');
            }
            return 1;
        }
        isAudio(bool) {
            if (bool !== undefined) {
                this.isAudio_ = !!bool;
                return;
            }
            return !!this.isAudio_;
        }
        addTextTrack(kind, label, language) {
            if (this.tech_) {
                return this.tech_.addTextTrack(kind, label, language);
            }
        }
        addRemoteTextTrack(options, manualCleanup) {
            if (this.tech_) {
                return this.tech_.addRemoteTextTrack(options, manualCleanup);
            }
        }
        removeRemoteTextTrack(obj = {}) {
            let {track} = obj;
            if (!track) {
                track = obj;
            }
            if (this.tech_) {
                return this.tech_.removeRemoteTextTrack(track);
            }
        }
        getVideoPlaybackQuality() {
            return this.techGet_('getVideoPlaybackQuality');
        }
        videoWidth() {
            return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
        }
        videoHeight() {
            return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
        }
        language(code) {
            if (code === undefined) {
                return this.language_;
            }
            if (this.language_ !== String(code).toLowerCase()) {
                this.language_ = String(code).toLowerCase();
                ///if (evented.isEvented(this)) {
                    this.trigger('languagechange');
                ///}
            }
        }
        languages() {
            return mergeOptions(Player.prototype.options_.languages, this.languages_);
        }
        toJSON() {
            const options = mergeOptions(this.options_);
            const tracks = options.tracks;
            options.tracks = [];
            for (let i = 0; i < tracks.length; i++) {
                let track = tracks[i];
                track = mergeOptions(track);
                track.player = undefined;
                options.tracks[i] = track;
            }
            return options;
        }
        createModal(content, options) {
            options = options || {};
            options.content = content || '';
            const modal = new ModalDialog(this, options);
            this.addChild(modal);
            modal.on('dispose', () => {
                this.removeChild(modal);
            });
            modal.open();
            return modal;
        }
        updateCurrentBreakpoint_() {
            if (!this.responsive()) {
                return;
            }
            const currentBreakpoint = this.currentBreakpoint();
            const currentWidth = this.currentWidth();
            for (let i = 0; i < BREAKPOINT_ORDER.length; i++) {
                const candidateBreakpoint = BREAKPOINT_ORDER[i];
                const maxWidth = this.breakpoints_[candidateBreakpoint];
                if (currentWidth <= maxWidth) {
                    if (currentBreakpoint === candidateBreakpoint) {
                        return;
                    }
                    if (currentBreakpoint) {
                        this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
                    }
                    this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
                    this.breakpoint_ = candidateBreakpoint;
                    break;
                }
            }
        }
        removeCurrentBreakpoint_() {
            const className = this.currentBreakpointClass();
            this.breakpoint_ = '';
            if (className) {
                this.removeClass(className);
            }
        }
        breakpoints(breakpoints) {
            if (breakpoints === undefined) {
                return obj.assign(this.breakpoints_);
            }
            this.breakpoint_ = '';
            this.breakpoints_ = obj.assign({}, DEFAULT_BREAKPOINTS, breakpoints);
            this.updateCurrentBreakpoint_();
            return obj.assign(this.breakpoints_);
        }
        responsive(value) {
            if (value === undefined) {
                return this.responsive_;
            }
            value = Boolean(value);
            const current = this.responsive_;
            if (value === current) {
                return;
            }
            this.responsive_ = value;
            if (value) {
                this.listenTo('playerresize', this.updateCurrentBreakpoint_);
                this.updateCurrentBreakpoint_();
            } else {
                this.unlistenTo('playerresize', this.updateCurrentBreakpoint_);
                this.removeCurrentBreakpoint_();
            }
            return value;
        }
        currentBreakpoint() {
            return this.breakpoint_;
        }
        currentBreakpointClass() {
            return BREAKPOINT_CLASSES[this.breakpoint_] || '';
        }
        loadMedia(media, ready) {
            if (!media || typeof media !== 'object') {
                return;
            }
            this.reset();
            this.cache_.media = mergeOptions(media);
            const {artwork, poster, src, textTracks} = this.cache_.media;
            if (!artwork && poster) {
                this.cache_.media.artwork = [{
                        src: poster,
                        type: mimetypes.getMimetype(poster)
                    }];
            }
            if (src) {
                this.src(src);
            }
            if (poster) {
                this.poster(poster);
            }
            if (Array.isArray(textTracks)) {
                textTracks.forEach(tt => this.addRemoteTextTrack(tt, false));
            }
            this.ready(ready);
        }
        getMedia() {
            if (!this.cache_.media) {
                const poster = this.poster();
                const src = this.currentSources();
                const textTracks = Array.prototype.map.call(this.remoteTextTracks(), tt => ({
                    kind: tt.kind,
                    label: tt.label,
                    language: tt.language,
                    src: tt.src
                }));
                const media = {
                    src,
                    textTracks
                };
                if (poster) {
                    media.poster = poster;
                    media.artwork = [{
                            src: media.poster,
                            type: mimetypes.getMimetype(media.poster)
                        }];
                }
                return media;
            }
            return mergeOptions(this.cache_.media);
        }
        static getTagSettings(tag) {
            const baseOptions = {
                sources: [],
                tracks: []
            };
            const tagOptions = Dom.getAttributes(tag);
            const dataSetup = tagOptions['data-setup'];
            if (Dom.hasClass(tag, 'vjs-fill')) {
                tagOptions.fill = true;
            }
            if (Dom.hasClass(tag, 'vjs-fluid')) {
                tagOptions.fluid = true;
            }
            if (dataSetup !== null) {
                const [err, data] = safeParseTuple(dataSetup || '{}');
                if (err) {
                    log.error(err);
                }
                obj.assign(tagOptions, data);
            }
            obj.assign(baseOptions, tagOptions);
            if (tag.hasChildNodes()) {
                const children = tag.childNodes;
                for (let i = 0, j = children.length; i < j; i++) {
                    const child = children[i];
                    const childName = child.nodeName.toLowerCase();
                    if (childName === 'source') {
                        baseOptions.sources.push(Dom.getAttributes(child));
                    } else if (childName === 'track') {
                        baseOptions.tracks.push(Dom.getAttributes(child));
                    }
                }
            }
            return baseOptions;
        }
        flexNotSupported_() {
            const elem = document.createElement('i');
            return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style || 'msFlexOrder' in elem.style);
        }
        debug(enabled) {
            if (enabled === undefined) {
                return this.debugEnabled_;
            }
            if (enabled) {
                this.trigger('debugon');
                this.previousLogLevel_ = this.log.level;
                this.log.level('debug');
                this.debugEnabled_ = true;
            } else {
                this.trigger('debugoff');
                this.log.level(this.previousLogLevel_);
                this.previousLogLevel_ = undefined;
                this.debugEnabled_ = false;
            }
        }
    }
    TRACK_TYPES.ALL.names.forEach(function (name) {
        const props = TRACK_TYPES.ALL[name];
        Player.prototype[props.getterName] = function () {
            if (this.tech_) {
                return this.tech_[props.getterName]();
            }
            this[props.privateName] = this[props.privateName] || new props.ListClass();
            return this[props.privateName];
        };
    });
    Player.prototype.crossorigin = Player.prototype.crossOrigin;
    Player.players = {};
    const navigator = window.navigator;

    Player.prototype.options_ = {
        techOrder: Tech.defaultTechOrder_,
        html5: {},
        inactivityTimeout: 2000,
        playbackRates: [],
        liveui: false,
        children: [
            'mediaLoader',
            'posterImage',
            'textTrackDisplay',
            'loadingSpinner',
            'bigPlayButton',
            'liveTracker',
            'controlBar',
            'errorDisplay',
            'textTrackSettings',
            'resizeManager'
        ],
        language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',
        languages: {},
        notSupportedMessage: 'No compatible source was found for this media.',
        fullscreen: { options: { navigationUI: 'hide' } },
        breakpoints: {},
        responsive: false
    };
    [
        'ended',
        'seeking',
        'seekable',
        'networkState',
        'readyState'
    ].forEach(function (fn) {
        Player.prototype[fn] = function () {
            return this.techGet_(fn);
        };
    });
    TECH_EVENTS_RETRIGGER.forEach(function (event) {
        Player.prototype[`handleTech${ stringCases.toTitleCase(event) }_`] = function () {
            return this.trigger(event);
        };
    });
    Component.registerComponent('Player', Player);
    return Player;
});
define('skylark-videojs/plugin',[
    ///'./mixins/evented',
    './mixins/stateful',
    './utils/events',
    './utils/fn',
    './utils/log',
    "./event-target",
    './player'
], function ( stateful, Events, Fn, log, EventTarget, Player) {
    'use strict';
    const BASE_PLUGIN_NAME = 'plugin';
    const PLUGIN_CACHE_KEY = 'activePlugins_';
    const pluginStorage = {};
    const pluginExists = name => pluginStorage.hasOwnProperty(name);
    const getPlugin = name => pluginExists(name) ? pluginStorage[name] : undefined;
    const markPluginAsActive = (player, name) => {
        player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
        player[PLUGIN_CACHE_KEY][name] = true;
    };
    const triggerSetupEvent = (player, hash, before) => {
        const eventName = (before ? 'before' : '') + 'pluginsetup';
        player.trigger(eventName, hash);
        player.trigger(eventName + ':' + hash.name, hash);
    };
    const createBasicPlugin = function (name, plugin) {
        const basicPluginWrapper = function () {
            triggerSetupEvent(this, {
                name,
                plugin,
                instance: null
            }, true);
            const instance = plugin.apply(this, arguments);
            markPluginAsActive(this, name);
            triggerSetupEvent(this, {
                name,
                plugin,
                instance
            });
            return instance;
        };
        Object.keys(plugin).forEach(function (prop) {
            basicPluginWrapper[prop] = plugin[prop];
        });
        return basicPluginWrapper;
    };
    const createPluginFactory = (name, PluginSubClass) => {
        PluginSubClass.prototype.name = name;
        return function (...args) {
            triggerSetupEvent(this, {
                name,
                plugin: PluginSubClass,
                instance: null
            }, true);
            const instance = new PluginSubClass(...[
                this,
                ...args
            ]);
            this[name] = () => instance;
            triggerSetupEvent(this, instance.getEventHash());
            return instance;
        };
    };
    class Plugin  extends EventTarget{
        constructor(player) {
            if (this.constructor === Plugin) {
                throw new Error('Plugin must be sub-classed; not directly instantiated.');
            }
            this.player = player;
            if (!this.log) {
                this.log = this.player.log.createLogger(this.name);
            }
            ///evented(this);
            ///delete this.trigger;
            stateful(this, this.constructor.defaultState);
            markPluginAsActive(player, this.name);
            this.dispose = Fn.bind(this, this.dispose);
            player.on('dispose', this.dispose);
        }
        version() {
            return this.constructor.VERSION;
        }
        /*
        getEventHash(hash = {}) {
            hash.name = this.name;
            hash.plugin = this.constructor;
            hash.instance = this;
            return hash;
        }
        trigger(event, hash = {}) {
            return Events.trigger(this.eventBusEl_, event, this.getEventHash(hash));
        }
        */
        handleStateChanged(e) {
        }
        dispose() {
            const {name, player} = this;
            this.trigger('dispose');
            this.unlistenTo();
            player.off('dispose', this.dispose);
            player[PLUGIN_CACHE_KEY][name] = false;
            this.player = this.state = null;
            player[name] = createPluginFactory(name, pluginStorage[name]);
        }
        static isBasic(plugin) {
            const p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;
            return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);
        }
        static registerPlugin(name, plugin) {
            if (typeof name !== 'string') {
                throw new Error(`Illegal plugin name, "${ name }", must be a string, was ${ typeof name }.`);
            }
            if (pluginExists(name)) {
                log.warn(`A plugin named "${ name }" already exists. You may want to avoid re-registering plugins!`);
            } else if (Player.prototype.hasOwnProperty(name)) {
                throw new Error(`Illegal plugin name, "${ name }", cannot share a name with an existing player method!`);
            }
            if (typeof plugin !== 'function') {
                throw new Error(`Illegal plugin for "${ name }", must be a function, was ${ typeof plugin }.`);
            }
            pluginStorage[name] = plugin;
            if (name !== BASE_PLUGIN_NAME) {
                if (Plugin.isBasic(plugin)) {
                    Player.prototype[name] = createBasicPlugin(name, plugin);
                } else {
                    Player.prototype[name] = createPluginFactory(name, plugin);
                }
            }
            return plugin;
        }
        static deregisterPlugin(name) {
            if (name === BASE_PLUGIN_NAME) {
                throw new Error('Cannot de-register base plugin.');
            }
            if (pluginExists(name)) {
                delete pluginStorage[name];
                delete Player.prototype[name];
            }
        }
        static getPlugins(names = Object.keys(pluginStorage)) {
            let result;
            names.forEach(name => {
                const plugin = getPlugin(name);
                if (plugin) {
                    result = result || {};
                    result[name] = plugin;
                }
            });
            return result;
        }
        static getPluginVersion(name) {
            const plugin = getPlugin(name);
            return plugin && plugin.VERSION || '';
        }
    }
    Plugin.getPlugin = getPlugin;
    Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
    Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
    Player.prototype.usingPlugin = function (name) {
        return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
    };
    Player.prototype.hasPlugin = function (name) {
        return !!pluginExists(name);
    };
    return Plugin;
});
define('skylark-videojs/video',[
    "skylark-langx-globals/window",
    'skylark-net-http/xhr',
    './setup',
    './utils/stylesheet',
    './component',
    './event-target',
    './utils/events',
    './player',
    './plugin',
    './utils/merge-options',
    './utils/fn',
    './tracks/text-track',
    './tracks/audio-track',
    './tracks/video-track',
    './utils/time-ranges',
    './utils/format-time',
    './utils/log',
    './utils/dom',
    './utils/browser',
    './utils/url',
    './utils/obj',
    './utils/computed-style',
    ///'./extend',
    './tech/tech',
    './tech/middleware',
    './utils/define-lazy-property'
], function (
    window,
    xhr,
    setup, 
    stylesheet, 
    Component, 
    EventTarget, 
    Events, 
    Player, 
    Plugin, 
    mergeOptions, 
    Fn, 
    TextTrack, 
    AudioTrack, 
    VideoTrack, 
    timeRanges, 
    formatTime, 
    log, 
    Dom, 
    browser, 
    Url, 
    obj, 
    computedStyle, 
    ///extend, 
    Tech, 
    middleware, 
    defineLazyProperty
) {
    'use strict';

    var middlewareUse = middleware.use,
        TERMINATOR = middleware.TERMINATOR;


    const normalizeId = id => id.indexOf('#') === 0 ? id.slice(1) : id;
    function videojs(id, options, ready) {
        let player = videojs.getPlayer(id);
        if (player) {
            if (options) {
                log.warn(`Player "${ id }" is already initialised. Options will not be applied.`);
            }
            if (ready) {
                player.ready(ready);
            }
            return player;
        }
        const el = typeof id === 'string' ? Dom.$('#' + normalizeId(id)) : id;
        if (!Dom.isEl(el)) {
            throw new TypeError('The element or ID supplied is not valid. (videojs)');
        }
        if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {
            log.warn('The element supplied is not included in the DOM');
        }
        options = options || {};
        videojs.hooks('beforesetup').forEach(hookFunction => {
            const opts = hookFunction(el, mergeOptions(options));
            if (!obj.isObject(opts) || Array.isArray(opts)) {
                log.error('please return an object in beforesetup hooks');
                return;
            }
            options = mergeOptions(options, opts);
        });
        const PlayerComponent = Component.getComponent('Player');
        player = new PlayerComponent(el, options, ready);
        videojs.hooks('setup').forEach(hookFunction => hookFunction(player));
        return player;
    }
    videojs.hooks_ = {};
    videojs.hooks = function (type, fn) {
        videojs.hooks_[type] = videojs.hooks_[type] || [];
        if (fn) {
            videojs.hooks_[type] = videojs.hooks_[type].concat(fn);
        }
        return videojs.hooks_[type];
    };
    videojs.hook = function (type, fn) {
        videojs.hooks(type, fn);
    };
    videojs.hookOnce = function (type, fn) {
        videojs.hooks(type, [].concat(fn).map(original => {
            const wrapper = (...args) => {
                videojs.removeHook(type, wrapper);
                return original(...args);
            };
            return wrapper;
        }));
    };
    videojs.removeHook = function (type, fn) {
        const index = videojs.hooks(type).indexOf(fn);
        if (index <= -1) {
            return false;
        }
        videojs.hooks_[type] = videojs.hooks_[type].slice();
        videojs.hooks_[type].splice(index, 1);
        return true;
    };
    if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && Dom.isReal()) {
        let style = Dom.$('.vjs-styles-defaults');
        if (!style) {
            style = stylesheet.createStyleElement('vjs-styles-defaults');
            const head = Dom.$('head');
            if (head) {
                head.insertBefore(style, head.firstChild);
            }
            stylesheet.setTextContent(style, `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid {
        padding-top: 56.25%
      }
    `);
        }
    }
    setup.autoSetupTimeout(1, videojs);
    videojs.VERSION = "7.11.5";
    videojs.options = Player.prototype.options_;
    videojs.getPlayers = () => Player.players;
    videojs.getPlayer = id => {
        const players = Player.players;
        let tag;
        if (typeof id === 'string') {
            const nId = normalizeId(id);
            const player = players[nId];
            if (player) {
                return player;
            }
            tag = Dom.$('#' + nId);
        } else {
            tag = id;
        }
        if (Dom.isEl(tag)) {
            const {player, playerId} = tag;
            if (player || players[playerId]) {
                return player || players[playerId];
            }
        }
    };
    videojs.getAllPlayers = () => Object.keys(Player.players).map(k => Player.players[k]).filter(Boolean);
    videojs.players = Player.players;
    videojs.getComponent = Component.getComponent;
    videojs.registerComponent = (name, comp) => {
        if (Tech.isTech(comp)) {
            log.warn(`The ${ name } tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);
        }
        Component.registerComponent.call(Component, name, comp);
    };
    videojs.getTech = Tech.getTech;
    videojs.registerTech = Tech.registerTech;
    videojs.use = middlewareUse;
    Object.defineProperty(videojs, 'middleware', {
        value: {},
        writeable: false,
        enumerable: true
    });
    Object.defineProperty(videojs.middleware, 'TERMINATOR', {
        value: TERMINATOR,
        writeable: false,
        enumerable: true
    });
    videojs.browser = browser;
    videojs.TOUCH_ENABLED = browser.TOUCH_ENABLED;
    ///videojs.extend = extend;
    videojs.mergeOptions = mergeOptions;
    videojs.bind = Fn.bind;
    videojs.registerPlugin = Plugin.registerPlugin;
    videojs.deregisterPlugin = Plugin.deregisterPlugin;
    videojs.plugin = (name, plugin) => {
        log.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');
        return Plugin.registerPlugin(name, plugin);
    };
    videojs.getPlugins = Plugin.getPlugins;
    videojs.getPlugin = Plugin.getPlugin;
    videojs.getPluginVersion = Plugin.getPluginVersion;
    videojs.addLanguage = function (code, data) {
        code = ('' + code).toLowerCase();
        videojs.options.languages = mergeOptions(videojs.options.languages, { [code]: data });
        return videojs.options.languages[code];
    };
    videojs.log = log;
    videojs.createLogger = log.createLogger;
    videojs.createTimeRange = videojs.undefined = timeRanges.createTimeRanges;
    videojs.formatTime = formatTime;
    videojs.setFormatTime = formatTime.setFormatTime;
    videojs.resetFormatTime = formatTime.resetFormatTime;
    videojs.parseUrl = Url.parseUrl;
    videojs.isCrossOrigin = Url.isCrossOrigin;
    videojs.EventTarget = EventTarget;
    videojs.on = Events.on;
    videojs.one = Events.one;
    videojs.off = Events.off;
    videojs.trigger = Events.trigger;
    videojs.xhr = xhr;
    videojs.TextTrack = TextTrack;
    videojs.AudioTrack = AudioTrack;
    videojs.VideoTrack = VideoTrack;
    [
        'isEl',
        'isTextNode',
        'createEl',
        'hasClass',
        'addClass',
        'removeClass',
        'toggleClass',
        'setAttributes',
        'getAttributes',
        'emptyEl',
        'appendContent',
        'insertContent'
    ].forEach(k => {
        videojs[k] = function () {
            log.warn(`videojs.${ k }() is deprecated; use videojs.dom.${ k }() instead`);
            return Dom[k].apply(null, arguments);
        };
    });
    videojs.computedStyle = computedStyle;
    videojs.dom = Dom;
    videojs.url = Url;
    videojs.defineLazyProperty = defineLazyProperty;
    return videojs;
});
define('skylark-videojs/main',[
	'skylark-langx/skylark',
    './video'
//    '@videojs/http-streaming'
], function (skylark,videojs) {
    'use strict';

    return skylark.attach("intg.videojs",videojs);
});
define('skylark-videojs', ['skylark-videojs/main'], function (main) { return main; });


},this);
//# sourceMappingURL=sourcemaps/skylark-videojs-all.js.map
