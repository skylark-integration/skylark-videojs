{"version":3,"sources":["utils/dom.js"],"names":["define","window","document","domx","fs","log","obj","computedStyle","browser","isNonBlankString","str","Boolean","trim","isEl","value","isObject","nodeType","createQuerier","method","selector","context","querySelector","ctx","findPosition","el","offsetParent","left","top","width","height","offsetWidth","offsetHeight","fullscreenElement","offsetLeft","offsetTop","normalizeContent","content","Array","isArray","map","test","createTextNode","filter","isReal","noder","isElement","isInFrame","createEl","tagName","properties","attributes","createElement","append","textContent","data","text","prependTo","child","parent","prepend","hasClass","styler","addClass","removeClass","toggleClass","toogleClass","setAttributes","attr","getAttributes","tag","knownBooleans","length","attrs","i","attrName","name","attrVal","indexOf","getAttribute","setAttribute","removeAttribute","removeAttr","blockTextSelection","body","focus","onselectstart","unblockTextSelection","getBoundingClientRect","parentNode","rect","result","forEach","k","undefined","parseFloat","geom","pageRect","getPointerPosition","event","translated","x","y","IS_IOS","item","nodeName","toLowerCase","transform","values","slice","split","Number","position","boxTarget","target","box","boxW","boxH","offsetY","offsetX","changedTouches","pageX","pageY","Math","max","min","isTextNode","emptyEl","empty","appendContent","insertContent","isSingleLeftClick","button","buttons","type","$","finder","find","$$","findAll"],"mappings":"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","file":"../../utils/dom.js","sourcesContent":["define([\n    \"skylark-langx-globals/window\",\n    \"skylark-langx-globals/document\",   \n    \"skylark-domx\",\n    '../fullscreen-api',\n    './log',\n    './obj',\n    './computed-style',\n    './browser'\n], function (window,document,domx,fs, log, obj, computedStyle, browser) {\n    'use strict';\n    function isNonBlankString(str) {\n        return typeof str === 'string' && Boolean(str.trim());\n    }\n    function throwIfWhitespace(str) {\n        if (str.indexOf(' ') >= 0) {\n            throw new Error('class has illegal whitespace characters');\n        }\n    }\n    function classRegExp(className) {\n        return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n    }\n\n    function isEl(value) {\n        return obj.isObject(value) && value.nodeType === 1;\n    }\n    function isInFrame() {\n        try {\n            return window.parent !== window.self;\n        } catch (x) {\n            return true;\n        }\n    }\n    function createQuerier(method) {\n        return function (selector, context) {\n            if (!isNonBlankString(selector)) {\n                return document[method](null);\n            }\n            if (isNonBlankString(context)) {\n                context = document.querySelector(context);\n            }\n            const ctx = isEl(context) ? context : document;\n            return ctx[method] && ctx[method](selector);\n        };\n    }\n    function createEl(tagName = 'div', properties = {}, attributes = {}, content) {\n        const el = document.createElement(tagName);\n        Object.getOwnPropertyNames(properties).forEach(function (propName) {\n            const val = properties[propName];\n            if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n                log.warn('Setting attributes in the second argument of createEl()\\n' + 'has been deprecated. Use the third argument instead.\\n' + `createEl(type, properties, attributes). Attempting to set ${ propName } to ${ val }.`);\n                el.setAttribute(propName, val);\n            } else if (propName === 'textContent') {\n                textContent(el, val);\n            } else if (el[propName] !== val || propName === 'tabIndex') {\n                el[propName] = val;\n            }\n        });\n        Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n            el.setAttribute(attrName, attributes[attrName]);\n        });\n        if (content) {\n            appendContent(el, content);\n        }\n        return el;\n    }\n    function textContent(el, text) {\n        if (typeof el.textContent === 'undefined') {\n            el.innerText = text;\n        } else {\n            el.textContent = text;\n        }\n        return el;\n    }\n    function prependTo(child, parent) {\n        if (parent.firstChild) {\n            parent.insertBefore(child, parent.firstChild);\n        } else {\n            parent.appendChild(child);\n        }\n    }\n    function hasClass(element, classToCheck) {\n        throwIfWhitespace(classToCheck);\n        if (element.classList) {\n            return element.classList.contains(classToCheck);\n        }\n        return classRegExp(classToCheck).test(element.className);\n    }\n    function addClass(element, classToAdd) {\n        if (element.classList) {\n            element.classList.add(classToAdd);\n        } else if (!hasClass(element, classToAdd)) {\n            element.className = (element.className + ' ' + classToAdd).trim();\n        }\n        return element;\n    }\n    function removeClass(element, classToRemove) {\n        if (element.classList) {\n            element.classList.remove(classToRemove);\n        } else {\n            throwIfWhitespace(classToRemove);\n            element.className = element.className.split(/\\s+/).filter(function (c) {\n                return c !== classToRemove;\n            }).join(' ');\n        }\n        return element;\n    }\n    function toggleClass(element, classToToggle, predicate) {\n        const has = hasClass(element, classToToggle);\n        if (typeof predicate === 'function') {\n            predicate = predicate(element, classToToggle);\n        }\n        if (typeof predicate !== 'boolean') {\n            predicate = !has;\n        }\n        if (predicate === has) {\n            return;\n        }\n        if (predicate) {\n            addClass(element, classToToggle);\n        } else {\n            removeClass(element, classToToggle);\n        }\n        return element;\n    }\n    function setAttributes(el, attributes) {\n        Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n            const attrValue = attributes[attrName];\n            if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n                el.removeAttribute(attrName);\n            } else {\n                el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n            }\n        });\n    }\n    function getAttributes(tag) {\n        const obj = {};\n        const knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n        if (tag && tag.attributes && tag.attributes.length > 0) {\n            const attrs = tag.attributes;\n            for (let i = attrs.length - 1; i >= 0; i--) {\n                const attrName = attrs[i].name;\n                let attrVal = attrs[i].value;\n                if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n                    attrVal = attrVal !== null ? true : false;\n                }\n                obj[attrName] = attrVal;\n            }\n        }\n        return obj;\n    }\n    function getAttribute(el, attribute) {\n        return el.getAttribute(attribute);\n    }\n    function setAttribute(el, attribute, value) {\n        el.setAttribute(attribute, value);\n    }\n    function removeAttribute(el, attribute) {\n        el.removeAttribute(attribute);\n    }\n    function blockTextSelection() {\n        document.body.focus();\n        document.onselectstart = function () {\n            return false;\n        };\n    }\n    function unblockTextSelection() {\n        document.onselectstart = function () {\n            return true;\n        };\n    }\n    function getBoundingClientRect(el) {\n        if (el && el.getBoundingClientRect && el.parentNode) {\n            const rect = el.getBoundingClientRect();\n            const result = {};\n            [\n                'bottom',\n                'height',\n                'left',\n                'right',\n                'top',\n                'width'\n            ].forEach(k => {\n                if (rect[k] !== undefined) {\n                    result[k] = rect[k];\n                }\n            });\n            if (!result.height) {\n                result.height = parseFloat(computedStyle(el, 'height'));\n            }\n            if (!result.width) {\n                result.width = parseFloat(computedStyle(el, 'width'));\n            }\n            return result;\n        }\n    }\n    function findPosition(el) {\n        if (!el || el && !el.offsetParent) {\n            return {\n                left: 0,\n                top: 0,\n                width: 0,\n                height: 0\n            };\n        }\n        const width = el.offsetWidth;\n        const height = el.offsetHeight;\n        let left = 0;\n        let top = 0;\n        while (el.offsetParent && el !== document[fs.fullscreenElement]) {\n            left += el.offsetLeft;\n            top += el.offsetTop;\n            el = el.offsetParent;\n        }\n        return {\n            left,\n            top,\n            width,\n            height\n        };\n    }\n    function getPointerPosition(el, event) {\n        const translated = {\n            x: 0,\n            y: 0\n        };\n        if (browser.IS_IOS) {\n            let item = el;\n            while (item && item.nodeName.toLowerCase() !== 'html') {\n                const transform = computedStyle(item, 'transform');\n                if (/^matrix/.test(transform)) {\n                    const values = transform.slice(7, -1).split(/,\\s/).map(Number);\n                    translated.x += values[4];\n                    translated.y += values[5];\n                } else if (/^matrix3d/.test(transform)) {\n                    const values = transform.slice(9, -1).split(/,\\s/).map(Number);\n                    translated.x += values[12];\n                    translated.y += values[13];\n                }\n                item = item.parentNode;\n            }\n        }\n        const position = {};\n        const boxTarget = findPosition(event.target);\n        const box = findPosition(el);\n        const boxW = box.width;\n        const boxH = box.height;\n        let offsetY = event.offsetY - (box.top - boxTarget.top);\n        let offsetX = event.offsetX - (box.left - boxTarget.left);\n        if (event.changedTouches) {\n            offsetX = event.changedTouches[0].pageX - box.left;\n            offsetY = event.changedTouches[0].pageY + box.top;\n            if (browser.IS_IOS) {\n                offsetX -= translated.x;\n                offsetY -= translated.y;\n            }\n        }\n        position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));\n        position.x = Math.max(0, Math.min(1, offsetX / boxW));\n        return position;\n    }\n    function isTextNode(value) {\n        return obj.isObject(value) && value.nodeType === 3;\n    }\n    function emptyEl(el) {\n        while (el.firstChild) {\n            el.removeChild(el.firstChild);\n        }\n        return el;\n    }\n    function normalizeContent(content) {\n        if (typeof content === 'function') {\n            content = content();\n        }\n        return (Array.isArray(content) ? content : [content]).map(value => {\n            if (typeof value === 'function') {\n                value = value();\n            }\n            if (isEl(value) || isTextNode(value)) {\n                return value;\n            }\n            if (typeof value === 'string' && /\\S/.test(value)) {\n                return document.createTextNode(value);\n            }\n        }).filter(value => value);\n    }\n    function appendContent(el, content) {\n        normalizeContent(content).forEach(node => el.appendChild(node));\n        return el;\n    }\n    function insertContent(el, content) {\n        return appendContent(emptyEl(el), content);\n    }\n    function isSingleLeftClick(event) {\n        if (event.button === undefined && event.buttons === undefined) {\n            return true;\n        }\n        if (event.button === 0 && event.buttons === undefined) {\n            return true;\n        }\n        if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {\n            return true;\n        }\n        if (event.button !== 0 || event.buttons !== 1) {\n            return false;\n        }\n        return true;\n    }\n    const $ = createQuerier('querySelector');\n    const $$ = createQuerier('querySelectorAll');\n    return {\n        isReal: browser.isReal,\n        isEl: domx.noder.isElement,// isEl,\n        isInFrame: domx.noder.isInFrame, //isInFrame,\n        createEl:  function (tagName = 'div', properties = {}, attributes = {}, content) { //createEl,\n            var el  = domx.noder.createElement(tagName,properties,attributes);\n            if (content) {\n                domx.noder.append(el,content)\n            }\n            return el;\n        }, \n        textContent: domx.data.text, //textContent,\n        prependTo: function (child, parent) { //prependTo,\n            domx.noder.prepend(parent,child);\n        },\n        hasClass: domx.styler.hasClass, //hasClass,\n        addClass: domx.styler.addClass,  //addClass,\n        removeClass: domx.styler.removeClass, //removeClass,\n        toggleClass: domx.styler.toogleClass, //toggleClass,\n        setAttributes: domx.data.attr, // setAttributes,\n        getAttributes: getAttributes,\n        getAttribute: domx.data.attr, //getAttribute,\n        setAttribute: domx.data.attr, //setAttribute,\n        removeAttribute: domx.data.removeAttr, //removeAttribute,\n        blockTextSelection: blockTextSelection,\n        unblockTextSelection: unblockTextSelection,\n        getBoundingClientRect: getBoundingClientRect,\n        findPosition: domx.geom.pageRect, //findPosition,\n        getPointerPosition: getPointerPosition,\n        isTextNode: domx.noder.isTextNode,// isTextNode,\n        emptyEl: domx.noder.empty, //emptyEl,\n        normalizeContent: normalizeContent,\n        appendContent: domx.noder.append,//appendContent,\n        insertContent: function(el,content) { //insertContent,\n            domx.noder.empty(el);\n            domx.noder.append(el,content);\n            return el;\n        },\n        isSingleLeftClick: isSingleLeftClick,\n        $: function(selector,context) {\n            context = context || document;\n            return domx.finder.find(context,selector);\n        },\n        $$: function(selector,context) {\n            context = context || document;\n            return domx.finder.findAll(context,selector);\n        }\n    };\n});"]}