{"version":3,"sources":["plugin.js"],"names":["define","evented","stateful","Events","Fn","log","Player","BASE_PLUGIN_NAME","PLUGIN_CACHE_KEY","pluginStorage","pluginExists","name","hasOwnProperty","getPlugin","undefined","markPluginAsActive","player","triggerSetupEvent","hash","before","eventName","trigger","createBasicPlugin","plugin","basicPluginWrapper","this","instance","apply","arguments","Object","keys","forEach","prop","createPluginFactory","PluginSubClass","prototype","args","getEventHash","Plugin","[object Object]","constructor","Error","createLogger","defaultState","dispose","bind","on","VERSION","event","eventBusEl_","e","unlistenTo","off","state","p","isPrototypeOf","warn","isBasic","names","result","registerPlugin","usingPlugin","hasPlugin"],"mappings":"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","file":"../plugin.js","sourcesContent":["define([\n    './mixins/evented',\n    './mixins/stateful',\n    './utils/events',\n    './utils/fn',\n    './utils/log',\n    './player'\n], function (evented, stateful, Events, Fn, log, Player) {\n    'use strict';\n    const BASE_PLUGIN_NAME = 'plugin';\n    const PLUGIN_CACHE_KEY = 'activePlugins_';\n    const pluginStorage = {};\n    const pluginExists = name => pluginStorage.hasOwnProperty(name);\n    const getPlugin = name => pluginExists(name) ? pluginStorage[name] : undefined;\n    const markPluginAsActive = (player, name) => {\n        player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\n        player[PLUGIN_CACHE_KEY][name] = true;\n    };\n    const triggerSetupEvent = (player, hash, before) => {\n        const eventName = (before ? 'before' : '') + 'pluginsetup';\n        player.trigger(eventName, hash);\n        player.trigger(eventName + ':' + hash.name, hash);\n    };\n    const createBasicPlugin = function (name, plugin) {\n        const basicPluginWrapper = function () {\n            triggerSetupEvent(this, {\n                name,\n                plugin,\n                instance: null\n            }, true);\n            const instance = plugin.apply(this, arguments);\n            markPluginAsActive(this, name);\n            triggerSetupEvent(this, {\n                name,\n                plugin,\n                instance\n            });\n            return instance;\n        };\n        Object.keys(plugin).forEach(function (prop) {\n            basicPluginWrapper[prop] = plugin[prop];\n        });\n        return basicPluginWrapper;\n    };\n    const createPluginFactory = (name, PluginSubClass) => {\n        PluginSubClass.prototype.name = name;\n        return function (...args) {\n            triggerSetupEvent(this, {\n                name,\n                plugin: PluginSubClass,\n                instance: null\n            }, true);\n            const instance = new PluginSubClass(...[\n                this,\n                ...args\n            ]);\n            this[name] = () => instance;\n            triggerSetupEvent(this, instance.getEventHash());\n            return instance;\n        };\n    };\n    class Plugin {\n        constructor(player) {\n            if (this.constructor === Plugin) {\n                throw new Error('Plugin must be sub-classed; not directly instantiated.');\n            }\n            this.player = player;\n            if (!this.log) {\n                this.log = this.player.log.createLogger(this.name);\n            }\n            evented(this);\n            delete this.trigger;\n            stateful(this, this.constructor.defaultState);\n            markPluginAsActive(player, this.name);\n            this.dispose = Fn.bind(this, this.dispose);\n            player.on('dispose', this.dispose);\n        }\n        version() {\n            return this.constructor.VERSION;\n        }\n        getEventHash(hash = {}) {\n            hash.name = this.name;\n            hash.plugin = this.constructor;\n            hash.instance = this;\n            return hash;\n        }\n        trigger(event, hash = {}) {\n            return Events.trigger(this.eventBusEl_, event, this.getEventHash(hash));\n        }\n        handleStateChanged(e) {\n        }\n        dispose() {\n            const {name, player} = this;\n            this.trigger('dispose');\n            this.unlistenTo();\n            player.off('dispose', this.dispose);\n            player[PLUGIN_CACHE_KEY][name] = false;\n            this.player = this.state = null;\n            player[name] = createPluginFactory(name, pluginStorage[name]);\n        }\n        static isBasic(plugin) {\n            const p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\n            return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\n        }\n        static registerPlugin(name, plugin) {\n            if (typeof name !== 'string') {\n                throw new Error(`Illegal plugin name, \"${ name }\", must be a string, was ${ typeof name }.`);\n            }\n            if (pluginExists(name)) {\n                log.warn(`A plugin named \"${ name }\" already exists. You may want to avoid re-registering plugins!`);\n            } else if (Player.prototype.hasOwnProperty(name)) {\n                throw new Error(`Illegal plugin name, \"${ name }\", cannot share a name with an existing player method!`);\n            }\n            if (typeof plugin !== 'function') {\n                throw new Error(`Illegal plugin for \"${ name }\", must be a function, was ${ typeof plugin }.`);\n            }\n            pluginStorage[name] = plugin;\n            if (name !== BASE_PLUGIN_NAME) {\n                if (Plugin.isBasic(plugin)) {\n                    Player.prototype[name] = createBasicPlugin(name, plugin);\n                } else {\n                    Player.prototype[name] = createPluginFactory(name, plugin);\n                }\n            }\n            return plugin;\n        }\n        static deregisterPlugin(name) {\n            if (name === BASE_PLUGIN_NAME) {\n                throw new Error('Cannot de-register base plugin.');\n            }\n            if (pluginExists(name)) {\n                delete pluginStorage[name];\n                delete Player.prototype[name];\n            }\n        }\n        static getPlugins(names = Object.keys(pluginStorage)) {\n            let result;\n            names.forEach(name => {\n                const plugin = getPlugin(name);\n                if (plugin) {\n                    result = result || {};\n                    result[name] = plugin;\n                }\n            });\n            return result;\n        }\n        static getPluginVersion(name) {\n            const plugin = getPlugin(name);\n            return plugin && plugin.VERSION || '';\n        }\n    }\n    Plugin.getPlugin = getPlugin;\n    Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\n    Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\n    Player.prototype.usingPlugin = function (name) {\n        return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\n    };\n    Player.prototype.hasPlugin = function (name) {\n        return !!pluginExists(name);\n    };\n    return Plugin;\n});"]}