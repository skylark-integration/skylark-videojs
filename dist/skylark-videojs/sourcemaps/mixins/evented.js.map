{"version":3,"sources":["mixins/evented.js"],"names":["define","Dom","Events","Fn","Obj","EventTarget","log","objName","obj","name","name_","constructor","isEvented","object","eventBusEl_","every","k","isValidEventType","type","test","Array","isArray","length","validateTarget","target","fnName","nodeName","Error","validateEventType","validateListener","listener","normalizeListenArgs","self","args","isTargetingSelf","shift","bind","listen","method","EventedMixin","[object Object]","this","removeListenerOnDispose","off","guid","removeRemoverOnTargetDispose","wrapper","largs","apply","targetOrType","typeOrListener","event","hash","error","trigger","evented","options","eventBusKey","createEl","className","assign","eventedCallbacks","forEach","callback","on","window","setTimeout","addEventedCallback","push"],"mappings":";;;;;;;AAAAA,QACI,eACA,kBACA,cACA,eACA,kBACA,gBACD,SAAUC,EAAKC,EAAQC,EAAIC,EAAKC,EAAaC,GAC5C,aACA,MAAMC,EAAUC,GACY,mBAAbA,EAAIC,KACJD,EAAIC,OAES,iBAAbD,EAAIC,KACJD,EAAIC,KAEXD,EAAIE,MACGF,EAAIE,MAEXF,EAAIG,aAAeH,EAAIG,YAAYF,KAC5BD,EAAIG,YAAYF,YAEbD,EAEZI,EAAYC,GAAUA,aAAkBR,KAAiBQ,EAAOC,cAClE,KACA,MACA,MACA,WACFC,MAAMC,GAA0B,mBAAdH,EAAOG,IAWrBC,EAAmBC,GAAwB,iBAATA,GAAqB,KAAKC,KAAKD,IAASE,MAAMC,QAAQH,MAAWA,EAAKI,OACxGC,EAAiB,CAACC,EAAQhB,EAAKiB,KACjC,IAAKD,IAAWA,EAAOE,WAAad,EAAUY,GAC1C,MAAM,IAAIG,4BAA6BpB,EAAQC,MAAUiB,6CAG3DG,EAAoB,CAACV,EAAMV,EAAKiB,KAClC,IAAKR,EAAiBC,GAClB,MAAM,IAAIS,gCAAiCpB,EAAQC,MAAUiB,4CAG/DI,EAAmB,CAACC,EAAUtB,EAAKiB,KACrC,GAAwB,mBAAbK,EACP,MAAM,IAAIH,8BAA+BpB,EAAQC,MAAUiB,2BAG7DM,EAAsB,CAACC,EAAMC,EAAMR,KACrC,MAAMS,EAAkBD,EAAKX,OAAS,GAAKW,EAAK,KAAOD,GAAQC,EAAK,KAAOD,EAAKlB,YAChF,IAAIU,EACAN,EACAY,EAcJ,OAbII,GACAV,EAASQ,EAAKlB,YACVmB,EAAKX,QAAU,GACfW,EAAKE,SAERjB,EAAMY,GAAYG,IAElBT,EAAQN,EAAMY,GAAYG,EAE/BV,EAAeC,EAAQQ,EAAMP,GAC7BG,EAAkBV,EAAMc,EAAMP,GAC9BI,EAAiBC,EAAUE,EAAMP,IAG7BS,gBAAAA,EACAV,OAAAA,EACAN,KAAAA,EACAY,SALJA,EAAW3B,EAAGiC,KAAKJ,EAAMF,KAQvBO,EAAS,CAACb,EAAQc,EAAQpB,EAAMY,KAClCP,EAAeC,EAAQA,EAAQc,GAC3Bd,EAAOE,SACPxB,EAAOoC,GAAQd,EAAQN,EAAMY,GAE7BN,EAAOc,GAAQpB,EAAMY,IAGvBS,GACFC,MAAMP,GACF,MAAMC,gBAACA,EAAeV,OAAEA,EAAMN,KAAEA,EAAIY,SAAEA,GAAYC,EAAoBU,KAAMR,EAAM,MAElF,GADAI,EAAOb,EAAQ,KAAMN,EAAMY,IACtBI,EAAiB,CAClB,MAAMQ,EAA0B,IAAMD,KAAKE,IAAInB,EAAQN,EAAMY,GAC7DY,EAAwBE,KAAOd,EAASc,KACxC,MAAMC,EAA+B,IAAMJ,KAAKE,IAAI,UAAWD,GAC/DG,EAA6BD,KAAOd,EAASc,KAC7CP,EAAOI,KAAM,KAAM,UAAWC,GAC9BL,EAAOb,EAAQ,KAAM,UAAWqB,KAGxCL,OAAOP,GACH,MAAMC,gBAACA,EAAeV,OAAEA,EAAMN,KAAEA,EAAIY,SAAEA,GAAYC,EAAoBU,KAAMR,EAAM,OAClF,GAAIC,EACAG,EAAOb,EAAQ,MAAON,EAAMY,OACzB,CACH,MAAMgB,EAAU,IAAIC,KAChBN,KAAKE,IAAInB,EAAQN,EAAM4B,GACvBhB,EAASkB,MAAM,KAAMD,IAEzBD,EAAQF,KAAOd,EAASc,KACxBP,EAAOb,EAAQ,MAAON,EAAM4B,KAGpCN,OAAOP,GACH,MAAMC,gBAACA,EAAeV,OAAEA,EAAMN,KAAEA,EAAIY,SAAEA,GAAYC,EAAoBU,KAAMR,EAAM,OAClF,GAAIC,EACAG,EAAOb,EAAQ,MAAON,EAAMY,OACzB,CACH,MAAMgB,EAAU,IAAIC,KAChBN,KAAKE,IAAInB,EAAQN,EAAM4B,GACvBhB,EAASkB,MAAM,KAAMD,IAEzBD,EAAQF,KAAOd,EAASc,KACxBP,EAAOb,EAAQ,MAAON,EAAM4B,KAGpCN,IAAIS,EAAcC,EAAgBpB,GAC9B,IAAKmB,GAAgBhC,EAAiBgC,GAClC/C,EAAOyC,IAAIF,KAAK3B,YAAamC,EAAcC,OACxC,CACH,MAAM1B,EAASyB,EACT/B,EAAOgC,EACb3B,EAAeC,EAAQiB,KAAM,OAC7Bb,EAAkBV,EAAMuB,KAAM,OAC9BZ,EAAiBC,EAAUW,KAAM,OACjCX,EAAW3B,EAAGiC,KAAKK,KAAMX,GACzBW,KAAKE,IAAI,UAAWb,GAChBN,EAAOE,UACPxB,EAAOyC,IAAInB,EAAQN,EAAMY,GACzB5B,EAAOyC,IAAInB,EAAQ,UAAWM,IACvBlB,EAAUY,KACjBA,EAAOmB,IAAIzB,EAAMY,GACjBN,EAAOmB,IAAI,UAAWb,MAIlCU,QAAQW,EAAOC,GACX7B,EAAekB,KAAK3B,YAAa2B,KAAM,WACvC,MAAMvB,EAAOiC,GAA0B,iBAAVA,EAAqBA,EAAMjC,KAAOiC,EAC/D,IAAKlC,EAAiBC,GAAO,CACzB,MAAMmC,4BAAmC9C,EAAQkC,kBAAqB,mFACtE,IAAIU,EAGA,MAAM,IAAIxB,MAAM0B,IAFfZ,KAAKnC,KAAOA,GAAK+C,MAAMA,GAKhC,OAAOnD,EAAOoD,QAAQb,KAAK3B,YAAaqC,EAAOC,KAGvD,SAASG,EAAQ/B,EAAQgC,MACrB,MAAMC,YAACA,GAAeD,EACtB,GAAIC,EAAa,CACb,IAAKjC,EAAOiC,GAAa/B,SACrB,MAAM,IAAIC,0BAA2B8B,oCAEzCjC,EAAOV,YAAcU,EAAOiC,QAE5BjC,EAAOV,YAAcb,EAAIyD,SAAS,QAAUC,UAAW,kBAc3D,OAZAvD,EAAIwD,OAAOpC,EAAQe,GACff,EAAOqC,kBACPrC,EAAOqC,iBAAiBC,QAAQC,IAC5BA,MAGRvC,EAAOwC,GAAG,UAAW,KACjBxC,EAAOmB,MACPsB,OAAOC,WAAW,KACd1C,EAAOV,YAAc,MACtB,KAEAU,EAMX,OAHA+B,EAAQ3C,UAAYA,EACpB2C,EAAQY,mBA9JmB,EAAC3C,EAAQuC,KAC5BnD,EAAUY,GACVuC,KAEKvC,EAAOqC,mBACRrC,EAAOqC,qBAEXrC,EAAOqC,iBAAiBO,KAAKL,MAyJ9BR","file":"../../mixins/evented.js","sourcesContent":["define([\n    '../utils/dom',\n    '../utils/events',\n    '../utils/fn',\n    '../utils/obj',\n    '../event-target',\n    '../utils/log'\n], function (Dom, Events, Fn, Obj, EventTarget, log) {\n    'use strict';\n    const objName = obj => {\n        if (typeof obj.name === 'function') {\n            return obj.name();\n        }\n        if (typeof obj.name === 'string') {\n            return obj.name;\n        }\n        if (obj.name_) {\n            return obj.name_;\n        }\n        if (obj.constructor && obj.constructor.name) {\n            return obj.constructor.name;\n        }\n        return typeof obj;\n    };\n    const isEvented = object => object instanceof EventTarget || !!object.eventBusEl_ && [\n        'on',\n        'one',\n        'off',\n        'trigger'\n    ].every(k => typeof object[k] === 'function');\n    const addEventedCallback = (target, callback) => {\n        if (isEvented(target)) {\n            callback();\n        } else {\n            if (!target.eventedCallbacks) {\n                target.eventedCallbacks = [];\n            }\n            target.eventedCallbacks.push(callback);\n        }\n    };\n    const isValidEventType = type => typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length;\n    const validateTarget = (target, obj, fnName) => {\n        if (!target || !target.nodeName && !isEvented(target)) {\n            throw new Error(`Invalid target for ${ objName(obj) }#${ fnName }; must be a DOM node or evented object.`);\n        }\n    };\n    const validateEventType = (type, obj, fnName) => {\n        if (!isValidEventType(type)) {\n            throw new Error(`Invalid event type for ${ objName(obj) }#${ fnName }; must be a non-empty string or array.`);\n        }\n    };\n    const validateListener = (listener, obj, fnName) => {\n        if (typeof listener !== 'function') {\n            throw new Error(`Invalid listener for ${ objName(obj) }#${ fnName }; must be a function.`);\n        }\n    };\n    const normalizeListenArgs = (self, args, fnName) => {\n        const isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n        let target;\n        let type;\n        let listener;\n        if (isTargetingSelf) {\n            target = self.eventBusEl_;\n            if (args.length >= 3) {\n                args.shift();\n            }\n            [type, listener] = args;\n        } else {\n            [target, type, listener] = args;\n        }\n        validateTarget(target, self, fnName);\n        validateEventType(type, self, fnName);\n        validateListener(listener, self, fnName);\n        listener = Fn.bind(self, listener);\n        return {\n            isTargetingSelf,\n            target,\n            type,\n            listener\n        };\n    };\n    const listen = (target, method, type, listener) => {\n        validateTarget(target, target, method);\n        if (target.nodeName) {\n            Events[method](target, type, listener);\n        } else {\n            target[method](type, listener);\n        }\n    };\n    const EventedMixin = {\n        on(...args) {\n            const {isTargetingSelf, target, type, listener} = normalizeListenArgs(this, args, 'on');\n            listen(target, 'on', type, listener);\n            if (!isTargetingSelf) {\n                const removeListenerOnDispose = () => this.off(target, type, listener);\n                removeListenerOnDispose.guid = listener.guid;\n                const removeRemoverOnTargetDispose = () => this.off('dispose', removeListenerOnDispose);\n                removeRemoverOnTargetDispose.guid = listener.guid;\n                listen(this, 'on', 'dispose', removeListenerOnDispose);\n                listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\n            }\n        },\n        one(...args) {\n            const {isTargetingSelf, target, type, listener} = normalizeListenArgs(this, args, 'one');\n            if (isTargetingSelf) {\n                listen(target, 'one', type, listener);\n            } else {\n                const wrapper = (...largs) => {\n                    this.off(target, type, wrapper);\n                    listener.apply(null, largs);\n                };\n                wrapper.guid = listener.guid;\n                listen(target, 'one', type, wrapper);\n            }\n        },\n        any(...args) {\n            const {isTargetingSelf, target, type, listener} = normalizeListenArgs(this, args, 'any');\n            if (isTargetingSelf) {\n                listen(target, 'any', type, listener);\n            } else {\n                const wrapper = (...largs) => {\n                    this.off(target, type, wrapper);\n                    listener.apply(null, largs);\n                };\n                wrapper.guid = listener.guid;\n                listen(target, 'any', type, wrapper);\n            }\n        },\n        off(targetOrType, typeOrListener, listener) {\n            if (!targetOrType || isValidEventType(targetOrType)) {\n                Events.off(this.eventBusEl_, targetOrType, typeOrListener);\n            } else {\n                const target = targetOrType;\n                const type = typeOrListener;\n                validateTarget(target, this, 'off');\n                validateEventType(type, this, 'off');\n                validateListener(listener, this, 'off');\n                listener = Fn.bind(this, listener);\n                this.off('dispose', listener);\n                if (target.nodeName) {\n                    Events.off(target, type, listener);\n                    Events.off(target, 'dispose', listener);\n                } else if (isEvented(target)) {\n                    target.off(type, listener);\n                    target.off('dispose', listener);\n                }\n            }\n        },\n        trigger(event, hash) {\n            validateTarget(this.eventBusEl_, this, 'trigger');\n            const type = event && typeof event !== 'string' ? event.type : event;\n            if (!isValidEventType(type)) {\n                const error = `Invalid event type for ${ objName(this) }#trigger; ` + 'must be a non-empty string or object with a type key that has a non-empty value.';\n                if (event) {\n                    (this.log || log).error(error);\n                } else {\n                    throw new Error(error);\n                }\n            }\n            return Events.trigger(this.eventBusEl_, event, hash);\n        }\n    };\n    function evented(target, options = {}) {\n        const {eventBusKey} = options;\n        if (eventBusKey) {\n            if (!target[eventBusKey].nodeName) {\n                throw new Error(`The eventBusKey \"${ eventBusKey }\" does not refer to an element.`);\n            }\n            target.eventBusEl_ = target[eventBusKey];\n        } else {\n            target.eventBusEl_ = Dom.createEl('span', { className: 'vjs-event-bus' });\n        }\n        Obj.assign(target, EventedMixin);\n        if (target.eventedCallbacks) {\n            target.eventedCallbacks.forEach(callback => {\n                callback();\n            });\n        }\n        target.on('dispose', () => {\n            target.off();\n            window.setTimeout(() => {\n                target.eventBusEl_ = null;\n            }, 0);\n        });\n        return target;\n    }\n\n    evented.isEvented = isEvented;\n    evented.addEventedCallback = addEventedCallback;\n\n    return evented;\n    \n});"]}